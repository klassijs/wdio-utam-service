/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const REIFY_SHADOW_ELEMENT_CONSTANT = '__$UTAM_REIFY_SHADOW$__';
const DEFAULT_PROFILE_NAME = 'default';
const DEFAULT_PROFILE_VALUE = 'impl';

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const SUPPORTED_LOCATOR_STRATEGIES = [
    'css selector',
    'accessibility id',
    '-android uiautomator',
    '-ios class chain',
];
class By {
    constructor(using, value) {
        this.using = this.validateStrategy(using);
        this.value = value;
    }
    validateStrategy(using) {
        /**
         * Type assertion as a workaround until upper-bounded generics lands in TS
         * @see https://github.com/microsoft/TypeScript/issues/26255
         */
        if (!SUPPORTED_LOCATOR_STRATEGIES.includes(using)) {
            throw new Error('Unsupported Locator strategy');
        }
        else {
            return using;
        }
    }
    static accessibilityId(selector) {
        return new By('accessibility id', selector);
    }
    static classChain(selector) {
        return new By('-ios class chain', selector);
    }
    static css(selector) {
        return new By('css selector', selector);
    }
    static uiAutomator(selector) {
        return new By('-android uiautomator', selector);
    }
    toString() {
        return `By(${this.using}, ${this.value})`;
    }
}
function checkLocator(locator) {
    if (locator instanceof By) {
        return locator;
    }
    if (typeof locator === 'function') {
        throw new Error('UTAM core error: locator of type "function" is not yet supported');
    }
    if (locator &&
        typeof locator === 'object' &&
        typeof locator.using === 'string' &&
        typeof locator.value === 'string') {
        return new By(locator.using, locator.value);
    }
    throw new TypeError(`Invalid locator "${JSON.stringify(locator)}"`);
}

/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * traverse DOM to define if element still attached
 *
 * note: method should be in this file to avoid cross dependencies from typescript
 * @param driver instance of driver adapter
 * @param element instance of element adapter
 * @returns boolean true if element is not stale
 */
async function isElementAttachedToDom(driver, element) {
    const STALE_ELEMENT_ERROR = 'stale element reference';
    try {
        // In order to implement isPresent we simply walk up though the DOM structure (including shadows)
        // If we do reach the root document, the DOM element is connected or present
        const isPresentResult = await driver.executeScript(function _isPresent(element) {
            // inline this function here for simplicity (will be parsed every time this method its invoked)
            function connectedToDocument(node, docTarget = document) {
                if (!node) {
                    return false;
                }
                else if (node.parentNode) {
                    return connectedToDocument(node.parentNode, docTarget);
                }
                else if (node.host) {
                    return connectedToDocument(node.host, docTarget);
                }
                else {
                    return node === docTarget;
                }
            }
            return connectedToDocument(element, document);
        }, element);
        return isPresentResult;
    }
    catch (err) {
        if (err.name.includes(STALE_ELEMENT_ERROR) || err.toString().includes(STALE_ELEMENT_ERROR)) {
            return false;
        }
        else {
            throw err;
        }
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const NOT_IMPLEMENTED_ERROR = 'Method not implemented because it is never invoked from this object';
class ShadowRoot {
    constructor(driver, element) {
        this.driver = driver;
        this.contextElement = element;
    }
    findElement(locator) {
        const selectorStr = checkLocator(locator).value;
        return this.driver.waitFor(() => {
            return this.driver.executeScript(function _findElement(element, selector) {
                if (element.shadowRoot) {
                    return element.shadowRoot.querySelector(selector);
                }
                else {
                    throw new Error(`Can't find element with locator '${selector}': its scope does not have shadow root`);
                }
            }, this.contextElement, selectorStr, 
            // This is to give special meaning and semantics to a framework implementation
            // that this executScript should return an Element with context
            REIFY_SHADOW_ELEMENT_CONSTANT);
        }, {
            // use implicit timeout, not waitFor timeout
            timeout: this.driver.config.implicitTimeout,
            message: `Can't find element with locator '${selectorStr}' inside its scope shadow root`,
        });
    }
    findElements(locator) {
        const selectorStr = checkLocator(locator).value;
        return this.driver.waitFor(() => {
            return this.driver.executeScript(function _findElements(element, selector) {
                if (!element.shadowRoot) {
                    throw new Error(`Can't find element with locator '${selector}': scope does not have shadow root.`);
                }
                const elements = element.shadowRoot.querySelectorAll(selector);
                // shadowRoot.querySelectorAll can return an empty array which is not falsy
                if (!elements?.length) {
                    return null;
                }
                return elements;
            }, this.contextElement, selectorStr, 
            // This is to give special meaning and semantics to a framework implementation
            // that this executScript should return an Element with context
            REIFY_SHADOW_ELEMENT_CONSTANT);
        }, {
            // use implicit timeout, not waitFor timeout
            timeout: this.driver.config.implicitTimeout,
            message: `Can't find elements with locator '${selectorStr}' inside its scope shadow root.`,
        });
    }
    async containsElement(locator) {
        // todo - fix mock to use "return (await this.containsElements(locator)) > 0;" instead next block
        const { using, value } = locator;
        if (using !== 'css selector') {
            throw new Error(`Invalid selector strategy "${using}", only css is supported at the moment`);
        }
        const result = await this.driver.executeScript(function _containsFromWithinShadow(element, selector) {
            if (element.shadowRoot) {
                return !!element.shadowRoot.querySelector(selector);
            }
        }, this.contextElement, value);
        return Boolean(result);
    }
    async containsElements(locator) {
        const { using, value } = locator;
        if (using !== 'css selector') {
            throw new Error(`Invalid selector strategy "${using}", only css is supported at the moment`);
        }
        const result = await this.driver.executeScript(function _containsFromWithinShadow(element, selector) {
            if (element.shadowRoot && element.shadowRoot.querySelector(selector)) {
                return element.shadowRoot.querySelectorAll(selector).length;
            }
            return 0;
        }, this.contextElement, value);
        return Number(result);
    }
    getCssValue(cssStyleProperty) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getAttribute(attributeName) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getRect() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    isDisplayed() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    isEnabled() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    hasFocus() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    isExisting() {
        return isElementAttachedToDom(this.driver, this);
    }
    click() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    clearValue() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    addValue(arg) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    setValue(arg) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    press(key, options) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getValue() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getText() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    scrollIntoView(arg) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    moveTo(options) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    dragAndDrop(target, durationSec) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    async flick(offset) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    async blur() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    async focus() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    doubleClick() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    rightClick() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    clickAndHold(durationSec) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function validateElement(element) {
    if (!element) {
        throw new Error(`Undefined element reference: PageObject has been incorrectly initialized`);
    }
    return element;
}
/**
 * base abstract class for a Page Object and an Element
 */
class UtamBase {
    constructor(driver, element, locator) {
        if (!driver) {
            throw new Error('A driver object implementing the UTAM Driver interface must be provided');
        }
        if (!element && !locator) {
            throw new Error('An element implementing the UTAM Element interface or a locator must be provided');
        }
        this.driver = driver;
        this.element = element;
        this.locator = locator;
    }
    /**
     * access to the element instance for subclasses
     * @param utamElement instance of the UTAM element
     * @returns instance of the Element
     */
    getUnwrappedElement(utamElement) {
        if (!utamElement) {
            throw new Error('Error while attempting to access Element on the null or undefined value');
        }
        return validateElement(utamElement.element);
    }
    /**
     * check if element can be found, element is assumed to be not null
     * @returns false if element is stale, true is found, throws and error otherwise
     */
    async isPresent() {
        // with UtamLoader.create for root Page Object we can be in state where element is undefined
        if (!this.element) {
            // method is not always called by PageObject, message has to be agnostic
            throw new Error(`Element has not been initialized properly (element: undefined)`);
        }
        return this.element.isExisting();
    }
    async isVisible() {
        if (await this.isPresent()) {
            return this.element.isDisplayed();
        }
        else {
            return false;
        }
    }
    waitFor(condition, ...args) {
        return this.driver.waitFor(condition, undefined, ...args);
    }
    async waitForAbsence() {
        await this.driver.waitFor(async () => {
            return !(await this.isPresent());
        }, { message: `waitForAbsence method did not complete` });
    }
    async waitForVisible() {
        const isPresent = await this.isPresent();
        if (isPresent) {
            await this.driver.waitFor(async () => {
                return await this.isVisible();
            }, { message: `waitForVisible method did not complete` });
        }
        else {
            throw new Error(`Unable to apply "waitForVisible" method on a stale element`);
        }
    }
    async waitForInvisible() {
        const isPresent = await this.isPresent();
        if (isPresent) {
            await this.driver.waitFor(async () => {
                return !(await this.isVisible());
            }, { message: `waitForInvisible method did not complete` });
        }
        else {
            throw new Error(`Unable to apply "waitForInvisible" method on a stale element`);
        }
    }
    /**
     * checks if there is an element present with the given selector
     * @param locator selector to look for
     * @param expandShadow if set to true, look inside shadow root
     */
    containsElement(locator, expandShadow = false) {
        let element = validateElement(this.element);
        if (expandShadow) {
            element = new ShadowRoot(this.driver, element);
        }
        return element.containsElement(locator);
    }
}
/** mark a page object as a declarative interface */
UtamBase.isInterface = false;
/** default context is web (covers both desktop and webviews) */
UtamBase.mobileContext = 'web';

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * base class for a Page Object element.
 * contains methods to get element state, actions like blur or focus are part of Actionable type
 */
class BaseUtamElement extends UtamBase {
    constructor(driver, element) {
        super(driver, element);
    }
    getElement() {
        const element = validateElement(this.element);
        return element;
    }
    getAttribute(attributeName) {
        if (!attributeName) {
            throw new Error('getAttribute method requires string parameter');
        }
        const element = validateElement(this.element);
        return element.getAttribute(attributeName);
    }
    getClassAttribute() {
        const element = validateElement(this.element);
        return element.getAttribute('class');
    }
    /**
     * Returns the CSS property value from the given CSS Property name
     * @param cssStyleProperty css property name
     * @returns the CSS property value when the property is found, an empty string otherwise
     */
    getCssPropertyValue(cssStyleProperty) {
        const element = validateElement(this.element);
        return element.getCssValue(cssStyleProperty);
    }
    getText() {
        const element = validateElement(this.element);
        return element.getText();
    }
    getTitle() {
        const element = validateElement(this.element);
        return element.getAttribute('title');
    }
    getValue() {
        const element = validateElement(this.element);
        return element.getValue();
    }
    isEnabled() {
        const element = validateElement(this.element);
        return element.isEnabled();
    }
    /**
     * if invoked on the element without shadowRoot, check if current element is active inside driver
     * otherwise check if current element is same as shadowHost.shadowRoot.activeElement
     * @see https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/activeElement
     * @return true if current element is active
     */
    isFocused() {
        const element = validateElement(this.element);
        return element.hasFocus();
    }
    /**
     * get element size and location
     * @returns element size and location
     */
    getRect() {
        const element = validateElement(this.element);
        return element.getRect();
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
class FrameUtamElement extends BaseUtamElement {
    static getUnwrappedElement(frame) {
        const unwrappedElement = frame.getElement();
        if (!unwrappedElement) {
            throw new Error("Can't enter frame element");
        }
        return unwrappedElement;
    }
}

/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Class that enables navigation in both web and mobile contexts
 */
class NavigationUtamElement {
    /**
     * Creates a new navigation object
     * @param driver browser driver instance
     */
    constructor(driver) {
        this._driver = driver;
    }
    /**
     * Navigates one step backward in the current browsing context
     */
    back() {
        return this._driver.back();
    }
    /**
     * Navigates one step backward in the current browsing context
     */
    forward() {
        return this._driver.forward();
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * base class for all Page Objects
 */
class UtamBasePageObject extends UtamBase {
    constructor(driver, element, locator) {
        super(driver, element, locator);
    }
    // This method gets invoked by the loader every time an instance is created
    // Its protected to "reduce" the invokability from user land
    async __beforeLoad__() {
        await this.getRootElement();
    }
    async getRootElement() {
        if (!this.element) {
            throw new Error('Unable to get root element: PageObject has not been initialized properly (element: undefined)');
        }
        const isPresent = await this.isPresent();
        if (!isPresent) {
            throw new Error(`Unable to get root element from pageObject "${this.constructor.name}". The element reference is stale or not in the DOM`);
        }
        return this.element;
    }
    getDocument() {
        return new DocumentUtamElement(this.driver);
    }
    getNavigation() {
        return new NavigationUtamElement(this.driver);
    }
}
/**
 * root Page Object represent higher order Page Objects that are located
 * directly inside browser or driver root
 */
class UtamBaseRootPageObject extends UtamBasePageObject {
    // overrides method from superclass UtamBasePageObject
    // only root page object is allowed to use root locator
    // public because called from tests
    async getRootElement() {
        if (!this.element) {
            if (!this.locator) {
                throw new Error('Unable to find element: No element or locator provided');
            }
            this.element = await this.driver.findElement(this.locator);
        }
        return super.getRootElement();
    }
    // overrides method from superclass UtamBase
    async isPresent() {
        // first try to find root because we can be in a state when it never was found (__beforeLoad__ override)
        if (!this.element) {
            await this.getRootElement();
        }
        return super.isPresent();
    }
    // exposed to access default root locator from Document.containsObject
    __getRootLocator__() {
        if (!this.locator) {
            throw new Error('Root locator is not provided');
        }
        return this.locator;
    }
    // override beforeLoad to wait for root element, which is most common case for root POs
    async __beforeLoad__() {
        await this.waitFor(() => this.getRootElement());
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function resolveWaitMessage(timeoutMsec, message) {
    const timeoutSuffix = `within timeout ${timeoutMsec}ms.`;
    return message ? `${typeof message === 'function' ? message() : message} ${timeoutSuffix}\n` : '';
}
// Type guard that determines if the condition used in polling is a function
function isConditionAFunction(condition) {
    return typeof condition === 'function';
}
/**
 * Wraps the condition function in a promise as that function can either be sync or async.
 *
 * @param condition a sync/async function to wrap in the promise
 * @param args condition function arguments
 * @returns a promise that represents the results of the function invocation
 */
function wrapConditionFn(condition, args) {
    try {
        return Promise.resolve(condition(...args));
    }
    catch (err) {
        // this is needed if condition is regular function (not async) and throws an error
        return Promise.reject(err);
    }
}
/**
 * custom polling wait
 * This code is a version of Selenium wait:
 * https://github.com/SeleniumHQ/selenium/blob/trunk/javascript/node/selenium-webdriver/lib/webdriver.js
 */
function wait(condition, { opt_timeout, opt_message, opt_interval }, ...args) {
    if (isConditionAFunction(condition)) {
        const result = new Promise((resolve, reject) => {
            const startTime = Date.now();
            const pollCondition = async () => {
                // inner function that handles timeout promise rejections
                function handlePollTimeout(elapsed, opt_timeout, err) {
                    // if caller provided failure message - add to the message.
                    const timeoutMessage = resolveWaitMessage(opt_timeout, opt_message);
                    // if function throws an error - add to the message.
                    const errSuffix = err && err.message ? `Error: ${err.message}.\n` : '';
                    // combine all available messages into one
                    reject(new Error(`${timeoutMessage}${errSuffix}Timeout while waiting for condition after ${elapsed}ms.`));
                }
                return wrapConditionFn(condition, args)
                    .then(function (value) {
                    const elapsed = Date.now() - startTime;
                    if (value) {
                        resolve(value);
                    }
                    else if ((opt_timeout || opt_timeout === 0) && elapsed >= opt_timeout) {
                        handlePollTimeout(elapsed, opt_timeout, undefined);
                    }
                    else {
                        setTimeout(pollCondition, opt_interval);
                    }
                })
                    .catch(function (err) {
                    const elapsed = Date.now() - startTime;
                    if ((opt_timeout || opt_timeout === 0) && elapsed >= opt_timeout) {
                        handlePollTimeout(elapsed, opt_timeout, err);
                    }
                    else {
                        setTimeout(pollCondition, opt_interval);
                    }
                });
            };
            pollCondition();
        });
        return result;
    }
    else {
        return new Promise((resolve, reject) => {
            if (!opt_timeout) {
                resolve(condition);
                return;
            }
            // inner function that handles timeout promise rejections
            function handlePollTimeout(elapsed, opt_timeout) {
                const timeoutMessage = resolveWaitMessage(opt_timeout, opt_message);
                reject(new Error(`${timeoutMessage}\nTimeout while waiting for promise to resolve after ${elapsed}ms.`));
            }
            const startTime = Date.now();
            let timer = setTimeout(function () {
                timer = null;
                const elapsed = Date.now() - startTime;
                handlePollTimeout(elapsed, opt_timeout);
            }, opt_timeout);
            const clearTimer = () => timer && clearTimeout(timer);
            condition
                .then((value) => {
                clearTimer();
                resolve(value);
            })
                .catch((error) => {
                clearTimer();
                reject(error);
            });
        });
    }
}
async function createInstanceAndWaitForRoot(Ctor, driver, element, locator) {
    const pageObjectInstance = await createInstance(Ctor, driver, element, locator);
    // The beforeLoad is protected to discourage user-land use
    // The call to this method can be overriden via beforeload declarative PO
    // Invariant: It guarantees the root is available when yielding to user-land code
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    await pageObjectInstance.__beforeLoad__();
    return pageObjectInstance;
}
// TODO we need to hook the switch context here
async function createInstance(Ctor, driver, element, locator) {
    const findConstructorFromLoader = UtamPageObjectProvider.getPageObjectImpl;
    const ConcreteCtor = Ctor.isInterface ? await findConstructorFromLoader(Ctor) : Ctor;
    // Set the mobile context type for hybrid mobile app, by default set to web.
    // for not mobile driver driver.setPageContext does nothing
    const { mobileContext } = ConcreteCtor;
    if (ConcreteCtor.prototype instanceof UtamBaseRootPageObject) {
        await driver.setPageContext(mobileContext, UtamPageObjectProvider.getBridgeAppTitle());
    }
    return new ConcreteCtor(driver, element, locator);
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
class DocumentUtamElement {
    constructor(driver) {
        this.driver = driver;
    }
    waitFor(condition, ...args) {
        return this.driver.waitFor(condition, undefined, ...args);
    }
    waitForDocumentReady() {
        return this.driver.waitFor(() => {
            return this.driver.executeScript(function () {
                return document.readyState === 'complete';
            });
        });
    }
    containsElement(locator) {
        if (locator.using !== 'css selector') {
            throw Error('Only css locators are supported at this moment');
        }
        return this.driver.executeScript(function (selector) {
            return !!document.querySelector(selector);
        }, locator.value);
    }
    getUrl() {
        return this.driver.executeScript(function () {
            return document.URL;
        });
    }
    /**
     * checks if given Root Page Object present, ex.
     * utam.getDocument().containsObject(MyModal)
     *
     * @param Ctor type of a Root Page Object
     * @returns true if given type of the Root Page Object present in browser
     */
    async containsObject(Ctor) {
        const pageObjectInstance = new Ctor(this.driver);
        const locator = pageObjectInstance.__getRootLocator__();
        return this.containsElement(locator);
    }
    // (I)Frames APIs
    /**
     * Enters the (i)frame specified by the given frame element
     * @param frame frame element to enter into
     */
    enterFrame(frame) {
        const frameElement = FrameUtamElement.getUnwrappedElement(frame);
        return this.driver.enterFrame(frameElement);
    }
    /**
     * Exits focus from a(n) (i)frame to the immediate parent frame
     * @remarks
     * If already at the top-level frame, this is a no-op
     */
    exitToParentFrame() {
        return this.driver.exitToParentFrame();
    }
    /**
     * Exits focus from a(n) (i)frame to the page's default content
     * @remarks
     * If already at the top-level frame, this is a no-op
     */
    exitFrame() {
        return this.driver.exitFrame();
    }
    /**
     * Enters a frame or iframe element and loads the specified Page Object as loaded in the frame
     * @param frame rame element to enter into
     * @param Ctor Type of the Root Page Object to Return
     * @returns instance of the Page Object, loaded in the frame
     */
    async enterFrameAndLoad(frame, Ctor) {
        await this.enterFrame(frame);
        return await createInstanceAndWaitForRoot(Ctor, this.driver);
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Class that exposes static adapters between the UTAM Loader and the UTAM Core runtime.
 * This class is responsible for passing data from the loader to the runtime.
 * The adapter functions are bound to specific loader's APIs in its constructor.
 */
class UtamPageObjectProvider {
    /**
     * Return a page object constructor that represents the concrete implementation of the page object interface
     * passed as an argument.
     *
     * @param typeCtor page object that represent an interface
     * @returns a page object that is the concrete implementation of the given interface
     */
    static getPageObjectImpl(typeCtor) {
        if (!UtamPageObjectProvider.pageObjectImplAdapter) {
            throw new Error(`Error: Loader cannot resolve any PageObject: Implementation Adapter not provided`);
        }
        return UtamPageObjectProvider.pageObjectImplAdapter(typeCtor);
    }
    /**
     * Set the function used to find a page object implementation that matches an interface for a given active
     * profile. This function is bound to the loader function that finds an implementation matching an interface in
     * the loader constructor.
     *
     * @param implAdapter adapter function used to find page object implementations
     */
    static setPageObjectImplAdapter(implAdapter) {
        UtamPageObjectProvider.pageObjectImplAdapter = implAdapter;
    }
    /**
     * Set the adapter function for getting the bridgeAppTitle
     * @param bridgeAppTitleAdapter adapter function used to find the bridgeAppTitle set in the loader config
     */
    static setGetBridgeAppTitleAdapter(bridgeAppTitleAdapter) {
        UtamPageObjectProvider.bridgeAppTitleAdapter = bridgeAppTitleAdapter;
    }
    /**
     * Return the bridgeAppTitle if an adapter has been set (loader has been instanciated), undefined otherwise
     */
    static getBridgeAppTitle() {
        return UtamPageObjectProvider.bridgeAppTitleAdapter
            ? UtamPageObjectProvider.bridgeAppTitleAdapter()
            : undefined;
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Ported from the mixwith package, credit to Justin Fagnani.
 *
 * This class is a semantic wrapper around mixins applications that allows to express
 * mixins composition in an elegant way.
 *
 * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
 * @see https://github.com/justinfagnani/mixwith.js
 */
class MixinBuilder {
    constructor(superclass) {
        this.superclass = superclass;
    }
    with(...mixins) {
        return mixins.reduce((c, mixin) => mixin(c), this.superclass);
    }
}
const mix = (superclass) => new MixinBuilder(superclass);
/**
 * This function is a facade to avoid exposing how we handle mutiple inheritance to
 * page object consumers. As basic elements types are now declared as a list of
 * interfaces that an element must satisfy, we can't use inheritance anymore.
 *
 * Using the mixins design pattern, we can create a Class that will augment the
 * Base Class with additional behavior. This function creates and return such a class.
 *
 * @param elementConstructors mixins that augments BaseUtamElement methods
 * @returns a Class that extends BaseUtamElement
 */
function createUtamMixinCtor(...elementConstructors) {
    return class UtamMixCtor extends mix(BaseUtamElement).with(...elementConstructors) {
    };
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function ActionableUtamElement(Base) {
    return class ActionableUtamElement extends Base {
        async blur() {
            const element = validateElement(this.element);
            await element.blur();
        }
        async focus() {
            const element = validateElement(this.element);
            await element.focus();
        }
        scrollToCenter() {
            const element = validateElement(this.element);
            return element.scrollIntoView({ block: 'center' });
        }
        scrollToTop() {
            const element = validateElement(this.element);
            return element.scrollIntoView(true);
        }
        moveTo() {
            const element = validateElement(this.element);
            return element.moveTo();
        }
    };
}
function ClickableUtamElement(Base) {
    return class ClickableUtamElement extends Base {
        async click() {
            const element = validateElement(this.element);
            try {
                await element.click();
            }
            catch (err) {
                // Force JS click due to ChromeDriver bug:
                // https://bugs.chromium.org/p/chromedriver/issues/detail?id=3684
                return this.javascriptClick(element);
            }
        }
        javascriptClick(element) {
            return this.driver.executeScript(function (el) {
                el.click();
            }, element);
        }
        doubleClick() {
            const element = validateElement(this.element);
            return element.click();
        }
        rightClick() {
            const element = validateElement(this.element);
            return element.rightClick();
        }
        clickAndHold(durationSec) {
            const element = validateElement(this.element);
            return element.clickAndHold(durationSec);
        }
    };
}
function EditableUtamElement(Base) {
    return class EditableUtamElement extends Base {
        clear() {
            const element = validateElement(this.element);
            return element.clearValue();
        }
        setText(arg) {
            const element = validateElement(this.element);
            return element.addValue(arg);
        }
        press(key, options) {
            return this.driver.press(key, options);
        }
        clearAndType(value) {
            const element = validateElement(this.element);
            return element.setValue(value);
        }
    };
}
function DraggableUtamElement(Base) {
    return class DraggableUtamElement extends Base {
        dragAndDrop(target, durationSec) {
            const fromElement = validateElement(this.element);
            const destination = this.getUnwrappedElement(target);
            return fromElement.dragAndDrop({ element: destination }, durationSec);
        }
        dragAndDropByOffset(xOffset, yOffset, durationSec) {
            const fromElement = validateElement(this.element);
            return fromElement.dragAndDrop({ offset: { x: xOffset, y: yOffset } }, durationSec);
        }
    };
}
function TouchableUtamElement(Base) {
    return class TouchableUtamElement extends Base {
        flick(xOffset, yOffset) {
            const fromElement = validateElement(this.element);
            return fromElement.flick({ x: xOffset, y: yOffset });
        }
    };
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const DEFAULT_EXPLICIT_WAIT_TEIMEOUT = 20000;
const DEFAULT_POLLING_INTERVAL = 200;

export { ActionableUtamElement, BaseUtamElement, By, ClickableUtamElement, DEFAULT_EXPLICIT_WAIT_TEIMEOUT, DEFAULT_POLLING_INTERVAL, DEFAULT_PROFILE_NAME, DEFAULT_PROFILE_VALUE, DocumentUtamElement, DraggableUtamElement, EditableUtamElement, FrameUtamElement, NavigationUtamElement, REIFY_SHADOW_ELEMENT_CONSTANT, ShadowRoot, TouchableUtamElement, UtamBasePageObject, UtamBaseRootPageObject, UtamPageObjectProvider, checkLocator, createInstance, createInstanceAndWaitForRoot, createUtamMixinCtor, isElementAttachedToDom, wait };
/** version: 1.2.2 */
