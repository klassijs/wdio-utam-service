"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowRoot = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const constants_1 = require("./constants");
const by_1 = require("./lib/by");
const dom_traversal_1 = require("./helpers/dom-traversal");
const NOT_IMPLEMENTED_ERROR = 'Method not implemented because it is never invoked from this object';
class ShadowRoot {
    constructor(driver, element) {
        this.driver = driver;
        this.contextElement = element;
    }
    findElement(locator) {
        const selectorStr = by_1.checkLocator(locator).value;
        return this.driver.waitFor(() => {
            return this.driver.executeScript(function _findElement(element, selector) {
                if (element.shadowRoot) {
                    return element.shadowRoot.querySelector(selector);
                }
                else {
                    throw new Error(`Can't find element with locator '${selector}': its scope does not have shadow root`);
                }
            }, this.contextElement, selectorStr, 
            // This is to give special meaning and semantics to a framework implementation
            // that this executScript should return an Element with context
            constants_1.REIFY_SHADOW_ELEMENT_CONSTANT);
        }, {
            // use implicit timeout, not waitFor timeout
            timeout: this.driver.config.implicitTimeout,
            message: `Can't find element with locator '${selectorStr}' inside its scope shadow root`,
        });
    }
    findElements(locator) {
        const selectorStr = by_1.checkLocator(locator).value;
        return this.driver.waitFor(() => {
            return this.driver.executeScript(function _findElements(element, selector) {
                if (!element.shadowRoot) {
                    throw new Error(`Can't find element with locator '${selector}': scope does not have shadow root.`);
                }
                const elements = element.shadowRoot.querySelectorAll(selector);
                // shadowRoot.querySelectorAll can return an empty array which is not falsy
                if (!elements?.length) {
                    return null;
                }
                return elements;
            }, this.contextElement, selectorStr, 
            // This is to give special meaning and semantics to a framework implementation
            // that this executScript should return an Element with context
            constants_1.REIFY_SHADOW_ELEMENT_CONSTANT);
        }, {
            // use implicit timeout, not waitFor timeout
            timeout: this.driver.config.implicitTimeout,
            message: `Can't find elements with locator '${selectorStr}' inside its scope shadow root.`,
        });
    }
    async containsElement(locator) {
        // todo - fix mock to use "return (await this.containsElements(locator)) > 0;" instead next block
        const { using, value } = locator;
        if (using !== 'css selector') {
            throw new Error(`Invalid selector strategy "${using}", only css is supported at the moment`);
        }
        const result = await this.driver.executeScript(function _containsFromWithinShadow(element, selector) {
            if (element.shadowRoot) {
                return !!element.shadowRoot.querySelector(selector);
            }
        }, this.contextElement, value);
        return Boolean(result);
    }
    async containsElements(locator) {
        const { using, value } = locator;
        if (using !== 'css selector') {
            throw new Error(`Invalid selector strategy "${using}", only css is supported at the moment`);
        }
        const result = await this.driver.executeScript(function _containsFromWithinShadow(element, selector) {
            if (element.shadowRoot && element.shadowRoot.querySelector(selector)) {
                return element.shadowRoot.querySelectorAll(selector).length;
            }
            return 0;
        }, this.contextElement, value);
        return Number(result);
    }
    getCssValue(cssStyleProperty) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getAttribute(attributeName) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getRect() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    isDisplayed() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    isEnabled() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    hasFocus() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    isExisting() {
        return dom_traversal_1.isElementAttachedToDom(this.driver, this);
    }
    click() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    clearValue() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    addValue(arg) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    setValue(arg) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    press(key, options) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getValue() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    getText() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    scrollIntoView(arg) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    moveTo(options) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    dragAndDrop(target, durationSec) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    async flick(offset) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    async blur() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    async focus() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    doubleClick() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    rightClick() {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
    clickAndHold(durationSec) {
        throw new Error(NOT_IMPLEMENTED_ERROR);
    }
}
exports.ShadowRoot = ShadowRoot;
//# sourceMappingURL=shadow-element.js.map