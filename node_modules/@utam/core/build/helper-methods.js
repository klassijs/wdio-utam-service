"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInstance = exports.createInstanceAndWaitForRoot = exports.wait = void 0;
const _1 = require(".");
const utam_page_object_1 = require("./utam-page-object");
function resolveWaitMessage(timeoutMsec, message) {
    const timeoutSuffix = `within timeout ${timeoutMsec}ms.`;
    return message ? `${typeof message === 'function' ? message() : message} ${timeoutSuffix}\n` : '';
}
// Type guard that determines if the condition used in polling is a function
function isConditionAFunction(condition) {
    return typeof condition === 'function';
}
/**
 * Wraps the condition function in a promise as that function can either be sync or async.
 *
 * @param condition a sync/async function to wrap in the promise
 * @param args condition function arguments
 * @returns a promise that represents the results of the function invocation
 */
function wrapConditionFn(condition, args) {
    try {
        return Promise.resolve(condition(...args));
    }
    catch (err) {
        // this is needed if condition is regular function (not async) and throws an error
        return Promise.reject(err);
    }
}
/**
 * custom polling wait
 * This code is a version of Selenium wait:
 * https://github.com/SeleniumHQ/selenium/blob/trunk/javascript/node/selenium-webdriver/lib/webdriver.js
 */
function wait(condition, { opt_timeout, opt_message, opt_interval }, ...args) {
    if (isConditionAFunction(condition)) {
        const result = new Promise((resolve, reject) => {
            const startTime = Date.now();
            const pollCondition = async () => {
                // inner function that handles timeout promise rejections
                function handlePollTimeout(elapsed, opt_timeout, err) {
                    // if caller provided failure message - add to the message.
                    const timeoutMessage = resolveWaitMessage(opt_timeout, opt_message);
                    // if function throws an error - add to the message.
                    const errSuffix = err && err.message ? `Error: ${err.message}.\n` : '';
                    // combine all available messages into one
                    reject(new Error(`${timeoutMessage}${errSuffix}Timeout while waiting for condition after ${elapsed}ms.`));
                }
                return wrapConditionFn(condition, args)
                    .then(function (value) {
                    const elapsed = Date.now() - startTime;
                    if (value) {
                        resolve(value);
                    }
                    else if ((opt_timeout || opt_timeout === 0) && elapsed >= opt_timeout) {
                        handlePollTimeout(elapsed, opt_timeout, undefined);
                    }
                    else {
                        setTimeout(pollCondition, opt_interval);
                    }
                })
                    .catch(function (err) {
                    const elapsed = Date.now() - startTime;
                    if ((opt_timeout || opt_timeout === 0) && elapsed >= opt_timeout) {
                        handlePollTimeout(elapsed, opt_timeout, err);
                    }
                    else {
                        setTimeout(pollCondition, opt_interval);
                    }
                });
            };
            pollCondition();
        });
        return result;
    }
    else {
        return new Promise((resolve, reject) => {
            if (!opt_timeout) {
                resolve(condition);
                return;
            }
            // inner function that handles timeout promise rejections
            function handlePollTimeout(elapsed, opt_timeout) {
                const timeoutMessage = resolveWaitMessage(opt_timeout, opt_message);
                reject(new Error(`${timeoutMessage}\nTimeout while waiting for promise to resolve after ${elapsed}ms.`));
            }
            const startTime = Date.now();
            let timer = setTimeout(function () {
                timer = null;
                const elapsed = Date.now() - startTime;
                handlePollTimeout(elapsed, opt_timeout);
            }, opt_timeout);
            const clearTimer = () => timer && clearTimeout(timer);
            condition
                .then((value) => {
                clearTimer();
                resolve(value);
            })
                .catch((error) => {
                clearTimer();
                reject(error);
            });
        });
    }
}
exports.wait = wait;
async function createInstanceAndWaitForRoot(Ctor, driver, element, locator) {
    const pageObjectInstance = await createInstance(Ctor, driver, element, locator);
    // The beforeLoad is protected to discourage user-land use
    // The call to this method can be overriden via beforeload declarative PO
    // Invariant: It guarantees the root is available when yielding to user-land code
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    await pageObjectInstance.__beforeLoad__();
    return pageObjectInstance;
}
exports.createInstanceAndWaitForRoot = createInstanceAndWaitForRoot;
// TODO we need to hook the switch context here
async function createInstance(Ctor, driver, element, locator) {
    const findConstructorFromLoader = _1.UtamPageObjectProvider.getPageObjectImpl;
    const ConcreteCtor = Ctor.isInterface ? await findConstructorFromLoader(Ctor) : Ctor;
    // Set the mobile context type for hybrid mobile app, by default set to web.
    // for not mobile driver driver.setPageContext does nothing
    const { mobileContext } = ConcreteCtor;
    if (ConcreteCtor.prototype instanceof utam_page_object_1.UtamBaseRootPageObject) {
        await driver.setPageContext(mobileContext, _1.UtamPageObjectProvider.getBridgeAppTitle());
    }
    return new ConcreteCtor(driver, element, locator);
}
exports.createInstance = createInstance;
//# sourceMappingURL=helper-methods.js.map