"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtamBase = exports.validateElement = void 0;
const shadow_element_1 = require("./shadow-element");
function validateElement(element) {
    if (!element) {
        throw new Error(`Undefined element reference: PageObject has been incorrectly initialized`);
    }
    return element;
}
exports.validateElement = validateElement;
/**
 * base abstract class for a Page Object and an Element
 */
class UtamBase {
    constructor(driver, element, locator) {
        if (!driver) {
            throw new Error('A driver object implementing the UTAM Driver interface must be provided');
        }
        if (!element && !locator) {
            throw new Error('An element implementing the UTAM Element interface or a locator must be provided');
        }
        this.driver = driver;
        this.element = element;
        this.locator = locator;
    }
    /**
     * access to the element instance for subclasses
     * @param utamElement instance of the UTAM element
     * @returns instance of the Element
     */
    getUnwrappedElement(utamElement) {
        if (!utamElement) {
            throw new Error('Error while attempting to access Element on the null or undefined value');
        }
        return validateElement(utamElement.element);
    }
    /**
     * check if element can be found, element is assumed to be not null
     * @returns false if element is stale, true is found, throws and error otherwise
     */
    async isPresent() {
        // with UtamLoader.create for root Page Object we can be in state where element is undefined
        if (!this.element) {
            // method is not always called by PageObject, message has to be agnostic
            throw new Error(`Element has not been initialized properly (element: undefined)`);
        }
        return this.element.isExisting();
    }
    async isVisible() {
        if (await this.isPresent()) {
            return this.element.isDisplayed();
        }
        else {
            return false;
        }
    }
    waitFor(condition, ...args) {
        return this.driver.waitFor(condition, undefined, ...args);
    }
    async waitForAbsence() {
        await this.driver.waitFor(async () => {
            return !(await this.isPresent());
        }, { message: `waitForAbsence method did not complete` });
    }
    async waitForVisible() {
        const isPresent = await this.isPresent();
        if (isPresent) {
            await this.driver.waitFor(async () => {
                return await this.isVisible();
            }, { message: `waitForVisible method did not complete` });
        }
        else {
            throw new Error(`Unable to apply "waitForVisible" method on a stale element`);
        }
    }
    async waitForInvisible() {
        const isPresent = await this.isPresent();
        if (isPresent) {
            await this.driver.waitFor(async () => {
                return !(await this.isVisible());
            }, { message: `waitForInvisible method did not complete` });
        }
        else {
            throw new Error(`Unable to apply "waitForInvisible" method on a stale element`);
        }
    }
    /**
     * checks if there is an element present with the given selector
     * @param locator selector to look for
     * @param expandShadow if set to true, look inside shadow root
     */
    containsElement(locator, expandShadow = false) {
        let element = validateElement(this.element);
        if (expandShadow) {
            element = new shadow_element_1.ShadowRoot(this.driver, element);
        }
        return element.containsElement(locator);
    }
}
exports.UtamBase = UtamBase;
/** mark a page object as a declarative interface */
UtamBase.isInterface = false;
/** default context is web (covers both desktop and webviews) */
UtamBase.mobileContext = 'web';
//# sourceMappingURL=utam-base.js.map