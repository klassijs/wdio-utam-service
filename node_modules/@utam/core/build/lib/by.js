"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.By = exports.checkLocator = void 0;
const SUPPORTED_LOCATOR_STRATEGIES = [
    'css selector',
    'accessibility id',
    '-android uiautomator',
    '-ios class chain',
];
class By {
    constructor(using, value) {
        this.using = this.validateStrategy(using);
        this.value = value;
    }
    validateStrategy(using) {
        /**
         * Type assertion as a workaround until upper-bounded generics lands in TS
         * @see https://github.com/microsoft/TypeScript/issues/26255
         */
        if (!SUPPORTED_LOCATOR_STRATEGIES.includes(using)) {
            throw new Error('Unsupported Locator strategy');
        }
        else {
            return using;
        }
    }
    static accessibilityId(selector) {
        return new By('accessibility id', selector);
    }
    static classChain(selector) {
        return new By('-ios class chain', selector);
    }
    static css(selector) {
        return new By('css selector', selector);
    }
    static uiAutomator(selector) {
        return new By('-android uiautomator', selector);
    }
    toString() {
        return `By(${this.using}, ${this.value})`;
    }
}
exports.By = By;
function checkLocator(locator) {
    if (locator instanceof By) {
        return locator;
    }
    if (typeof locator === 'function') {
        throw new Error('UTAM core error: locator of type "function" is not yet supported');
    }
    if (locator &&
        typeof locator === 'object' &&
        typeof locator.using === 'string' &&
        typeof locator.value === 'string') {
        return new By(locator.using, locator.value);
    }
    throw new TypeError(`Invalid locator "${JSON.stringify(locator)}"`);
}
exports.checkLocator = checkLocator;
//# sourceMappingURL=by.js.map