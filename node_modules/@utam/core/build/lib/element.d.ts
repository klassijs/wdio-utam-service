import { By } from './by';
/**
 * This type is used as a return type of Element.getRect method
 * Represents coordinates and size of the element
 */
export interface ElementRectangle {
    x: number;
    y: number;
    width: number;
    height: number;
}
export interface Element {
    findElement(locator: By): Promise<Element>;
    findElements(locator: By): Promise<Element[]>;
    containsElement(locator: By): Promise<boolean>;
    containsElements(locator: By): Promise<number>;
    getText(): Promise<string | null>;
    getCssValue(cssStyleProperty: string): Promise<string | null>;
    getAttribute(attributeName: string): Promise<string | null>;
    getValue(): Promise<string | null>;
    isDisplayed(): Promise<boolean>;
    isEnabled(): Promise<boolean>;
    isExisting(): Promise<boolean>;
    /**
     * if invoked on the element without shadowRoot, check if current element is active inside driver
     * otherwise check if current element is same as shadowHost.shadowRoot.activeElement
     * @see https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/activeElement
     * @return true if current element is active
     */
    hasFocus(): Promise<boolean>;
    /**
     * click on the element
     */
    click(): Promise<void>;
    /**
     * double click
     */
    doubleClick(): Promise<void>;
    /**
     * right click
     */
    rightClick(): Promise<void>;
    /**
     * click on the element and hold (do not release mouse button)
     * @param durationSec hold duration in seconds
     */
    clickAndHold(durationSec?: number): Promise<void>;
    /**
     * Clear a <textarea> or text <input> elementâ€™s value.
     * Make sure you can interact with the element before using this command.
     * You can't clear an input element that is disabled or in readonly mode.
     */
    clearValue(): Promise<void>;
    /**
     * Add a value to an object found by given selector
     * @param arg String to enter
     */
    addValue(arg: string): Promise<void>;
    /**
     * Send a sequence of key strokes to an element (clears value before)
     * @param arg String to enter
     */
    setValue(arg: string): Promise<void>;
    /**
     * scroll to element
     * @param arg can be boolean (true to align top, false to bottom) or options like { block: 'center'}
     */
    scrollIntoView(arg?: boolean | {
        block: ScrollLogicalPosition;
    }): Promise<void>;
    /**
     * move the mouse by an offset relative to the top-left corner of the element
     * if offset is not specified - to the middle of the element
     * @param options optional offset parameters
     */
    moveTo(options?: {
        xOffset: number;
        yOffset: number;
    }): Promise<void>;
    /**
     * Drag and item (current element) into the target position.
     * Destination is set as a target element or relative coordinates.
     * @param target position to drag into as an Element or offset (coordinates) relative to current element position
     * @param durationSec hold duration in seconds before element is "dropped"
     */
    dragAndDrop(target: {
        element?: Element;
        offset?: {
            x: number;
            y: number;
        };
    }, durationSec?: number): Promise<void>;
    /**
     * mobile only: flick action based on offset coordinates
     *
     * @param offset horizontal (x) and vertical (y) offset
     */
    flick(offset: {
        x: number;
        y: number;
    }): Promise<void>;
    /**
     * web only: blur by running JavaScript in a browser
     */
    blur(): Promise<void>;
    /**
     * web only: focus by running JavaScript in a browser
     */
    focus(): Promise<void>;
    /**
     * get coordinates and size of the element
     */
    getRect(): Promise<ElementRectangle>;
}
//# sourceMappingURL=element.d.ts.map