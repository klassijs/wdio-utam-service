"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFromPath = exports.resolveConfig = exports.DEFAULT_INPUT_FILE_MASKS = exports.scan = exports.writeOutputJSON = exports.createSingleOutputDirectory = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const parser_wrapper_1 = require("./utils/parser-wrapper");
const traversal_1 = require("./parser/traversal");
const post_process_1 = require("./post-process");
const constants_1 = require("./utils/constants");
// use in packages/utam module for generation CLI
var writer_1 = require("./writer");
Object.defineProperty(exports, "createSingleOutputDirectory", { enumerable: true, get: function () { return writer_1.createSingleOutputDirectory; } });
Object.defineProperty(exports, "writeOutputJSON", { enumerable: true, get: function () { return writer_1.writeOutputJSON; } });
var scanner_1 = require("./scanner");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scanner_1.scan; } });
var constants_2 = require("./utils/constants");
Object.defineProperty(exports, "DEFAULT_INPUT_FILE_MASKS", { enumerable: true, get: function () { return constants_2.DEFAULT_INPUT_FILE_MASKS; } });
/**
 * Get page object name from file path
 * @param filePath absolute file path
 * @returns short page object name string
 */
function getPageObjectName(filePath) {
    return path_1.default.basename(filePath).split('.')[0];
}
/**
 * Merge default options with override from config
 * @param options partial options
 * @returns resolved configuration
 */
function resolveConfig(options) {
    // included tags, classes and attributes should be merged, not overridden
    const mergeIncludedTags = constants_1.DEFAULT_CONFIG_OPTIONS.includeTags;
    const mergeIncludedAttributes = constants_1.DEFAULT_CONFIG_OPTIONS.includeAttributes;
    const mergeIncludedClasses = constants_1.DEFAULT_CONFIG_OPTIONS.includeClasses;
    if (options.includeTags) {
        mergeIncludedTags.push(...options.includeTags);
    }
    if (options.includeAttributes) {
        mergeIncludedAttributes.push(...options.includeAttributes);
    }
    if (options.includeClasses) {
        mergeIncludedClasses.push(...options.includeClasses);
    }
    const config = {
        ...constants_1.DEFAULT_CONFIG_OPTIONS,
        ...options,
        includeTags: mergeIncludedTags,
        includeClasses: mergeIncludedClasses,
        includeAttributes: mergeIncludedAttributes,
    };
    return config;
}
exports.resolveConfig = resolveConfig;
/**
 * Generate UTAM JSON from HTML file
 * Can return more than one output if option to generate content of custom tags is on.
 * @param htmlFilePath absolute path to HTML file
 * @param config generator config
 * @returns generated objects
 */
function generateFromPath(htmlFilePath, config) {
    const htmlString = fs_1.default.readFileSync(htmlFilePath, 'utf8');
    if (!htmlString) {
        return []; //empty file
    }
    const pageObjectName = getPageObjectName(htmlFilePath);
    const rootNode = parser_wrapper_1.getRootNode(htmlString);
    if (!rootNode) {
        return [];
    }
    // remember all generated page objects in a map
    const generatedMap = new Map();
    const traversal = new traversal_1.DocumentTraversal(pageObjectName, config, generatedMap);
    traversal.traverse(rootNode);
    const output = [];
    for (const generated of generatedMap.values()) {
        post_process_1.postProcess(generated, traversal.traversalContext);
        output.push(generated);
    }
    return output;
}
exports.generateFromPath = generateFromPath;
//# sourceMappingURL=index.js.map