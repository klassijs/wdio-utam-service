"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildBasicSelectorString = exports.buildBasicElementName = exports.buildBasicElementType = void 0;
const parser_wrapper_1 = require("../utils/parser-wrapper");
const parser_utils_1 = require("../utils/parser-utils");
const constants_1 = require("../utils/constants");
function isRuleByAttributeValues(rule) {
    const schema = {
        tagNames: 'tagNames',
        attrValues: 'attrValues',
    };
    return Object.keys(rule).length === 2 && Object.keys(schema).filter((property) => property in rule).length === 2;
}
function isRuleByTagName(rule) {
    const schema = {
        tagNames: 'tagNames',
    };
    return Object.keys(rule).length === 1 && Object.keys(schema).filter((property) => property in rule).length === 1;
}
function isRuleByAttributeName(rule) {
    const schema = {
        attrNames: 'attrNames',
    };
    return Object.keys(rule).length === 1 && Object.keys(schema).filter((property) => property in rule).length === 1;
}
function isAttrValueMatch(element, rule) {
    const { tagNames, attrValues } = rule;
    const tagName = parser_wrapper_1.getName(element);
    if (tagNames.includes(tagName)) {
        for (const attrName in attrValues) {
            const attrValue = parser_wrapper_1.getAttribute(element, attrName);
            const attrValueArr = attrValues[attrName];
            if (attrValue && attrValueArr.includes(attrValue)) {
                return true;
            }
        }
    }
    return false;
}
function isTagNameMatch(element, rule) {
    const { tagNames } = rule;
    const tagName = parser_wrapper_1.getName(element);
    return tagNames.includes(tagName);
}
function isAttrNameMatch(element, rule) {
    const { attrNames } = rule;
    return parser_wrapper_1.hasAttribute(element, attrNames);
}
/**
 * Check given element belongs to the basic type
 * @param element HTML element
 * @returns types as array or undefined if no match found
 */
function buildBasicElementType(element) {
    for (const { type, rule } of constants_1.BASIC_TYPE_RULES) {
        if (isRuleByAttributeValues(rule) && isAttrValueMatch(element, rule)) {
            return type;
        }
        if (isRuleByTagName(rule) && isTagNameMatch(element, rule)) {
            return type;
        }
        if (isRuleByAttributeName(rule) && isAttrNameMatch(element, rule)) {
            return type;
        }
    }
    // no matching type found - return undefined
    return undefined;
}
exports.buildBasicElementType = buildBasicElementType;
/**
 * Build name of the generated element
 * @param element source HTML element
 * @returns string with name
 */
function buildBasicElementName(element) {
    return parser_utils_1.getElementNameFromAttributes(element);
}
exports.buildBasicElementName = buildBasicElementName;
/**
 * Build relative selector string for "css"
 * @param element HTML element
 * @returns string with CSS selector
 */
function buildBasicSelectorString(element, config, scopeCss) {
    return parser_utils_1.getSelectorFromAttributes(element, config, scopeCss);
}
exports.buildBasicSelectorString = buildBasicSelectorString;
//# sourceMappingURL=basic-element.js.map