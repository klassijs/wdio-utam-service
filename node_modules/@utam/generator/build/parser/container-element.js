"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildContainerElementType = exports.buildContainerSelectorString = exports.buildContainerElementName = void 0;
const parser_wrapper_1 = require("../utils/parser-wrapper");
const parser_utils_1 = require("../utils/parser-utils");
/**
 * Check if given element is a container
 * @param element HTML element
 * @returns true if container
 */
function isContainerTag(element) {
    const htmlTag = parser_wrapper_1.getName(element);
    return htmlTag === 'slot';
}
/**
 * Build name of the generated container element.
 * If slot has name, use name, otherwise use name of the parent node.
 * @param element element itself
 * @param scopeElement parent of the container
 * @returns string with name
 */
function buildContainerElementName(element, scopeElement) {
    const nameAttr = parser_wrapper_1.getAttribute(element, 'name');
    if (nameAttr) {
        return `${nameAttr}Container`;
    }
    const scopeName = 'name' in scopeElement ? scopeElement.name : 'root';
    return `${scopeName}Container`;
}
exports.buildContainerElementName = buildContainerElementName;
/**
 * Build relative selector string for "css"
 * @param element HTML element
 * @returns string with CSS selector
 */
function buildContainerSelectorString(element, config, scopeCss) {
    const { containerSelector } = config;
    const selectorScope = parser_utils_1.getSelectorScope(config, scopeCss);
    const nameAttr = parser_wrapper_1.getAttribute(element, 'name');
    if (nameAttr) {
        return `${selectorScope}[slot='${nameAttr}']`;
    }
    return `${selectorScope}${containerSelector}`;
}
exports.buildContainerSelectorString = buildContainerSelectorString;
/**
 * Check if the given node is a container element and return its type
 * @param node HTML element node
 * @returns container type or undefined if element is not a match
 */
function buildContainerElementType(node) {
    if (!isContainerTag(node)) {
        return undefined;
    }
    return 'container';
}
exports.buildContainerElementType = buildContainerElementType;
//# sourceMappingURL=container-element.js.map