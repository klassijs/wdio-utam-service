"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentTraversal = void 0;
const parser_wrapper_1 = require("../utils/parser-wrapper");
const custom_element_1 = require("./custom-element");
const basic_element_1 = require("./basic-element");
const container_element_1 = require("./container-element");
const scope_element_1 = require("./scope-element");
const compose_method_1 = require("./compose-method");
const parser_utils_1 = require("../utils/parser-utils");
/**
 * helper class for HTML elements traversal
 */
class DocumentTraversal {
    constructor(pageObjectName, generatorConfig, generatedTypes) {
        this.pageObject = {};
        this.traversalContext = {
            elementNames: new Map(),
            methods: new Map(),
            usedElements: new Map(),
            generatedTypes,
            pageObjectName,
        };
        this.generatorConfig = generatorConfig;
    }
    setMethod(composedElement, pageObjectMethod) {
        const { methods, usedElements } = this.traversalContext;
        const { name } = pageObjectMethod;
        if (!methods.has(name)) {
            if (!this.pageObject.methods) {
                this.pageObject.methods = [];
            }
            this.pageObject.methods.push(pageObjectMethod);
            methods.set(name, pageObjectMethod);
            if (!usedElements.has(composedElement)) {
                usedElements.set(composedElement, []);
            }
            usedElements.get(composedElement)?.push(name);
        }
    }
    /**
     * build element name based on tag and index
     * @param type category of generated element
     * @param element HTML element node
     * @param isList boolean indicating element is a list
     * @param suffix name can have suffix
     * @param scopeElement for container use scope name
     * @returns string with element name
     */
    getElementName(type, element, isList, suffix, scopeElement) {
        let elementName;
        if (type === 'scope') {
            elementName = scope_element_1.buildScopeElementName(element) + suffix;
        }
        else if (type === 'custom' || type === 'shadowBoundary') {
            elementName = custom_element_1.buildCustomElementName(element) + suffix;
        }
        else if (type === 'container') {
            elementName = container_element_1.buildContainerElementName(element, scopeElement);
        }
        else {
            elementName = basic_element_1.buildBasicElementName(element) + suffix;
        }
        const { elementNames } = this.traversalContext;
        return parser_utils_1.buildUniqueName(elementName, elementNames, isList);
    }
    /**
     * returns the type of the element, creates a custom type if needed
     * @param element HTML node
     * @returns element type or undefined if no match found
     */
    getElementType(element) {
        // rule with highest priority is it custom tag?
        const customType = custom_element_1.buildCustomElementType(element, this.generatorConfig);
        if (customType) {
            const { generatedType, customTypeShortName, isTraverseContent } = customType;
            return { generatedType, customTypeShortName, type: isTraverseContent ? 'shadowBoundary' : 'custom' };
        }
        const basicType = basic_element_1.buildBasicElementType(element);
        if (basicType) {
            return { generatedType: basicType, type: 'basic' };
        }
        const containerType = container_element_1.buildContainerElementType(element);
        if (containerType) {
            return { generatedType: containerType, type: 'container' };
        }
        const { createScopeElement } = this.generatorConfig;
        // if option to chain selectors is off - add private scope element
        if (createScopeElement && parser_utils_1.isScopeElement(element, this.generatorConfig)) {
            return { generatedType: scope_element_1.buildScopeElementType(), type: 'scope' };
        }
        // no match found - return undefined
        return undefined;
    }
    /**
     * Build CSS selector string scoped inside its scope CSS
     * Depending on imposed rules, scope CSS can be ignored
     * @param element HTML element
     * @returns CSS string
     */
    buildScopedSelector(type, element, scopeCss) {
        if (type === 'custom') {
            return custom_element_1.buildCustomSelectorString(element, this.generatorConfig, scopeCss);
        }
        if (type === 'container') {
            return container_element_1.buildContainerSelectorString(element, this.generatorConfig, scopeCss);
        }
        if (type === 'scope') {
            return scope_element_1.buildScopeSelectorString(element, this.generatorConfig, scopeCss);
        }
        return basic_element_1.buildBasicSelectorString(element, this.generatorConfig, scopeCss);
    }
    /**
     * build an element from the HTML node
     * @param node HTML node
     * @param isList boolean that defines if element is a list
     * @param scopeCss scope selector
     * @returns UtamElement JSON object and its selector
     */
    processElement(node, isList, scopeCss, scopeIndexNestedLevel, scopeElement) {
        const generated = this.getElementType(node);
        if (!generated) {
            return {
                selector: parser_utils_1.getScopeSelectorFromAttributes(node, this.generatorConfig, scopeCss),
                scopeElement,
                scopeIndexNestedLevel,
            };
        }
        const { type, customTypeShortName, generatedType } = generated;
        const selector = this.buildScopedSelector(type, node, scopeCss);
        const name = this.getElementName(type, node, isList, '', scopeElement);
        const element = {
            public: type === 'scope' ? undefined : true,
            name,
            type: generatedType,
            selector: { css: selector, returnAll: isList && type !== 'container' ? true : undefined },
        };
        const elements = [];
        const methods = [];
        elements.push(element);
        let nextElement = element;
        let nextScopeIndexNestedLevel = scopeIndexNestedLevel;
        // add index based element
        if (isList) {
            const indexedSelector = parser_utils_1.buildSelectorWithIndex(element.selector, scopeIndexNestedLevel);
            const indexedElement = {
                public: true,
                name: this.getElementName(type, node, false, 'ByIndex', scopeElement),
                type: generatedType,
                selector: indexedSelector.json,
            };
            elements.push(indexedElement);
            nextElement = indexedElement;
            nextScopeIndexNestedLevel = indexedSelector.nestedLevel;
        }
        return {
            type,
            elements,
            methods,
            selector,
            customTypeShortName,
            scopeElement: nextElement,
            scopeIndexNestedLevel: nextScopeIndexNestedLevel,
        };
    }
    /**
     * depending on config setup traversal can go inside custom tag
     * @param element current HTML node
     * @param customTypeShortName short name of the object to generate
     */
    traverseCustomElement(element, customTypeShortName) {
        const { generatedTypes, pageObjectName } = this.traversalContext;
        const typeName = customTypeShortName;
        if (generatedTypes.has(typeName) || // if same type already generated
            pageObjectName === typeName // reference to self
        ) {
            // end traversal for custom element
            return;
        }
        // otherwise create new traversal for custom element as a root
        const newTraversal = new DocumentTraversal(typeName, this.generatorConfig, generatedTypes);
        newTraversal.traverse(element);
    }
    /**
     * traverse HTML elements starting from root
     * @param elementNode current HTML node
     * @param context current element context
     */
    traverseElements(elementNode, context) {
        const { generateCustomContent, createScopeElement } = this.generatorConfig;
        const { returnAll, scopeCss, parent, isShadowRoot, hasImmediateParent, indexNestedLevel } = context;
        const parentName = 'name' in parent ? parent.name : 'root';
        if (parser_wrapper_1.isTextNode(elementNode) && hasImmediateParent) {
            // generate method to getText
            const textScopeName = parser_utils_1.getTextNodeAsVariable(elementNode);
            if (textScopeName) {
                parent.name = textScopeName;
            }
            const method = compose_method_1.buildTextComposeMethod(this.generatorConfig, parent);
            this.setMethod(textScopeName ?? parentName, method);
        }
        else if (parser_wrapper_1.isElementNode(elementNode)) {
            const isLoopElement = parser_utils_1.isElementLoop(elementNode);
            let nextScopeCss = createScopeElement ? '' : scopeCss;
            let nextParent = parent;
            let nextIsShadowRoot = isShadowRoot;
            let hasImmediateParent = false;
            let nextIndexNestedLevel = indexNestedLevel;
            if (!isLoopElement) {
                // can return public UtamElement or private if selector chaining is off
                // or undefined if selector chaining is on - then we need to remember new selector
                const { elements, methods, selector, customTypeShortName, type, scopeElement, scopeIndexNestedLevel } = this.processElement(elementNode, returnAll, scopeCss, indexNestedLevel, parent);
                nextIndexNestedLevel = scopeIndexNestedLevel;
                parser_utils_1.attachChildElements(parent, isShadowRoot, elements);
                if (elements && type) {
                    // since type not empty, element was added. so now scope is empty.
                    nextScopeCss = '';
                    nextParent = scopeElement;
                    nextIsShadowRoot = parser_utils_1.isShadowBoundary(elementNode);
                    methods?.forEach((method) => this.setMethod(scopeElement.name, method));
                    // for custom element we can to generate new page object or stop
                    if (type === 'custom' && customTypeShortName) {
                        if (generateCustomContent) {
                            this.traverseCustomElement(elementNode, customTypeShortName);
                        }
                        return;
                    }
                    if (type === 'container' || elements[0].type === 'frame') {
                        // stop traversal
                        return;
                    }
                    hasImmediateParent = true;
                }
                else {
                    // remember new selector
                    nextScopeCss = selector;
                }
            }
            // context for traversal of child nodes
            const nextElementContext = {
                returnAll: isLoopElement,
                scopeCss: nextScopeCss,
                parent: nextParent,
                isShadowRoot: nextIsShadowRoot,
                hasImmediateParent,
                indexNestedLevel: nextIndexNestedLevel,
            };
            this.treeWalk(elementNode, nextElementContext, isLoopElement);
        }
    }
    treeWalk(elementNode, elementContext, isLoopElement) {
        const childElements = parser_wrapper_1.getChildElements(elementNode);
        if (childElements.length > 0) {
            // if children have same tag - treat as a list
            if (!isLoopElement && parser_utils_1.isRepeatable(childElements)) {
                elementContext.returnAll = true;
                this.traverseElements(childElements[0], elementContext);
            }
            else {
                for (const child of childElements) {
                    this.traverseElements(child, elementContext);
                }
            }
        }
    }
    buildDescription(rootNode) {
        const { descriptionAuthor } = this.generatorConfig;
        const { pageObjectName } = this.traversalContext;
        const rootSelector = parser_wrapper_1.getName(rootNode);
        this.pageObject.description = {
            author: descriptionAuthor,
            text: [`Page Object: ${pageObjectName}`, `Root element: ${rootSelector}`],
        };
    }
    markAsRoot(rootNode) {
        const { rootSelectors } = this.generatorConfig;
        const rootTag = parser_wrapper_1.getName(rootNode);
        if (rootSelectors.includes(rootTag)) {
            this.pageObject.root = true;
            this.pageObject.selector = {
                css: rootTag,
            };
        }
    }
    /**
     * traverse HTML source starting from root
     * @returns void, fill this.generatedMap
     */
    traverse(rootNode) {
        const rootContext = {
            scopeCss: '',
            returnAll: false,
            isShadowRoot: parser_utils_1.isShadowBoundary(rootNode),
            parent: this.pageObject,
            hasImmediateParent: true,
            indexNestedLevel: 0,
        };
        this.buildDescription(rootNode);
        this.markAsRoot(rootNode);
        this.treeWalk(rootNode, rootContext, false);
        const { pageObjectName, generatedTypes, usedElements } = this.traversalContext;
        const generated = {
            pageObject: this.pageObject,
            pageObjectName,
            usedElements,
        };
        // add generated UtamPageObject to map with the name
        generatedTypes.set(pageObjectName, generated);
    }
}
exports.DocumentTraversal = DocumentTraversal;
//# sourceMappingURL=traversal.js.map