import { Element, TextNode } from './parser-wrapper';
import { UtamSelector, UtamElement, UtamPageObject, GeneratorConfigOptions } from '@utam/types';
/**
 * Build generated element name based on attributes
 * @param element HTML element
 * @returns string with name
 */
export declare function getElementNameFromAttributes(element: Element): string;
/**
 * Name of the element should be unique, so use map
 * @param elementName previously generated name
 * @param elementNames map for names tracking
 * @param isList boolean for list
 * @returns unique name
 */
export declare function buildUniqueName(elementName: string, elementNames: Map<string, number>, isList: boolean): string;
/**
 * Depending on config build selector scope
 * @param config generator config
 * @param scopeCss string with CSS from a parent
 * @returns string with scope CSS
 */
export declare function getSelectorScope(config: GeneratorConfigOptions, scopeCss: string): string;
/**
 * Basic element that was not recognized as actionable, can be a scope if it matches configured rules
 * @param element HTML element
 * @param config generator config
 * @returns true is element should be added as a scope
 */
export declare function isScopeElement(element: Element, config: GeneratorConfigOptions): boolean;
/**
 * Build CSS for the element of type "scope". First check if it actually was added
 * @param element HTML element
 * @param config generator config
 * @param scopeCss if chaining selectors is on, pass scope string
 * @returns CSS selector
 */
export declare function getScopeSelectorFromAttributes(element: Element, config: GeneratorConfigOptions, scopeCss: string): string;
/**
 * Build generated selector based on attributes
 * @param element HTML element
 * @param config generator config
 * @param scopeCss if chaining selectors is on, pass scope string
 * @returns CSS selector
 */
export declare function getSelectorFromAttributes(element: Element, config: GeneratorConfigOptions, scopeCss: string): string;
/**
 * Add index to selector or return self if it's already indexed
 * @param selector JSON selector object
 * @param nestedLevel indexed element can have more nested elements
 * @returns JSON indexed selector
 */
export declare function buildSelectorWithIndex(selector: UtamSelector, nestedLevel: number): {
    json: UtamSelector;
    nestedLevel: number;
};
/**
 * Add child elements to the parent
 * @param parent element or page object
 * @param isShadowRoot if true, add elements inside shadow
 * @param children elements to add
 */
export declare function attachChildElements(parent: UtamElement | UtamPageObject, isShadowRoot: boolean, children?: UtamElement[]): void;
/**
 * Check if element is repeated multiple times and should be a list
 * @param childElements elements
 * @returns
 */
export declare function isRepeatable(childElements: (Element | TextNode)[]): boolean;
/**
 * depending on the element tag, it can be shadow root
 * @param element HTML element
 * @returns true if element is shadow root
 */
export declare function isShadowBoundary(element: Element): boolean;
/**
 * utility method to transform string with '-' to camel case
 * @param value tag or attribute value
 */
export declare function kebabCaseToCamelCase(value: string): string;
/**
 * if content of the text node contains {variableName}, it will be used as the name of the parent element
 * @param textNode HTML element
 * @returns internal string or undefined
 */
export declare function getTextNodeAsVariable(textNode: TextNode): string | undefined;
/**
 * is element a loop
 * @param element HTML element
 * @returns true is it is
 */
export declare function isElementLoop(element: Element): boolean;
//# sourceMappingURL=parser-utils.d.ts.map