"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isElementLoop = exports.getTextNodeAsVariable = exports.kebabCaseToCamelCase = exports.isShadowBoundary = exports.isRepeatable = exports.attachChildElements = exports.buildSelectorWithIndex = exports.getSelectorFromAttributes = exports.getScopeSelectorFromAttributes = exports.isScopeElement = exports.getSelectorScope = exports.buildUniqueName = exports.getElementNameFromAttributes = void 0;
const parser_wrapper_1 = require("./parser-wrapper");
// check that string does not have trailing numbers, which means it's generated
const HAS_NUMBER = /[0-9]+$/;
// instead of using tag name, use mapped value
const TAG_TO_NAME = {
    a: 'link',
    td: 'tableCell',
    tr: 'tableRow',
    ol: 'list',
    ul: 'list',
    iframe: 'frame',
    li: 'listItem',
};
const ATTRIBUTE_TO_NAME = ['id', 'data-aura-class', 'name', 'slot'];
/**
 * Build generated element name based on attributes
 * @param element HTML element
 * @returns string with name
 */
function getElementNameFromAttributes(element) {
    const htmlTag = parser_wrapper_1.getName(element);
    for (const attrName of ATTRIBUTE_TO_NAME) {
        const attrValue = parser_wrapper_1.getAttribute(element, attrName);
        if (attrValue && !HAS_NUMBER.test(attrValue)) {
            // attribute value can be { dinamic } or kebab-case, neither is allowed in name
            return `${stripCurlyBraces(kebabCaseToCamelCase(attrValue))}`;
        }
    }
    for (const tagName in TAG_TO_NAME) {
        if (tagName === htmlTag) {
            return `${TAG_TO_NAME[tagName]}`;
        }
    }
    return `${htmlTag}`;
}
exports.getElementNameFromAttributes = getElementNameFromAttributes;
/**
 * Name of the element should be unique, so use map
 * @param elementName previously generated name
 * @param elementNames map for names tracking
 * @param isList boolean for list
 * @returns unique name
 */
function buildUniqueName(elementName, elementNames, isList) {
    const index = elementNames.get(elementName) ?? 0;
    // if element with same name already exists - add index to the name
    const name = `${elementName}${index > 0 ? index.toString() : ''}${isList ? 's' : ''}`;
    elementNames.set(elementName, index + 1);
    return name;
}
exports.buildUniqueName = buildUniqueName;
/**
 * Depending on config build selector scope
 * @param config generator config
 * @param scopeCss string with CSS from a parent
 * @returns string with scope CSS
 */
function getSelectorScope(config, scopeCss) {
    const { createScopeElement } = config;
    return !createScopeElement && scopeCss.length > 0 ? `${scopeCss} ` : '';
}
exports.getSelectorScope = getSelectorScope;
/**
 * Generator is configured to pick elements with matching class as a scope
 * @param element HTML element
 * @param config generator config
 * @returns undefined if no match found, otherwise matching class value
 */
function findMatchingClass(element, config) {
    const { includeClasses } = config;
    const classValues = parser_wrapper_1.getAttribute(element, 'class')?.split(' ') ?? [];
    // find class that starts as configured
    return classValues.find((value) => includeClasses.find((prefix) => value.startsWith(prefix)));
}
/**
 * Basic element that was not recognized as actionable, can be a scope if it matches configured rules
 * @param element HTML element
 * @param config generator config
 * @returns true is element should be added as a scope
 */
function isScopeElement(element, config) {
    if (!parser_wrapper_1.hasChildElements(element)) {
        return false;
    }
    const tagName = parser_wrapper_1.getName(element);
    const { includeTags, includeAttributes } = config;
    if (includeTags.includes(tagName)) {
        return true;
    }
    if (parser_wrapper_1.hasAttribute(element, includeAttributes)) {
        return true;
    }
    if (findMatchingClass(element, config)) {
        return true;
    }
    return false;
}
exports.isScopeElement = isScopeElement;
/**
 * Build CSS for the element of type "scope". First check if it actually was added
 * @param element HTML element
 * @param config generator config
 * @param scopeCss if chaining selectors is on, pass scope string
 * @returns CSS selector
 */
function getScopeSelectorFromAttributes(element, config, scopeCss) {
    if (!isScopeElement(element, config)) {
        return scopeCss;
    }
    return getSelectorFromAttributes(element, config, scopeCss);
}
exports.getScopeSelectorFromAttributes = getScopeSelectorFromAttributes;
/**
 * Build generated selector based on attributes
 * @param element HTML element
 * @param config generator config
 * @param scopeCss if chaining selectors is on, pass scope string
 * @returns CSS selector
 */
function getSelectorFromAttributes(element, config, scopeCss) {
    const htmlTag = parser_wrapper_1.getName(element);
    const scopeSelector = getSelectorScope(config, scopeCss);
    const { includeAttributes } = config;
    const ADD_TAG_TO_SELECTOR = ['a', 'input', 'button', 'select', 'textarea'];
    const tagNamePrefix = ADD_TAG_TO_SELECTOR.includes(htmlTag) || htmlTag.includes('-') ? htmlTag : '';
    for (const attrName of includeAttributes) {
        const attrValue = parser_wrapper_1.getAttribute(element, attrName);
        if (attrValue && !HAS_NUMBER.test(attrValue) && !attrValue.startsWith('{')) {
            const formattedValue = attrValue.split(' ')[0].trim();
            const cssString = attrName === 'id' ? `#${formattedValue}` : `[${attrName}='${formattedValue}']`;
            return `${scopeSelector}${tagNamePrefix}${cssString}`;
        }
    }
    const classMatch = findMatchingClass(element, config);
    if (classMatch) {
        return `${scopeSelector}${tagNamePrefix}.${classMatch}`;
    }
    return `${scopeSelector}${htmlTag}`;
}
exports.getSelectorFromAttributes = getSelectorFromAttributes;
/**
 * Add index to selector or return self if it's already indexed
 * @param selector JSON selector object
 * @param nestedLevel indexed element can have more nested elements
 * @returns JSON indexed selector
 */
function buildSelectorWithIndex(selector, nestedLevel) {
    const selectorStr = selector.css ?? '';
    // if selector is already indexed - return same
    if (selectorStr.includes(':nth-of-type')) {
        return { json: selector, nestedLevel };
    }
    // indexed element can have other chld elements
    const name = nestedLevel > 0 ? `index${nestedLevel}` : 'index';
    const css = `${selectorStr}:nth-of-type(%d)`;
    const arg = { name, type: 'number' };
    return {
        json: {
            css,
            args: [arg],
        },
        nestedLevel: nestedLevel + 1,
    };
}
exports.buildSelectorWithIndex = buildSelectorWithIndex;
/**
 * Add child elements to the parent
 * @param parent element or page object
 * @param isShadowRoot if true, add elements inside shadow
 * @param children elements to add
 */
function attachChildElements(parent, isShadowRoot, children) {
    if (!children || children.length === 0) {
        return;
    }
    if (!isShadowRoot) {
        if (!parent.elements) {
            parent.elements = [];
        }
        parent.elements.push(...children);
    }
    else {
        // slot elements should not be inside shadow
        // so we push them outside shadowRoot even though isShadowRoot is true
        const slotsElms = children.filter((element) => element.type === 'container');
        if (slotsElms.length > 0) {
            if (!parent.elements) {
                parent.elements = [];
            }
            parent.elements.push(...slotsElms);
        }
        const regularElms = children.filter((element) => element.type !== 'container');
        if (regularElms.length > 0) {
            if (!parent.shadow) {
                parent.shadow = {
                    elements: [],
                };
            }
            parent.shadow.elements.push(...regularElms);
        }
    }
}
exports.attachChildElements = attachChildElements;
/**
 * Check if element is repeated multiple times and should be a list
 * @param childElements elements
 * @returns
 */
function isRepeatable(childElements) {
    if (childElements.length < 2) {
        return false;
    }
    const elements = childElements.filter((el) => parser_wrapper_1.isElementNode(el));
    // if at least one element has "grandchild" or is a text - return false
    if (elements.length !== childElements.length) {
        return false;
    }
    // tag name should be same
    const names = new Set(elements.map((el) => parser_wrapper_1.getName(el)));
    if (names.size > 1) {
        return false;
    }
    // some tags are never lists
    const tagName = names.values().next().value;
    if (tagName === 'slot' || tagName === 'template') {
        return false;
    }
    // class should be same
    const classes = new Set(elements.map((el) => parser_wrapper_1.getAttribute(el, 'class') ?? ''));
    if (classes.size > 1) {
        return false;
    }
    return true;
}
exports.isRepeatable = isRepeatable;
/**
 * depending on the element tag, it can be shadow root
 * @param element HTML element
 * @returns true if element is shadow root
 */
function isShadowBoundary(element) {
    const tagName = parser_wrapper_1.getName(element);
    return tagName === 'template' || tagName.includes('-');
}
exports.isShadowBoundary = isShadowBoundary;
/**
 * utility method to transform string with '-' to camel case
 * @param value tag or attribute value
 */
function kebabCaseToCamelCase(value) {
    if (!value.includes('-')) {
        return value;
    }
    const kebabCaseName = value.substring(value.split('-')[0].length + 1);
    const camelCaseName = [];
    let upper = false;
    for (let i = 0; i < kebabCaseName.length; i++) {
        if (kebabCaseName[i] === '-') {
            upper = true;
        }
        else {
            camelCaseName.push(upper ? kebabCaseName[i].toUpperCase() : kebabCaseName[i]);
            upper = false;
        }
    }
    return camelCaseName.join('');
}
exports.kebabCaseToCamelCase = kebabCaseToCamelCase;
/**
 * extract string from curly braces
 * @param value input string
 */
function stripCurlyBraces(value) {
    return value.replace(/[{}]/g, '');
}
/**
 * if content of the text node contains {variableName}, it will be used as the name of the parent element
 * @param textNode HTML element
 * @returns internal string or undefined
 */
function getTextNodeAsVariable(textNode) {
    const text = textNode.value;
    if (text.startsWith('{')) {
        return stripCurlyBraces(text);
    }
    return undefined;
}
exports.getTextNodeAsVariable = getTextNodeAsVariable;
/**
 * is element a loop
 * @param element HTML element
 * @returns true is it is
 */
function isElementLoop(element) {
    return parser_wrapper_1.hasAttribute(element, ['for:each', 'for:item', 'for:iterator']);
}
exports.isElementLoop = isElementLoop;
//# sourceMappingURL=parser-utils.js.map