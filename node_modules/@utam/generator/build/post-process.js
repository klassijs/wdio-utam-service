"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcess = void 0;
const parser_utils_1 = require("./utils/parser-utils");
/**
 * Traverse generated page object to remove duplicates or redundant elements.
 * There could be elements with same selectors or redundant elements
 * @param generated output of generation
 */
function postProcess(generated, context) {
    const { elements, shadow, methods } = generated.pageObject;
    if (elements) {
        buildUniqueSelectors(elements, context, methods);
        removeRedundantElements(elements, context);
        if (elements.length === 0) {
            generated.pageObject.elements = undefined;
        }
    }
    if (shadow) {
        buildUniqueSelectors(shadow.elements, context, methods);
        removeRedundantElements(shadow.elements, context);
        if (shadow.elements.length === 0) {
            generated.pageObject.shadow = undefined;
        }
    }
}
exports.postProcess = postProcess;
/**
 * Element can be deleted as duplicate, then method should be adjusted to its twin
 * @param removedElement old element
 * @param newName new element
 * @param context traversal context
 * @param utamMethods methods
 */
function adjustMethods(removedElement, newName, context, utamMethods) {
    const { usedElements } = context;
    const oldName = removedElement.name;
    const methodNames = usedElements.get(oldName);
    if (methodNames && utamMethods) {
        for (let i = 0; i < utamMethods?.length; i++) {
            const { name, compose } = utamMethods[i];
            if (methodNames.includes(name)) {
                for (const statement of compose) {
                    if (statement.element === oldName) {
                        statement.element = newName;
                    }
                }
            }
        }
        usedElements.delete(oldName);
        usedElements.set(newName, methodNames);
    }
    if (utamMethods) {
        // traverse children and remove methods
        removeComposeMethod(context, utamMethods, removedElement.elements);
        if (removedElement.shadow) {
            removeComposeMethod(context, utamMethods, removedElement.shadow.elements);
        }
    }
}
function removeComposeMethod(context, utamMethods, removedElements) {
    if (removedElements) {
        const { usedElements } = context;
        for (const child of removedElements) {
            const elementName = child.name;
            const methodNames = usedElements.get(elementName);
            if (methodNames) {
                for (let i = 0; i < utamMethods.length; i++) {
                    if (methodNames.includes(utamMethods[i].name)) {
                        utamMethods.splice(i, 1);
                        i--;
                    }
                }
                usedElements.delete(elementName);
            }
            removeComposeMethod(context, utamMethods, child.elements);
            if (child.shadow) {
                removeComposeMethod(context, utamMethods, child.shadow.elements);
            }
        }
    }
}
/**
 * remove private elements (scope) that has no public leafs and is not used in methods
 * @param elements array
 * @param context document context
 */
function removeRedundantElements(elements, context) {
    const isRedundant = function (element, context) {
        const { usedElements } = context;
        if (element.elements) {
            if (element.elements.find((el) => !isRedundant(el, context))) {
                return false;
            }
        }
        if (element.shadow) {
            if (element.shadow.elements.find((el) => !isRedundant(el, context))) {
                return false;
            }
        }
        if (usedElements.has(element.name)) {
            return false;
        }
        // leaf!
        return element.public ? false : true;
    };
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (isRedundant(element, context)) {
            elements.splice(i, 1);
            i--;
        }
    }
}
/**
 * add index to selector
 * @param elements array
 */
function buildUniqueSelectors(elements, context, utamMethods) {
    // key - selector, value - name
    const selectors = new Map();
    // key - selector, value - index
    const counter = new Map();
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const selectorStr = element.selector.css ?? '';
        // if selector is already indexed - return same
        const indexedSelector = parser_utils_1.buildSelectorWithIndex(element.selector, 0);
        const indexedSelectorStr = indexedSelector.json.css ?? '';
        if (selectors.has(indexedSelectorStr)) {
            // this index already accomodated, element can be deleted
            const newElementName = selectors.get(indexedSelectorStr) ?? '';
            elements.splice(i, 1);
            adjustMethods(element, newElementName, context, utamMethods);
            i--;
        }
        else if (selectors.has(selectorStr)) {
            // this can only mean that element has different parent in DOM tree, otherwise it would be flagged as list
            const index = counter.get(selectorStr) ?? 0;
            const selectorWithIndex = `${selectorStr}:nth-of-type(${index + 1})`;
            element.selector.css = selectorWithIndex;
            counter.set(selectorStr, index + 1);
        }
        else {
            selectors.set(selectorStr, element.name);
            counter.set(selectorStr, 1);
        }
        if (element.elements) {
            buildUniqueSelectors(element.elements, context, utamMethods);
        }
        if (element.shadow) {
            buildUniqueSelectors(element.shadow.elements, context, utamMethods);
        }
    }
}
//# sourceMappingURL=post-process.js.map