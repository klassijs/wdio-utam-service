"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generation = exports.descriptions = exports.getConfiguredError = exports.buildMessageFromConfig = void 0;
const formatters_1 = require("./utils/formatters");
var errors_1 = require("./errors");
Object.defineProperty(exports, "buildMessageFromConfig", { enumerable: true, get: function () { return errors_1.buildMessageFromConfig; } });
Object.defineProperty(exports, "getConfiguredError", { enumerable: true, get: function () { return errors_1.getConfiguredError; } });
exports.descriptions = {
    JSON: {
        INVALID_PROPERTY_KEY: (key, structure, properties, position) => ({
            message: `Invalid property "${key}" inside ${structure}: valid keys are [${properties.join(', ')}]`,
            position,
        }),
        INVALID_TYPE_FOR_VALUE: (key, structure, expectedType, actualType, position) => ({
            message: `Invalid property "${key}" inside ${structure}: value must be of type ${expectedType} but found ${actualType}`,
            position,
        }),
        REQUIRED_KEY_ON_STRUCTURE: (key, structure, position) => ({
            message: `Property "${key}" is required for ${structure} object`,
            position,
        }),
        REQUIRED_EXCLUSIVE_KEYS_ON_STRUCTURE: (keys, structure, position) => ({
            message: `${formatters_1.buildExclusiveKeysPrefix(keys)} should be set for ${structure} object`,
            position,
        }),
        REDUNDANT_PROPERTY_KEY_FOR_STRUCTURE: (key, structureType, position) => ({
            message: `Property "${key}" is redundant for ${structureType}`,
            position,
        }),
        DUPLICATE_NODE_DECLARED: (name, structureType, position) => ({
            message: `Duplicate ${structureType} with name "${name}", please use a different name`,
            position,
        }),
    },
    ARGS: {
        REDUNDANT_KEYS: (structure) => ({
            message: `Either "type" and "name" or "value" is supported for ${structure} arguments`,
        }),
        ONLY_VALUE_SUPPORTED: (structureType, position) => ({
            message: `Only literal parameters (by value) are supported for ${structureType} arguments`,
            position,
        }),
        VALUE_NOT_SUPPORTED: (structure, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: literal parameters (by value) are not supported`,
            position,
        }),
        MISSING_REQUIRED_TYPE_KEY_LITERAL_ARG: (structure, expectedType, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: Missing required "type" property for "${expectedType}" literal argument`,
            position,
        }),
        INVALID_PAGE_OBJECT_TYPE_VALUE: (structure, value, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: Invalid value ${value}, value must be a URI-like path that represents the page object type`,
            position,
        }),
        EMPTY_METHOD_ARGS: (structure, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: Missing or empty method arguments while declaring reference argument in statement`,
            position,
        }),
        NONEXISTENT_ARGUMENT_REFERENCE: (structure, argName, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: A statement declares a reference to an "${argName}" argument but thereâ€™s no matching method-level argument`,
            position,
        }),
        UNSUPPORTED_NESTED_ARGS: (structure, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: only element reference can have nested args`,
            position,
        }),
        DESCRIPTION_NOT_SUPPORTED: (position) => ({
            message: `Property "description" is not supported for literal or function argument`,
            position,
        }),
    },
    ROOT: {
        REQUIRED_SELECTOR_IF_ROOT: (position) => ({
            message: `A "selector" property must be provided when Page Object is marked as a root`,
            position,
        }),
        REDUNDANT_SELECTOR: () => ({
            message: `Page Object should be marked as root when property "selector" is defined`,
        }),
        BEFORE_LOAD_UNSUPPORTED_ELEMENT: (position) => ({
            message: `Hook "beforeLoad" requires the element property to be "root" or "document"`,
            position,
        }),
        PLATFORM_INVALID_VALUE: (value, validValues, position) => ({
            message: `Invalid "platform" value "${value}". Valid values are ${formatters_1.stringifyIterableInBraces(validValues)}`,
            position,
        }),
        REQUIRED_IMPLEMENTS_IF_PROFILE: (position) => ({
            message: `An "implements" property must be provided when Page Object has a "profile" property`,
            position,
        }),
    },
    ELEMENT: {
        INVALID_BASIC_ELEMENT_TYPE: (type, basicTypes, position) => ({
            message: `Invalid element type "${type}". Valid types are: array of [${formatters_1.stringifyIterableInHumanReadableList(basicTypes)}]`,
            position,
        }),
        DUPLICATE_BASIC_TYPE: (type, elementName, position) => ({
            message: `Duplicated type "${type}" in "${elementName}" type declaration. Basic elements type values must be unique`,
            position,
        }),
        INVALID_ELEMENT_TYPE: (type, basicTypes, position) => ({
            message: `Invalid element type "${type}". Valid types are: array of [${formatters_1.stringifyIterableInHumanReadableList(basicTypes)}] or "container" or custom Page Object`,
            position,
        }),
        INVALID_CUSTOM_TYPE: (type) => ({
            message: `Invalid element type "${type}". Custom type must only contain alphanumeric characters with the schema [package-name]/[custom/path]/pageObject`,
        }),
        INVALID_FILTER_WITHOUT_SELECTOR_LIST: (elementName, position) => ({
            message: `Invalid element "${elementName}": filter requires a selector returning list`,
            position,
        }),
        LIST_CANNOT_HAVE_NESTED_ELEMENTS: (name, position) => ({
            message: `Invalid element "${name}": element marked as a list cannot have nested elements or shadow root`,
            position,
        }),
        ONLY_BASIC_TYPE_CAN_HAVE_NESTED_ELEMENTS: (name, position) => ({
            message: `Invalid element "${name}": only basic actionable element can have nested elements or shadow root`,
            position,
        }),
        INVALID_FILTER_MATCHER: (structure, matcherType, matcherTypes, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: unsupported filter matcher "${matcherType}". Valid matchers are [${matcherTypes.join(', ')}]`,
            position,
        }),
        UNSUPPORTED_FILTER_MATCHER: (structure, action, matcherType, matcherTypes, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: action "${action}" does not support matcher "${matcherType}". Valid matchers are [${matcherTypes.join(', ')}]`,
            position,
        }),
    },
    METHOD: {
        EMPTY_DECLARATION: (methodName, position) => ({
            message: `Method "${methodName}" is empty, it should contain a "compose" declaration`,
            position,
        }),
        NONEXISTENT_ELEMENT_REFERENCE: (structure, elementName, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: referenced element "${elementName}" is not found`,
            position,
        }),
        UNSUPPORTED_RETURN_TYPE_VALUE: (structure, returnTypeValue, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: invalid return type "${returnTypeValue}"`,
            position,
        }),
        INVALID_RETURN_TYPE_NEXT_STATEMENT_IS_CHAIN: (structure, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: "returnType" must be a custom element value when the next statement is declared as a "chain" statement`,
            position,
        }),
        INFERRED_TYPE_NOT_CUSTOM_NEXT_STATEMENT_IS_CHAIN: (structure, inferredReturnType) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: to use chain, previous statement must return custom type, but it returns '${inferredReturnType}'`,
        }),
    },
    ACTION: {
        UNKNOWN_APPLICABLE_METHOD: (structure, apply, elementType, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: action "${apply}" is not supported for elements of type(s): "${Array.isArray(elementType) ? elementType.join(', ') : elementType}"`,
            position,
        }),
        INVALID_APPLICABLE_TYPE: (structure, apply, applicableTypes, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: action "${apply}" is supported only for {${applicableTypes.join(', ')}} element type(s)`,
            position,
        }),
        APPLICABLE_ONLY_TO_LIST: (structure, apply, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: action "${apply}" is supported only for multiple elements, element selector should be marked as a list`,
            position,
        }),
        INVALID_RETURN_SELF_NOT_LAST_STATEMENT: (structure, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: "returnSelf" action can only be applied in the last compose statement`,
            position,
        }),
    },
    SELECTOR: {
        VALUE_CANT_BE_EMPTY: (structure, supportedSelectors, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(structure)}: can't be empty. You must declare one of these selector property: ${formatters_1.stringifyIterableInBraces(supportedSelectors)}`,
            position,
        }),
        DUPLICATE_SELECTOR_STRATEGIES: (selectors, supportedSelectors, position) => ({
            message: `Redundant ${formatters_1.stringifyIterableInBrackets(selectors)} properties inside a selector. You can declare only one of these selector property: ${formatters_1.stringifyIterableInBraces(supportedSelectors)}`,
            position,
        }),
        CLASS_CHAIN_INVALID_QUOTES: (position) => ({
            message: `only one of quotes {$,\`} can be set`,
            position,
        }),
        CLASS_CHAIN_INVALID_OPERATORS: (selector, operators, position) => ({
            message: `unsupported class chain selector: "${selector}", supported are: ${formatters_1.stringifyIterableInBraces(operators)}`,
            position,
        }),
        UIAUTOMATOR_UNSUPPORTED_METHOD: (method, operators, position) => ({
            message: `unsupported UiSelector method: "${method}", supported are : ${formatters_1.stringifyIterableInBraces(operators)}`,
            position,
        }),
    },
};
// errors during generation phase
exports.generation = {
    ARGS: {
        INCORRECT_COUNT: (validationContext, expectedCount, actualCount) => ({
            message: `${formatters_1.capitalizeFirstLetter(validationContext)}: expected ${expectedCount} arguments, actually passed ${actualCount}`,
        }),
        INCORRECT_TYPE: (validationContext, argNameOrValue, expectedType, actualType, position) => ({
            message: `${formatters_1.capitalizeFirstLetter(validationContext)}: mismatch in argument "${argNameOrValue}" - expected type is ${expectedType}, actual is ${actualType}`,
            position,
        }),
        SELECTOR_MISSING_ARGUMENT: (selectorString, args) => ({
            message: `Mismatch in arguments [${args}] for selector "${selectorString}": missing argument(s)`,
        }),
        COMPOSE_METHOD_DUPLICATED_ARGUMENT_NAMES: (argName, methodName) => ({
            message: `Duplicate parameters with name "${argName}" in method "${methodName}"`,
        }),
    },
};
//# sourceMappingURL=index.js.map