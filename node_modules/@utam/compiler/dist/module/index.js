import fs from 'fs';
import path from 'path';
import { generation, getConfiguredError, buildMessageFromConfig, descriptions } from '@utam/diagnostics';
import { findNodeAtLocation, getNodeValue, printParseErrorCode, visit, parseTree as parseTree$1, parse } from 'jsonc-parser';

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const UTAM_ROOT_ELEMENT = 'root';
const UTAM_DOCUMENT_ELEMENT = 'document';
const UTAM_NAVIGATION_ELEMENT = 'navigation';
const BEFORE_LOAD_METHOD_NAME = '__beforeLoad__';
const UTAM_CORE_MODULE = '@utam/core';
const UTAM_LOCATOR_BY = 'By';
const UTAM_SHADOW_CLASS = 'ShadowRoot';
const UTAM_TYPES_DRIVER = 'Driver';
const UTAM_TYPES_ELEMENT = 'Element';
const UTAM_TYPES_LOCATOR = 'Locator';
// -- Page Objects Classes Names
const UTAM_BASE_CLASS_NAME = 'UtamBasePageObject';
const UTAM_BASE_ROOT_CLASS_NAME = 'UtamBaseRootPageObject';
// -- Element Types
const UTAM_ELEMENT_DEFAULT_TYPE = 'basic';
const UTAM_CONTAINER_TYPE = 'container';
const UTAM_FRAME_ELEMENT_TYPE$1 = 'frame';
// -- Elements Constructors
const UTAM_ELEMENT_CTOR_DOCUMENT = 'DocumentUtamElement';
const UTAM_ELEMENT_CTOR_NAVIGATION = 'NavigationUtamElement';
const UTAM_ELEMENT_CTOR = 'createUtamMixinCtor';
const UTAM_ELEMENT_FACTORY_FN = 'createInstance';
const UTAM_ELEMENT_CTOR_BASE = 'BaseUtamElement';
const UTAM_ELEMENT_TYPE_TO_CTOR = {
    basic: 'BaseUtamElement',
    actionable: 'ActionableUtamElement',
    clickable: 'ClickableUtamElement',
    editable: 'EditableUtamElement',
    draggable: 'DraggableUtamElement',
    touchable: 'TouchableUtamElement',
};
const UTAM_CONTAINER_CTOR = 'ContainerCtor';
const UTAM_CONTAINER_LOCATOR = 'containerLocator';
const UTAM_FRAME_ELEMENT_CTOR = 'FrameUtamElement';
const UTAM_PAGE_OBJECT_CTOR = 'PageObjectCtor';
// -- Return Types
const UTAM_VOID_RETURN_TYPE = 'void';
const UTAM_BOOLEAN_RETURN_TYPE = 'boolean';
const UTAM_NUMBER_RETURN_TYPE = 'number';
const UTAM_STRING_RETURN_TYPE = 'string';
const UTAM_FRAME_RETURN_TYPE = 'frame';
const UTAM_PAGE_OBJECT_RETURN_TYPE = 'pageObject';
const UTAM_ROOT_PAGE_OBJECT_RETURN_TYPE = 'rootPageObject';
// -- Return Type Category
const UTAM_RETURN_CATEGORY_PRIMITIVE = 'primitive';
const UTAM_RETURN_CATEGORY_BASIC_ELEMENT = 'basicElement';
const UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT = 'customElement';
const UTAM_RETURN_CATEGORY_FRAME_ELEMENT = 'frameElement';
const UTAM_RETURN_CATEGORY_VOID = 'void';
const UTAM_RETURN_CATEGORY_SELF = 'self';
const UTAM_RETURN_CATEGORY_PAGE_OBJECT = 'pageObject';
const UTAM_RETURN_CATEGORY_ROOT_PAGE_OBJECT = 'rootPageObject';
// -- Arg Types
const UTAM_FRAME_ARG_TYPE = 'frame';
const UTAM_PAGE_OBJECT_ARG_TYPE = 'pageObject';
const UTAM_ROOT_PAGE_OBJECT_ARG_TYPE = 'rootPageObject';
const UTAM_LOCATOR_ARG_TYPE = 'locator';
const UTAM_ELEMENT_REFERENCE_ARG_TYPE = 'elementReference';
const UTAM_ARGUMENT_REFERENCE_ARG_TYPE = 'argumentReference';
// -- Hardcoded action
const RETURN_SELF_ACTION = 'returnSelf';

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// supported element types that can use actions
const ACTIONABLE = 'actionable';
const CLICKABLE = 'clickable';
const DRAGGABLE = 'draggable';
const EDITABLE = 'editable';
const TOUCHABLE = 'touchable';
const BASIC_ELEMENT_TYPES = [
    'basic',
    ACTIONABLE,
    CLICKABLE,
    EDITABLE,
    DRAGGABLE,
    TOUCHABLE,
];
const BASE_TYPES = [...BASIC_ELEMENT_TYPES, 'self'];
/**
 * enumeration of all supported actions for an actionable element
 * used for validations that action is supported, applicable to the element and passed arguments match expected,
 * based on return type of the action, generated code has "return" in the last compose statement and forEach or map to apply to list
 * based on applicability, compiler decides if action is applicable to the given element type
 * based on action cardinality, compiler decides if action can be applied to the single element or needs a list
 */
const SUPPORTED_ACTIONS = [
    { applyFunction: 'blur', applicableTo: [ACTIONABLE] },
    { applyFunction: 'click', applicableTo: [CLICKABLE] },
    { applyFunction: 'clickAndHold', applicableTo: [CLICKABLE], args: [{ type: 'number', required: false }] },
    { applyFunction: 'clear', applicableTo: [EDITABLE] },
    { applyFunction: 'clearAndType', applicableTo: [EDITABLE], args: [{ type: 'string', required: true }] },
    { applyFunction: 'doubleClick', applicableTo: [CLICKABLE] },
    {
        applyFunction: 'dragAndDrop',
        applicableTo: [DRAGGABLE],
        args: [
            { type: 'elementReference', required: true },
            { type: 'number', required: false },
        ],
    },
    {
        applyFunction: 'dragAndDropByOffset',
        applicableTo: [DRAGGABLE],
        args: [
            { type: 'number', required: true },
            { type: 'number', required: true },
            { type: 'number', required: false },
        ],
    },
    {
        applyFunction: 'flick',
        applicableTo: [TOUCHABLE],
        args: [
            { type: 'number', required: true },
            { type: 'number', required: true },
        ],
    },
    { applyFunction: 'focus', applicableTo: [ACTIONABLE] },
    {
        applyFunction: 'getAttribute',
        applicableTo: BASIC_ELEMENT_TYPES,
        return: 'string',
        args: [{ type: 'string', required: true }],
    },
    { applyFunction: 'getClassAttribute', applicableTo: BASIC_ELEMENT_TYPES, return: 'string' },
    {
        applyFunction: 'getCssPropertyValue',
        applicableTo: BASIC_ELEMENT_TYPES,
        args: [{ type: 'string', required: true }],
        return: 'string',
    },
    // this action is set to return void because we do not support return type for location and size
    { applyFunction: 'getRect', applicableTo: BASIC_ELEMENT_TYPES },
    { applyFunction: 'getText', applicableTo: BASIC_ELEMENT_TYPES, return: 'string' },
    { applyFunction: 'getTitle', applicableTo: BASIC_ELEMENT_TYPES, return: 'string' },
    { applyFunction: 'getValue', applicableTo: BASIC_ELEMENT_TYPES, return: 'string' },
    { applyFunction: 'isEnabled', applicableTo: BASIC_ELEMENT_TYPES, return: 'boolean' },
    { applyFunction: 'isFocused', applicableTo: BASIC_ELEMENT_TYPES, return: 'boolean' },
    { applyFunction: 'moveTo', applicableTo: [ACTIONABLE] },
    { applyFunction: 'rightClick', applicableTo: [CLICKABLE] },
    { applyFunction: 'scrollToCenter', applicableTo: [ACTIONABLE] },
    { applyFunction: 'scrollToTop', applicableTo: [ACTIONABLE] },
    { applyFunction: 'setText', applicableTo: [EDITABLE], args: [{ type: 'string', required: true }] },
    { applyFunction: 'press', applicableTo: [EDITABLE], args: [{ type: 'string', required: true }] },
    { applyFunction: 'size', applicableTo: BASIC_ELEMENT_TYPES, return: 'number', howToApply: 'needs list' },
    // actions applicable to a basic element type and a page object
    { applyFunction: 'isPresent', applicableTo: BASE_TYPES, return: 'boolean' },
    { applyFunction: 'isVisible', applicableTo: BASE_TYPES, return: 'boolean' },
    {
        applyFunction: 'containsElement',
        applicableTo: BASE_TYPES,
        args: [
            { type: 'locator', required: true },
            { type: 'boolean', required: false },
        ],
        return: 'boolean',
    },
    {
        applyFunction: 'waitFor',
        applicableTo: BASE_TYPES,
        args: [{ type: 'function', required: true }],
    },
    { applyFunction: 'waitForAbsence', applicableTo: BASE_TYPES },
    { applyFunction: 'waitForVisible', applicableTo: BASE_TYPES },
    { applyFunction: 'waitForInvisible', applicableTo: BASE_TYPES },
];
function isUtamElementType(elementType) {
    return BASIC_ELEMENT_TYPES.includes(elementType);
}
/**
 * check if string matches one of the supported actions from grammar spec
 * return supported action metadata object if it does or undefined otherwise
 * undefined value if further processed by validator
 * @param applyString string with action type
 */
function buildActionByName(applyFunction, elementType) {
    if (elementType && !Array.isArray(elementType) && !isUtamElementType(elementType) && elementType !== 'self') {
        return {
            external: true,
            applyFunction,
            return: 'unknown',
        };
    }
    return SUPPORTED_ACTIONS.find((action) => action.applyFunction === applyFunction);
}
/**
 * Verify that an action is applicable to at least one element types from the set of declared types
 * @param actionType type of the action being applied
 * @param elementTypes
 * @returns false if the action can't be applied to the element, true otherwise
 */
function isActionApplicableForTypes(actionType, elementTypes) {
    let isActionAppliedToOneElementType;
    if (Array.isArray(elementTypes)) {
        isActionAppliedToOneElementType = elementTypes.some((elementType) => actionType.applicableTo.includes(elementType));
    }
    else {
        isActionAppliedToOneElementType = actionType.applicableTo.includes(elementTypes);
    }
    return isActionAppliedToOneElementType;
}
/**
 * check if action requires operand to be a list/array of elements
 * @param methodName name of the compose method being validated
 * @param actionType type of the action being applied
 * @param isElementList boolean indicator if element is a list
 * @return false if action requires list and element is not
 */
function isCorrectElementCardinality(actionType, isElementList) {
    if (actionType.external || !actionType.howToApply) {
        return true; // we don't know expected cardinality or applicable to any
    }
    return isElementList === (actionType.howToApply === 'needs list');
}
function getActionExpectedArgs(actionType) {
    return actionType.args || [];
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function isBasicElement(type) {
    return Array.isArray(type) || BASIC_ELEMENT_TYPES.includes(type);
}
const VALID_CUSTOM_TYPE = /^@?[\w-/]+$/;
const isCustomTypePredicate = (type) => type.includes('-') || type.includes('/');
function isCustomType(type) {
    return typeof type === 'string' && isCustomTypePredicate(type);
}
function isContainerElement(value) {
    return typeof value === 'string' && value === UTAM_CONTAINER_TYPE;
}
function isFrameElement(type) {
    return typeof type === 'string' && type === UTAM_FRAME_ELEMENT_TYPE$1;
}
function wrapSingleBasicTypeInArray(type) {
    return Array.isArray(type) ? type : [type];
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getBaseIndentation(str) {
    const identMatch = /\n( +)/.exec(str);
    if (!identMatch) {
        return new RegExp('', 'gm');
    }
    return new RegExp(`^${identMatch[1]}`, 'gm');
}
function getChunkEndIndentation(str) {
    let newLineStart = str.length;
    while (newLineStart > 0 && str[newLineStart - 1] !== '\n') {
        newLineStart--;
    }
    let indentEnd = newLineStart;
    while (indentEnd < str.length && str[indentEnd] === ' ') {
        indentEnd++;
    }
    return str.slice(newLineStart, indentEnd);
}
function code(chunks, ...values) {
    const baseIndentation = getBaseIndentation(chunks[0]);
    let result = chunks[0].replace(baseIndentation, '');
    let currentIndentation = getChunkEndIndentation(result);
    for (let i = 1; i < chunks.length; i++) {
        const chunk = chunks[i].replace(baseIndentation, '');
        const value = values[i - 1];
        let formattedValue = Array.isArray(value) ? value.join('\n') : value;
        formattedValue = formattedValue.replace(/\n/g, `\n${currentIndentation}`);
        // Avoid empty lines in statements
        // TODO - remove empty lines in type definitions
        if (chunk === `\n${currentIndentation}` && formattedValue === '') {
            continue;
        }
        result += formattedValue + chunk;
        currentIndentation = getChunkEndIndentation(chunk);
    }
    return result.trim();
}
/**
 * Creates and  returns a string that represents a list of arguments separated by comma.
 * This function should be invoked during code generation when a list of arguments must be
 * built dynamically and append to existing arguments. If no arguments is passed, the
 * function returns an empty string which avoid trailing commas in generated page objects
 * code.
 *
 * @param args - arguments use to generate the list
 * @returns a string that represents the arguments to append to the existing ones
 */
function buildAddedArgs(args) {
    if (args.length < 1)
        return '';
    const SEMICOLON_SPACE = ', ';
    return `${SEMICOLON_SPACE}${args.join(SEMICOLON_SPACE)}`;
}
/**
 * escape all (not-already-escaped) double-quote chars in a string
 * For reference https://gist.github.com/getify/3667624
 * @param str input string
 * @returns string with escaped double quotes
 */
function escapeDoubleQuotes(str) {
    return str.replace(/\\([\s\S])|(")/g, '\\$1$2');
}
/**
 * replace single quotes (') with double quotes (\")
 * @param str input with single quotes
 * @returns output with double quotes
 */
function singleToDoubleQuotes(str) {
    return str.replace(/'/g, '"');
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const ARGS_TYPE_REGEX = /(%[s|d])/g;
// this type of error is thrown for args validations
class UtamArgsValidationError extends Error {
    constructor(diagnostic) {
        super(diagnostic.message);
        this.utamError = true;
    }
}
function replaceSelectorArguments(selectorExpression, args, prefix = '" + ', suffix = ' + "') {
    const argx = args.slice();
    return selectorExpression.replace(ARGS_TYPE_REGEX, function x() {
        const argName = argx.shift();
        if (!argName) {
            throw new UtamArgsValidationError(generation.ARGS.SELECTOR_MISSING_ARGUMENT(selectorExpression, args));
        }
        return `${prefix}${argName}${suffix}`;
    });
}
function isPrimitiveType(type) {
    return type === 'string' || type === 'number' || type === 'boolean';
}
/**
 * Detect and return supported literal primitive type
 *
 * @param value primitive literal value
 * @returns value's type
 */
function deriveLiteralType(value) {
    switch (typeof value) {
        case 'string': {
            return 'string';
        }
        case 'number': {
            return 'number';
        }
        case 'boolean': {
            return 'boolean';
        }
        default: {
            throw new Error(`Unsupported literal argument type: ${typeof value}`);
        }
    }
}
function checkArgType(validationContextStr, argNameOrValue, expectedType, argType) {
    if (argType !== expectedType)
        throw new UtamArgsValidationError(generation.ARGS.INCORRECT_TYPE(validationContextStr, argNameOrValue, expectedType, argType));
}
/**
 * from array of UtamArgument get string array for method declaration
 * @param args declared arguments
 */
function getArgumentsNames(args) {
    const argNames = [];
    if (!args) {
        return [];
    }
    // Add support for literal argument by filtering them explicitly
    // as we don't want literal arguments to be present in the method signatures
    const nonLiteralArg = args.filter((arg) => !('value' in arg));
    nonLiteralArg.forEach((arg) => argNames.push(arg.name));
    const nestedArgs = getLocatorNestedArguments(args);
    nestedArgs.forEach((arg) => {
        if (arg.name) {
            argNames.push(arg.name);
        }
    });
    return argNames;
}
/**
 * type predicates that narrows the literal arguments parameter down to UtamSelector
 * if the predicate is satisfied.
 * @param literalArg non-primitive literal argument ({ value: { ... }})
 * @returns true if the predicate condition is satisfied, false otherwise
 */
function isUtamSelector(literalArg) {
    return (typeof literalArg === 'object' &&
        ('css' in literalArg || 'accessid' in literalArg || 'classchain' in literalArg || 'uiautomator' in literalArg));
}
/**
 * literal locator can have nested args
 * @param args arguments
 * @returns array of nested arguments
 */
function getLocatorNestedArguments(args) {
    const res = [];
    if (!args) {
        return res;
    }
    args.forEach((arg) => {
        if ('value' in arg && isUtamSelector(arg.value)) {
            const selector = arg.value;
            if (selector.args) {
                res.push(...selector.args);
            }
        }
    });
    return res;
}
/**
 * helper to build selector such as By.css('.mySelector')
 * @param selector string with selector
 * @param byId prefix for builder, usually 'By'
 */
function buildLiteralSelectorCode(selector, byId) {
    if (!byId) {
        throw new Error(`Identifier for "By" must be present`);
    }
    const { args = [] } = selector;
    const selectorType = getDeclaredSelector(selector);
    const byApiId = getByApiId(selectorType);
    const selectorValue = selector[selectorType];
    if (!selectorValue) {
        throw new Error(`Selector "${JSON.stringify(selector)}" should have a value`);
    }
    if (!args.length) {
        return `${byId}.${byApiId}("${escapeDoubleQuotes(selectorValue)}")`;
    }
    // Note: we replace single quotes (') and double quotes (") with escaped double quotes (\")
    // as it seems that Appium doesn't recognize single quotes as strings
    return `${byId}.${byApiId}("${replaceSelectorArguments(escapeDoubleQuotes(singleToDoubleQuotes(selectorValue)), getArgumentsNames(args))}")`;
}
/**
 * Return the selector that has been specified in the page object
 *
 * @param selector element selector parsed from the JSON page object
 * @returns the element selector type
 */
function getDeclaredSelector(selector) {
    return selector.css ? 'css' : selector.accessid ? 'accessid' : selector.classchain ? 'classchain' : 'uiautomator';
}
/**
 * Return the By method identifier that is use to locate the element from the type of selector
 * declared in the page object
 *
 * @param selectorType the selector type declared in the page object
 * @returns the invoked By API used to find the element
 */
function getByApiId(selectorType) {
    switch (selectorType) {
        case 'accessid':
            return 'accessibilityId';
        case 'classchain':
            return 'classChain';
        case 'css':
            return 'css';
        case 'uiautomator':
            return 'uiAutomator';
    }
}
/**
 * Extract arguments types from a given selector value.
 * This is used to extract arguments types from selector parameters.
 * @param selector selector (accessid | classchain | css uiautomator) value
 * @returns list of argument types declared in the selector value
 */
function getSelectorArgTypesFromString(selector) {
    const types = [];
    const matches = selector.match(ARGS_TYPE_REGEX);
    const validationContext = `Selector "${selector}"`;
    if (matches) {
        matches.forEach((match) => {
            switch (match) {
                case '%s':
                    types.push('string');
                    break;
                case '%d':
                    types.push('number');
                    break;
                default:
                    throw new UtamArgsValidationError(generation.ARGS.INCORRECT_TYPE(validationContext, 'selector', 'string or number', match));
            }
        });
    }
    return types;
}
function getSelectorArgTypes(selector) {
    const matchTypes = {};
    const { css, args } = selector;
    if (args && args.length) {
        if (css) {
            const matches = css.match(ARGS_TYPE_REGEX);
            const validationContext = `Selector "${css}"`;
            if (matches) {
                const argx = args.slice();
                matches.forEach((match, index) => {
                    const key = argx.shift();
                    if (!key) {
                        throw new UtamArgsValidationError(generation.ARGS.SELECTOR_MISSING_ARGUMENT(css, getArgumentsNames(args)));
                    }
                    switch (match) {
                        case '%s':
                            matchTypes[key.name] = 'string';
                            checkArgType(validationContext, key.name, 'string', args[index].type);
                            break;
                        case '%d':
                            matchTypes[key.name] = 'number';
                            checkArgType(validationContext, key.name, 'number', args[index].type);
                            break;
                        default:
                            throw new UtamArgsValidationError(generation.ARGS.INCORRECT_TYPE(validationContext, key.name, 'string or number', match));
                    }
                });
            }
            else {
                throw new UtamArgsValidationError(generation.ARGS.INCORRECT_COUNT(validationContext, args.length, 0));
            }
        }
        else {
            args.forEach((arg) => {
                if (arg.name.includes(':')) {
                    const [key, type] = arg.name.split(':');
                    matchTypes[key] = type;
                }
                else {
                    matchTypes[arg.name] = 'string';
                }
            });
        }
    }
    return matchTypes;
}
function getSelectorArgDescriptions(selector) {
    const matchTypes = {};
    const { css, args } = selector;
    if (args && args.length) {
        if (css) {
            const matches = css.match(ARGS_TYPE_REGEX);
            const validationContext = `Selector "${css}"`;
            if (matches) {
                const argx = args.slice();
                matches.forEach(() => {
                    const key = argx.shift();
                    if (!key) {
                        throw new UtamArgsValidationError(generation.ARGS.SELECTOR_MISSING_ARGUMENT(css, getArgumentsNames(args)));
                    }
                    const description = key.description;
                    matchTypes[key.name] = description;
                });
            }
            else {
                throw new UtamArgsValidationError(generation.ARGS.INCORRECT_COUNT(validationContext, args.length, 0));
            }
        }
        else {
            args.forEach((arg) => {
                const description = arg.description;
                if (arg.name.includes(':')) {
                    const [key] = arg.name.split(':');
                    matchTypes[key] = description;
                }
                else {
                    matchTypes[arg.name] = description;
                }
            });
        }
    }
    return matchTypes;
}
/**
 * creates map for method arguments of "name" : "type"
 * @param args declared method args
 * @returns map of names and types for method declaration
 */
function getArgumentsTypeMap(args) {
    const matchTypes = {};
    if (!args) {
        return matchTypes;
    }
    args.forEach((arg) => {
        // only get arg type for non literal args
        if (arg.type !== 'literal' && !('value' in arg) && arg.name) {
            matchTypes[arg.name] = arg.type;
        }
        if ('value' in arg && isUtamSelector(arg.value)) {
            const selector = arg.value;
            if (selector.args) {
                selector.args.forEach((arg) => {
                    matchTypes[arg.name] = arg.type;
                });
            }
        }
    });
    return matchTypes;
}
/**
 * creates map for method arguments of "name" : "description"
 * @param args declared method args
 * @returns map of names and types for method declaration
 */
function getArgumentsDescriptionMap(args) {
    const matchTypes = {};
    if (!args) {
        return matchTypes;
    }
    args.forEach((arg) => {
        // only get arg type for non literal args
        if (arg.type !== 'literal' && !('value' in arg) && arg.name) {
            matchTypes[arg.name] = arg.description;
        }
        if ('value' in arg && isUtamSelector(arg.value)) {
            const selector = arg.value;
            if (selector.args) {
                selector.args.forEach((arg) => {
                    matchTypes[arg.name] = arg.description;
                });
            }
        }
    });
    return matchTypes;
}
/**
 * generates code for the argument value to add inside a method invocations
 * @param arg argument to get value from after traversal in method
 * @param byId string for "By"
 * @returns string with arg value
 */
function generateArgumentValueCode(arg, byId) {
    const { literal, type } = arg;
    if (arg.type === 'argumentReference') {
        return arg.name;
    }
    if (!literal) {
        return arg.name;
    }
    if (isPrimitiveType(type)) {
        const value = arg.value;
        return type === 'string' ? `"${escapeDoubleQuotes(value)}"` : value.toString();
    }
    if (type === 'locator') {
        const value = arg.value;
        return buildLiteralSelectorCode(value, byId);
    }
    throw new Error(`Unsupported argument type: ${JSON.stringify(arg)}`);
}
function isPrimitiveValue(value) {
    return typeof value === 'string' || typeof value === 'boolean' || typeof value === 'number';
}
/**
 * generates code for the argument value to add in method invocations or in hoisted methods
 * @param arg UtamArgument from JSON (for hoisted methods)
 * @param byId string for "By"
 * @returns string with arg value
 */
function generateUtamArgumentValueCode(arg, byId) {
    if (!('value' in arg)) {
        return arg.name;
    }
    const { value } = arg;
    if (isPrimitiveValue(value)) {
        return typeof value === 'string' ? `"${escapeDoubleQuotes(value)}"` : value.toString();
    }
    if (isUtamSelector(value)) {
        return buildLiteralSelectorCode(value, byId);
    }
    throw new Error(`Unsupported argument type: ${JSON.stringify(arg)}`);
}
/**
 * This function creates a function that ensure that compose method have unique arguments names.
 * This returns a closure that keep track of previous statements arguments.
 *
 * @param validationContext name of the structure that is being validated
 * @returns a closure that will ensure that the compose method has unique arguments names
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function createUniqueNamesValidator(validationContext) {
    const composeArgNames = new Set();
    /**
     * This closure is called anytime we try to add new parameters to the compose
     * method signature. It will throw if we have duplicated arguments.
     * It act as a safeguard to ensure we don't generate JS that is invalid (e.g function method(arg, arg) {})
     *
     * @param args argument(s) that need(s) to be validated
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function validateUniqueArgumentsNames(args) {
        if (!Array.isArray(args))
            args = [args];
        for (const arg of args) {
            const { name: argName } = arg;
            if (composeArgNames.has(argName)) {
                throw new UtamArgsValidationError(generation.ARGS.COMPOSE_METHOD_DUPLICATED_ARGUMENT_NAMES(argName, validationContext));
            }
            else {
                composeArgNames.add(argName);
            }
        }
    };
}
/**
 * Getter invocation can have explicit args, including argumentReference.
 * This method validates number and types of arguments, literal or non literal
 * @param elementArgs required element args declared inside the element
 * @param explicitArgs declared args in a getter compose statement
 * @returns array or arguments to be used
 */
function mergeElementAndExplicitArgs(elementArgs, explicitArgs) {
    // if explicit args are not set - return original
    if (explicitArgs.length === 0) {
        return elementArgs;
    }
    // todo - add validation and error codes
    return explicitArgs;
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const STAR_WILDCARD = '*';
/**
 * Add an underscode to guarantee no conflict with anything in user land
 * an even more correct approach would be to use `${module}__${name}`
 * @param name original type name
 * @returns string with modified identifier
 */
function buildIdentifier(name) {
    const toIdentifier = (str) => str.replace(/[^a-zA-Z0-9_]+/g, '_').replace(/^\d/, '_$&');
    return toIdentifier(`_${name}`);
}
/**
 *
 * @param module full module name to import type from, ex. "@utam/lightning/pageobjects/input"
 * @param name short module name, ex. "Input"
 * @param imports map with imports: key is full module name, value is pairs of name and identifier
 * @param defaultImport indicates if import is default
 * @returns string with identifier, ex. "_Input"
 */
function addImport(module, name, imports, defaultImport = false) {
    let moduleMap = imports.get(module);
    if (!moduleMap) {
        moduleMap = new Map();
        imports.set(module, moduleMap);
    }
    let importIdentifier = moduleMap.get(name);
    if (!importIdentifier) {
        importIdentifier = buildIdentifier(name);
        moduleMap.set(defaultImport ? 'default' : name, importIdentifier);
    }
    return importIdentifier;
}
// If two imports have the same specifier merge their importedNames
// so we generate one import declaration rather than two
// Ex. import { a } from "m"; import { b } from "m" => import { a, b } from "m";
function mergeImports(importsMap) {
    const visitedImportsMap = new Map();
    importsMap.forEach((importMap) => {
        const [name, importees] = importMap;
        if (!visitedImportsMap.has(name)) {
            visitedImportsMap.set(name, importMap);
        }
        else {
            const mergedImportMaps = visitedImportsMap.get(name);
            if (mergedImportMaps) {
                mergedImportMaps[1] = new Map([...mergedImportMaps[1], ...importees]);
            }
        }
    });
    return Array.from(visitedImportsMap.values());
}
/**
 * Get the type's substring matched by the wildcard '*' from a given pattern.
 *
 * For instance: if the type value is "utam-foo/pageObjects/path/to/po"
 * and the pattern is "utam-foo/{wildcard}/po", the function returns
 * "pageObjects/path/to"
 *
 * @param type element type value (as declared in the JSON file)
 * @param pattern matching pattern from which we want to extract the wildcard vale=
 * @returns either the substring that '*' matches, either the empty string if no matches are found
 */
function getWildcardValue(type, pattern) {
    if (!pattern.includes(STAR_WILDCARD))
        return '';
    const [preWildcardStr, postWildcardStr] = pattern.split(STAR_WILDCARD);
    const postIndex = type.indexOf(postWildcardStr);
    return type.slice(0, postIndex).replace(preWildcardStr, '');
}
/**
 * Get the type alias from the alias config if there's a match
 *
 * @param type element type value (as declared in the JSON file)
 * @param aliasConfig type alias configuration mappings
 * @returns the alias matching this type, null if none alias are found for this type
 */
function getMatchingAliasForType(type, aliasConfig) {
    for (const matchPattern in aliasConfig) {
        const isMatchingPattern = matchPattern.split('*').every((matchSubPattern) => type.includes(matchSubPattern));
        if (isMatchingPattern) {
            return {
                matchPattern,
                replacePattern: aliasConfig[matchPattern],
            };
        }
    }
    return null;
}
/**
 * Update the module specifier by applying the replacement pattern if there's an alias for this type
 *
 * @param type type element type value (as declared in the JSON file)
 * @param aliasConfig type alias configuration mappings
 * @returns the original module specifier or the updated module specifier if there's an alias matching the type
 */
function replaceTypeString(type, aliasConfig) {
    const alias = getMatchingAliasForType(type, aliasConfig);
    if (!alias) {
        return type;
    }
    else {
        const { matchPattern, replacePattern } = alias;
        const wildcardValue = getWildcardValue(type, matchPattern);
        return type.replace(matchPattern.replace(STAR_WILDCARD, wildcardValue), replacePattern.replace(STAR_WILDCARD, wildcardValue));
    }
}
function generateImports(importsMap, alias) {
    const mergedImportMaps = mergeImports(importsMap);
    return mergedImportMaps.map(([name, importees]) => {
        let defaultSpecifier;
        const namedSpecifiers = [];
        for (const [imported, local] of importees.entries()) {
            if (imported === 'default') {
                defaultSpecifier = local;
            }
            else {
                namedSpecifiers.push(`${imported} as ${local}`);
            }
        }
        let specifiers = '';
        if (defaultSpecifier)
            specifiers += defaultSpecifier;
        if (namedSpecifiers.length) {
            if (specifiers.length)
                specifiers += ', ';
            specifiers += `{ ${namedSpecifiers.join(', ')} }`;
        }
        return `import ${specifiers} from '${replaceTypeString(name, alias)}';`;
    });
}
/**
 * Impure function that updates the context object from the imports data.
 *
 * @param context compose statement context object
 * @param imports imports data used to update the context's imports
 */
function addMissingImportsFromStatementsArgs(context, imports) {
    for (const i of imports) {
        const { moduleSpecifier, name, destination, defaultImport } = i;
        const importIdentifier = addImport(moduleSpecifier, name, context.importsDestination[destination], defaultImport);
        // update the class body _byIdentifier if not already set
        // for instance, non root PO that expose only a compose method that uses CSS locator arguments
        if (name === UTAM_LOCATOR_BY && !context.typeIdentifiers._byIdentifier) {
            context.typeIdentifiers._byIdentifier = importIdentifier;
        }
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function kebabcaseToCamelcase(name, ignoreNamespace) {
    const newName = [];
    let nsFound = false;
    let upper = false;
    for (let i = 0; i < name.length; i++) {
        if (name[i] === '-') {
            if (!ignoreNamespace && !nsFound) {
                nsFound = true;
                newName.push('$');
            }
            else {
                upper = true;
            }
        }
        else {
            newName.push(upper ? name[i].toUpperCase() : name[i]);
            upper = false;
        }
    }
    return newName.join('');
}
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
/**
 * generate method name from an element name, ex. my_button -> getMyButton
 * @param name element name like 'myButton'
 * @param isPublic passed as true if method is public
 */
function elementToMethodName(name, isPublic) {
    // in case Element name contains _
    const camelCaseName = kebabcaseToCamelcase(name, true);
    // convention in JS to name private methods starting from underscore
    const privatePrefix = isPublic ? '' : '__';
    return `${privatePrefix}get${capitalize(camelCaseName)}`;
}
/**
 * Build suffix for the import type name in case of names collisions
 *
 * @param name short module name, ex. "Input"
 * @param module full module name to import type from, ex. "@utam/lightning/pageobjects/input"
 * @param typesTracker tracks names collisions
 * @returns suffix to be added to the type name
 */
function buildNameSuffix(name, module, typesTracker) {
    const moduleNames = typesTracker.get(name);
    // if module for this name is not same as first, it's names collision, so add suffix with number, ex. MyObject1
    if (moduleNames && moduleNames[0] !== module) {
        // if same module was already registered as collision, use already existing index moduleNames.indexOf(module)
        // otherwise use next available index moduleNames.length
        const suffix = (moduleNames.indexOf(module) > 0 ? moduleNames.indexOf(module) : moduleNames.length).toString();
        // remember name for this module, it can be used again in the same page object
        moduleNames.push(module);
        return suffix;
    }
    // remember module for the name
    typesTracker.set(name, [module]);
    return '';
}
/**
 * Generate the module import name from the module path
 * @param moduleSpecifier module path (i.e package-name/path/to/po)
 * @param typesTracker tracks names collisions
 * @returns the module import name
 */
function buildImportNameFromModulePath(moduleSpecifier, typesTracker) {
    const pageObjectName = path.basename(moduleSpecifier);
    const importName = capitalize(kebabcaseToCamelcase(pageObjectName));
    const suffix = buildNameSuffix(importName, moduleSpecifier, typesTracker);
    return importName.concat(suffix);
}
/**
 * Returns generated import name for custom elements and extensions
 * @param moduleSpecifier module path specifier
 * @param typesTracker tracks names collisions
 * @returns the import name of the module
 */
function getImportNameFromPath(moduleSpecifier, typesTracker) {
    return buildIdentifier(buildImportNameFromModulePath(moduleSpecifier, typesTracker));
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const SUPPORTED_MATCHERS$1 = [
    { matcher: 'isTrue', expectedArgs: [] },
    { matcher: 'isFalse', expectedArgs: [] },
    { matcher: 'stringContains', expectedArgs: ['string'] },
    { matcher: 'stringEquals', expectedArgs: ['string'] },
    { matcher: 'notNull', expectedArgs: [] },
];
function getMatcherType(matcherType) {
    const supported = SUPPORTED_MATCHERS$1.find((supported) => supported.matcher === matcherType);
    if (!supported) {
        return undefined;
    }
    return supported.matcher;
}
/**
 * depending on matcher type return expected matcher args types
 * @param structure
 * @param matcherType
 */
function getMatcherExpectedArgs(matcherType) {
    const supported = SUPPORTED_MATCHERS$1.find((supported) => supported.matcher === matcherType);
    if (!supported) {
        return undefined;
    }
    return supported.expectedArgs;
}
function getCompatibleMatchers(actionType) {
    if (!actionType.return || actionType.return === 'unknown') {
        return [];
    }
    else if (actionType.return === 'string') {
        return ['stringContains', 'stringEquals'];
    }
    else if (actionType.return === 'boolean') {
        return ['isTrue', 'isFalse', 'notNull'];
    }
    else {
        return [];
    }
}
function generateMatcherCode(matcherType, explicitArgumentsCode) {
    switch (matcherType) {
        case 'stringContains':
            return `?.includes(${explicitArgumentsCode}) ?? false`;
        case 'isTrue':
            return ` == true`;
        case 'isFalse':
            return ` == false`;
        case 'notNull':
            return ` !== null`;
        case 'stringEquals':
            return ` === ${explicitArgumentsCode}`;
        default:
            // should be caught in validation, never thrown here
            throw new Error(`Unsupported matcher type: "${matcherType}".`);
    }
}
/**
 * helper to build code of the filter method
 * @param matcherType type of the matcher
 * @param filterApplyCode with method invoked in a filter, ex. "await element.${apply}(${applyArgs})"
 * @param filterArg filter argument value
 * @returns generated code for a filter application
 */
function buildFilterFunctionCode(matcherType, filterApplyCode, filterArg) {
    if (matcherType === 'stringContains') {
        return `const result = ${filterApplyCode};\nreturn result.includes(${filterArg});`;
    }
    else if (matcherType === 'stringEquals') {
        return `const result = ${filterApplyCode};\nreturn result === ${filterArg};`;
    }
    else if (matcherType === 'isTrue') {
        return `return ${filterApplyCode};`;
    }
    else if (matcherType === 'isFalse') {
        return `return !(${filterApplyCode});`;
    }
    else if (matcherType === 'notNull') {
        return `const result = ${filterApplyCode};\nreturn result !== null;`;
    }
    else {
        // should be caught in validation, never thrown here
        throw new Error(`Unsupported matcher type: "${matcherType}".`);
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function validateState(declarations, by) {
    if (declarations.length && !by) {
        // if Page Object has only container element it does not need by
        const isContainerPageObject = declarations.length === 1 && declarations[0].isContainer;
        if (!isContainerPageObject) {
            throw new Error('Invalid state while generating module: By identifier must be defined if any declaration exists');
        }
    }
}
function validateShadowExistance(insideShadow, byShadow) {
    if (insideShadow && !byShadow) {
        throw new Error('Invalid state while generating module: Shadow Identifier must be defined if any declaration exists');
    }
}
function generateSelectorDeclarationCode(ast, { byId, shadowId }) {
    // Get context variables for generating the code
    const { name, parentName, selector, parentArgs, parentNullable, insideShadow, isContainer, nullable, parentSelectorReturnsList, parentFilterApplicationName, } = ast;
    const LOCATOR_ID = '_locator';
    const ELEMENT_ID = parentSelectorReturnsList ? '_elements' : '_element';
    validateShadowExistance(ast.insideShadow, shadowId);
    const { returnAll, args = [] } = selector;
    const containerExternalSelector = isContainer && !selector.css;
    const containerArgs = containerExternalSelector ? [UTAM_CONTAINER_LOCATOR] : [];
    const allArgs = ['driver', 'root', ...parentArgs, ...getArgumentsNames(args), ...containerArgs]; // Merge arguments from hierarchy
    const findElementMethod = returnAll ? 'findElements' : 'findElement';
    // Compute expressions to compose the final statements
    // Don't pass args to the element getter for a nested element of a filtered element
    // as args are passed to the filter application hoisted function
    const elementArgs = parentSelectorReturnsList && parentFilterApplicationName ? [] : parentArgs;
    const getElementExpression = parentName
        ? `await ${parentName}(driver, ${'root'.concat(buildAddedArgs(elementArgs))})`
        : `root`;
    const locatorExpression = containerExternalSelector
        ? UTAM_CONTAINER_LOCATOR // for container selector is passed as method parameter, otherwise hardcoded css
        : buildLiteralSelectorCode(selector, byId);
    const elementStatement = `let ${ELEMENT_ID} = ${getElementExpression};`;
    const locatorStatement = `const ${LOCATOR_ID} = ${locatorExpression};`;
    const shadowStatement = insideShadow ? `${ELEMENT_ID} = new ${shadowId}(driver, ${ELEMENT_ID});` : '';
    const parentNullableStatement = parentNullable ? `if (!${ELEMENT_ID}) { return null; }` : '';
    const nullableStatements = nullable
        ? [
            `const hasElement = await ${ELEMENT_ID}.containsElement(${LOCATOR_ID});`,
            `if (!hasElement) { return null; }`,
        ]
        : [];
    const FILTERED_ELEMENT_ID = '_filteredElement';
    const parentFilterParameters = ELEMENT_ID.concat(buildAddedArgs(parentArgs));
    const filterParentElementStatement = parentSelectorReturnsList && parentFilterApplicationName
        ? `const ${FILTERED_ELEMENT_ID} = await ${parentFilterApplicationName}(${parentFilterParameters});`
        : '';
    const returnedElementId = parentSelectorReturnsList ? FILTERED_ELEMENT_ID : ELEMENT_ID;
    const statements = [
        elementStatement,
        parentNullableStatement,
        locatorStatement,
        shadowStatement,
        nullableStatements.join('\n'),
        filterParentElementStatement,
        `return ${returnedElementId}.${findElementMethod}(${LOCATOR_ID});`,
    ].filter(Boolean); // We filter falsy values to remove unnecesary "\n"
    return code `
        async function ${name}(${allArgs.join(', ')}) {
            ${statements}
        }
    `;
}
function generateFilterDeclarationCode(ast, byId) {
    const { filter: { apply, matcher, args = [] }, name, parentArgs, } = ast;
    // FIXME:
    // filter should be able to accept any types of parameters, not just primitives or locator
    // which requires adding ability to import custom types and such
    let applyArgs = '';
    if (args) {
        applyArgs = args.map((arg) => generateUtamArgumentValueCode(arg, byId)).join(', ');
    }
    const filterApplyCode = `await element.${apply}(${applyArgs})`;
    let matcherArg = '';
    if (matcher?.args) {
        matcherArg = matcher.args.map((arg) => generateUtamArgumentValueCode(arg, byId)).join(', ');
    }
    // on top of args inside filter, those can be in selector or in matcher
    const additionalArgs = getArgumentsNames(matcher?.args);
    const filterFunctionCode = buildFilterFunctionCode(matcher.type, filterApplyCode, matcherArg);
    // Merge arguments from hierarchy
    const allArgs = ['element', ...parentArgs, ...getArgumentsNames(args), ...additionalArgs].join(', ');
    return code `
        async function ${name}(${allArgs}) {
           ${filterFunctionCode}
        }
    `;
}
/**
 * Generates the code for the hoisted filter application.
 *
 * This code is being generated when an element has a filter and a nested tree of elements.
 * It's generated once when processing the parent element and the function name is stored in the
 * SelectorDeclarationAST context so that it can be referenced when generating the nested elements hoisted getters.
 *
 * @param ast AST that holds the required information for generating this function
 * @returns the generated code for the hoisted filter application function
 */
function generateFilterApplicationDeclarationCode(ast) {
    const { filter: { matcher, args = [] }, name, elementName, filterFunctionName, parentArgs, } = ast;
    // on top of args inside filter, those can be in selector or in matcher
    const additionalArgs = getArgumentsNames(matcher?.args);
    // Merge arguments from hierarchy
    const filterArgs = [...getArgumentsNames(args), ...additionalArgs];
    const allArgs = [...parentArgs, ...getArgumentsNames(args), ...additionalArgs];
    const filterFunctionParameters = 'el'.concat(buildAddedArgs(filterArgs));
    const functionParameters = 'elements'.concat(buildAddedArgs(allArgs));
    return code `
        async function ${name}(${functionParameters}) {
            const appliedFilter = await Promise.all(
                elements.map((el) => ${filterFunctionName}(${filterFunctionParameters}))
            );
            let _element = elements.find((_, i) => appliedFilter[i]);
            if (!_element) {
                throw new Error('Could not find element "${elementName.toString()}" that matches filter condition!');
            }
            return _element;
        }
    `;
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
let UID = 0;
class BlockDeclarations {
    constructor() {
        this.imports = new Map();
        this._selectorDeclarations = [];
        this._filterDeclarations = [];
        this._filterApplicationDeclarations = [];
    }
    addSelectorFunctionDeclaration(selector, opts) {
        const plural = selector.returnAll ? 's' : '';
        const name = opts.name
            ? `_utam_get_${kebabcaseToCamelcase(opts.name, true)}${plural}`
            : `_utam_get_uuid${++UID}`;
        const isContainerDeclaration = !!opts.isContainer;
        this._selectorDeclarations.push({
            name,
            selector,
            nullable: opts.nullable ?? false,
            parentNullable: opts.parentNullable ?? false,
            parentName: opts.parentName,
            parentArgs: opts.parentArgs || [],
            isContainer: isContainerDeclaration,
            insideShadow: !!opts.insideShadow,
            parentSelectorReturnsList: opts.parentSelectorReturnsList ?? false,
            parentFilterApplicationName: opts.parentFilterApplicationName,
        });
        if (!this._byIdentifier) {
            this._byIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_LOCATOR_BY);
        }
        if (!this._insideShadowIdentifier && opts.insideShadow) {
            this._insideShadowIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_SHADOW_CLASS);
        }
        return name;
    }
    addFilterFunctionDeclaration(filter, opts) {
        const name = opts.name ? `_utam_filter_${kebabcaseToCamelcase(opts.name, true)}` : `_utam_filter_uuid${++UID}`;
        this._filterDeclarations.push({ name, filter, parentArgs: [] });
        return name;
    }
    /**
     * Generates the name of the hoisted function that apply a filter to a parent element and push the required
     * information for code generation in the AST.
     *
     * @param filter element filter object coming from the JSON page object
     * @param opts context that holds the information to push in the AST
     * @returns the name of function that applies the filter to the parent elements
     */
    addFilterApplicationFunctionDeclaration(filter, opts) {
        const name = opts.name
            ? `_utam_apply_filter_${kebabcaseToCamelcase(opts.name, true)}`
            : `_utam_apply_filter_uuid${++UID}`;
        this._filterApplicationDeclarations.push({
            name,
            filter,
            elementName: opts.name ?? UID,
            parentArgs: opts.parentArgs ?? [],
            filterFunctionName: opts.filterFunctionIdentifier ?? `_utam_filter_uuid${UID}`,
        });
        return name;
    }
    addImport(module, name) {
        return addImport(module, name, this.imports);
    }
    render() {
        const { _filterDeclarations, _filterApplicationDeclarations, _selectorDeclarations, _byIdentifier: byId, _insideShadowIdentifier: shadowId, } = this;
        validateState(_selectorDeclarations, byId);
        const filterDeclarations = _filterDeclarations.map((ast) => generateFilterDeclarationCode(ast, byId));
        const selectorDeclarations = _selectorDeclarations.map((ast) => generateSelectorDeclarationCode(ast, { byId, shadowId }));
        const filterApplicationDeclarations = _filterApplicationDeclarations.map((ast) => generateFilterApplicationDeclarationCode(ast));
        return [...filterDeclarations, ...filterApplicationDeclarations, ...selectorDeclarations].join('\n\n');
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function modifyArgumentsForContainer(argsTypes, ctorId = UTAM_CONTAINER_CTOR, byId = UTAM_LOCATOR_BY) {
    argsTypes[UTAM_CONTAINER_LOCATOR] = byId;
    argsTypes[UTAM_CONTAINER_CTOR] = `${ctorId}<T>`;
    return argsTypes;
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Generates a Class name from the element type (for basic element).
 *
 * For instance, if an element is declared as ["editable", "clickable"], this function generates the string
 * ClickableEditableUtamElement. If no type is specified, it default to BasicUtamElement. This function is used
 * when we generate the statements for the basic elements getters.
 *
 * For basic elements, we generate an extra statement that will assign the mixed class returned by _createUtamElement
 * to a variable named after the value returned by this function. For example:
 *
 * const ActivableClickableUtamElement = createUtamMixinCtor(ActivableUtamElement, EditableUtamElement)
 *
 * @param type type of the element for which statements are being generated (parsed from JSON declaration)
 * @returns the class name for basic elements, an empty string for custom and container elements
 */
function createCtorNameFromTypes(type) {
    const UTAM_ELEMENT_SUFFIX = 'UtamElement';
    let constructorName = '';
    if (Array.isArray(type)) {
        constructorName =
            type.length > 0
                ? type
                    .sort()
                    .map((t) => capitalize(t))
                    .join('')
                    .concat(UTAM_ELEMENT_SUFFIX)
                : UTAM_ELEMENT_CTOR_BASE;
    }
    return constructorName;
}
/**
 * Generates the list of mixins that the function _createUtamElement must take to extend the base class.
 *
 * @param type type of the element for which statements are being generated (parsed from JSON declaration)
 * @returns the name of the mixins from which we want to extend the base class (BaseUtamElement)
 */
function mapBasicTypesToCtors(type) {
    return Array.isArray(type) ? `${type.map((t) => `_${getBasicElementTypeCtor(t)}`).join(', ')}` : '';
}
/**
 * Generates the type returned by an element getter used for it's type definition.
 *
 * For instance, if an element is declared as ["editable", "clickable"], this function generates the string
 * BasicUtamElement & ClickableUtamElement & EditableUtamElement.
 *
 * @param type type of the element for which statements are being generated (parsed from JSON declaration)
 * @returns the type of the value returned by the element getter method used for it's type definition
 */
function createBasicElementCtorType(type) {
    return `(_${UTAM_ELEMENT_CTOR_BASE}${type
        .sort()
        .map((t) => getBasicElementTypeCtor(t))
        .reduce((returnedType, t) => `${returnedType} & _${t}`, '')})`;
}

/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * transform text into JS doc comment
 * @todo use replaceAll instead of replace when node 14 is deprecated (~April 2023)
 * @param text string for comment or undefined
 * @returns if text defined, return string wrapped as JS doc comment
 */
function textToJsDoc(text) {
    if (!text || text.length === 0) {
        return '';
    }
    const header = '/**';
    const footer = '*/'.padStart(3, ' ');
    const lines = text
        .filter((line) => line.length > 0)
        .map((line) => {
        // Note: we use RegExps with the global flag to match all occurences
        const htmlFriendlyLine = line
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\*\//g, '*&#47');
        return '* '.padStart(3, ' ').concat(htmlFriendlyLine);
    })
        .filter((line) => line.length > 0);
    return code `
        ${header}
        ${lines}
        ${footer}
    `;
}
/**
 * transform root description from Json to string array
 * @param jsonPath path to JSON source for class JsDoc
 * @param version page object version for class JsDoc
 * @param description from Json source
 * @returns string array with JsDoc lines or empty
 */
function buildRootDescription(jsonPath, version, description) {
    const DEFAULT_DESCRIPTION_AUTHOR = 'UTAM';
    const jsDocLines = [];
    const authorAndDeprecated = [];
    let author = DEFAULT_DESCRIPTION_AUTHOR;
    if (typeof description === 'string') {
        jsDocLines.push(description);
    }
    else {
        if (description) {
            jsDocLines.push(...description.text);
            if (description.author) {
                author = description.author;
            }
            if (description.deprecated) {
                authorAndDeprecated.push(`@deprecated ${description.deprecated}`);
            }
        }
    }
    authorAndDeprecated.unshift(`@author ${author}`);
    if (jsonPath) {
        jsDocLines.push(`generated from JSON ${jsonPath}`);
    }
    // version could be missing in config
    const versionStr = version ? version : new Date().toISOString();
    jsDocLines.push(`@version ${versionStr}`);
    jsDocLines.push(...authorAndDeprecated);
    return jsDocLines;
}
/**
 * transform method description from Json to string array
 * @param description from Json
 * @returns string array with JsDoc lines or empty
 */
function buildMethodDescription(description) {
    if (!description) {
        return [];
    }
    if (typeof description === 'string') {
        return [description];
    }
    const text = [...description.text];
    if (description.return) {
        text.push(`@return ${description.return}`);
    }
    if (description.throws) {
        text.push(`@throws ${description.throws}`);
    }
    if (description.deprecated) {
        text.push(`@deprecated ${description.deprecated}`);
    }
    return text;
}
/**
 * build string with method jsDoc
 * @param description string array with jsDoc lines
 * @param argNames non literal args names
 * @param argsDescriptionMap map of args description
 * @returns string with jsDoc for the method
 */
function buildMethodJsDoc(description, argNames, argsDescriptionMap) {
    const jsDocParams = argNames
        .map((argName) => {
        const argDescription = argsDescriptionMap[argName];
        return argDescription ? `@param ${argName} ${argDescription}` : '';
    })
        .filter((line) => line.length > 0);
    return textToJsDoc([...description, ...jsDocParams]);
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// generate root element getter
function generateRootElementMethodCode(methodAst) {
    const { methodName, typeConstructor, type } = methodAst;
    const basicElementCtorName = createCtorNameFromTypes(type);
    const utamBasicElementCtors = mapBasicTypesToCtors(type);
    return code `
        async ${methodName}() {
            const driver = this.driver;
            const root = await this.getRootElement();
            const ${basicElementCtorName} = ${typeConstructor}(${utamBasicElementCtors});
            return new ${basicElementCtorName}(driver, root);
        }
        `;
}
function generateInterfaceMethodCode(methodAst) {
    const { methodName, description, orderedArgs, argsDescriptionMap } = methodAst;
    const argsStr = orderedArgs.join(', ');
    const jsDoc = buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code `
    ${jsDoc}
    async ${methodName}(${argsStr}) {
        throw new Error(\`Interface method "${methodName}" was not implemented by the concrete implementation class.\`);
    }`;
}
/**
 * generates string with parameters for a method signature, used for code in type definition
 * @param argsNames array with args names
 * @param argsMap method arguments
 * @param typeIdentifiers config with mapping of some type names to the type identifiers
 * @returns parameters for method declaration, ex. "strArg: string, numArg: number"
 */
function generateArgsForMethodSignature(argsNames, argsMap, typeIdentifiers) {
    const typedArgs = argsNames.map((argName) => {
        const argType = argsMap[argName];
        if (!argType) {
            throw new Error(`Unable to match type of the '${argName}' argument`);
        }
        let declaredType;
        switch (argType) {
            case UTAM_ELEMENT_REFERENCE_ARG_TYPE:
                // "element" type should be declared as _BaseUtamElement
                declaredType = typeIdentifiers._elementTypeIdentifier;
                break;
            case UTAM_FRAME_ARG_TYPE:
                declaredType = typeIdentifiers._frameElementTypeIdentifier;
                break;
            case UTAM_PAGE_OBJECT_ARG_TYPE:
                declaredType = `${typeIdentifiers._pageObjectTypeIdentifier}<T>`;
                break;
            case UTAM_ROOT_PAGE_OBJECT_ARG_TYPE:
                declaredType = `${typeIdentifiers._rootPageObjectTypeIdentifier}<T>`;
                break;
            case UTAM_LOCATOR_ARG_TYPE:
                // "locator" type should be declared as _Locator
                declaredType = typeIdentifiers._locatorTypeIdentifier;
                break;
            default:
                // primitive types remain as is
                declaredType = argType;
        }
        return `${argName}: ${declaredType}`;
    });
    return typedArgs.join(', ');
}
/**
 * Generate method signature for type definition of compose or interface methods (not getters!)
 *
 * @param BaseMethodAst AST with method signature
 * @param typeIdentifiers config with mapping of some type names to the type identifiers
 * @returns method declaration string
 */
function generateBaseMethodTypeDefinition({ methodName, orderedArgs, argsTypeMap, argsDescriptionMap, typeConstructor, returnsList, description, }, typeIdentifiers) {
    const pageObjectOrRootPageObjectArg = Object.values(argsTypeMap).find((type) => type === UTAM_ROOT_PAGE_OBJECT_ARG_TYPE || type === UTAM_PAGE_OBJECT_ARG_TYPE);
    const isRootPageObjectType = typeConstructor === UTAM_BASE_ROOT_CLASS_NAME ||
        pageObjectOrRootPageObjectArg === UTAM_ROOT_PAGE_OBJECT_ARG_TYPE;
    // if method accepts PO type as parameter, add <T extends...> to declaration
    const genericPageObjectType = pageObjectOrRootPageObjectArg
        ? `<T extends ${buildIdentifier(isRootPageObjectType ? UTAM_BASE_ROOT_CLASS_NAME : UTAM_BASE_CLASS_NAME)}>`
        : '';
    const methodArgumentsTyped = generateArgsForMethodSignature(orderedArgs, argsTypeMap, typeIdentifiers);
    const listType = returnsList ? '[]' : '';
    const jsDoc = buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    const isReturnTypePageObject = 
    // typeConstructor starts from "_", like "_UtamBasePageObject"
    typeConstructor.endsWith(UTAM_BASE_ROOT_CLASS_NAME) || typeConstructor.endsWith(UTAM_BASE_CLASS_NAME);
    // if method returns page object AND accepts PO type as parameter - it should return Promise<T>
    const returnType = pageObjectOrRootPageObjectArg && isReturnTypePageObject ? 'T' : typeConstructor;
    return code `
        ${jsDoc}
        ${methodName}${genericPageObjectType}(${methodArgumentsTyped}): Promise<${returnType}${listType}>;
    `;
}
// generate element getter
function generateElementMethodCode(elementAst) {
    const { methodName, type, args, parentArgs, nullable, parentNullable, hoistedFunctionIdentifier, typeConstructor, hasSelector, selectorReturnsList, returnsList, filterFunctionIdentifier, filterFunctionArgs, filterReturnsList, description, argsDescriptionMap, orderedArgs, elementName, } = elementAst;
    const hasContainer = isContainerElement(type);
    const nullableType = nullable || parentNullable;
    const methodArguments = getElementMethodArgs(elementAst).join(', ');
    const hoistedMethodArguments = buildAddedArgs([
        ...parentArgs,
        ...args,
        ...(hasContainer && !hasSelector ? [UTAM_CONTAINER_LOCATOR] : []),
    ]);
    const elementsVarName = selectorReturnsList ? 'elements' : 'element';
    const findStatement = code `let ${elementsVarName} = await ${hoistedFunctionIdentifier}(driver, root${hoistedMethodArguments});`;
    const nullableStatement = nullableType ? `if (!${elementsVarName}) { return null; }` : '';
    /*
     * Return UtamClass statement:
     * elements.map((e) => { new Ctor(e, ...args); });
     */
    const basicElementCtorName = createCtorNameFromTypes(type) || typeConstructor;
    const utamBasicElementCtors = mapBasicTypesToCtors(type);
    const basicElementConstructorStatement = Array.isArray(type)
        ? `const ${basicElementCtorName} = ${typeConstructor}(${utamBasicElementCtors});`
        : '';
    /**
     * Create statement
     */
    const customElementFactoryFn = buildIdentifier(UTAM_ELEMENT_FACTORY_FN);
    const Ctor = Array.isArray(type) ? basicElementCtorName : typeConstructor;
    const createStatementSingle = isCustomType(type)
        ? code `${elementsVarName} = await ${customElementFactoryFn}(${typeConstructor}, driver, ${elementsVarName});`
        : code `${elementsVarName} = new ${Ctor}(driver, ${elementsVarName});`;
    const createStatementList = isCustomType(type)
        ? code `${elementsVarName} = await Promise.all(${elementsVarName}.map(function _createElement(element) {
            return ${customElementFactoryFn}(${typeConstructor}, driver, element);
        }));`
        : code `${elementsVarName} = ${elementsVarName}.map(function _createElement(element) {
            return new ${basicElementCtorName}(driver, element);
        });`;
    const createStatement = returnsList || filterFunctionIdentifier ? createStatementList : createStatementSingle;
    /*
     * Filter statement:
     * await Promise.all(elements.map(el => filterPredicate(el)))
     *              .then(find first match or return undefined);
     */
    let filterStatement = '';
    if (filterFunctionIdentifier) {
        const filterArgs = buildAddedArgs(filterFunctionArgs);
        const operandId = 'el';
        // find first match or apply filter depending on "findFirst" property
        const filterCollector = filterReturnsList ? 'filter' : 'find';
        // add code that checks if match not found
        const matchNotFoundCondition = filterReturnsList
            ? `!${elementsVarName} || ${elementsVarName}.length === 0`
            : `!${elementsVarName}`;
        // if match not found, for nullable we return null or empty array, for not nullable throw
        const matchNotFoundConditionResult = nullable
            ? filterReturnsList
                ? 'return [];'
                : 'return null;'
            : `throw new Error('Could not find element "${elementName}" that matches filter condition!');`;
        filterStatement = code `
        const appliedFilter = await Promise.all(${elementsVarName}.map(${operandId} => ${filterFunctionIdentifier}(${operandId}${filterArgs})));
        ${elementsVarName} = ${elementsVarName}.${filterCollector}((_, i) => appliedFilter[i]);
        if(${matchNotFoundCondition}) {
            ${matchNotFoundConditionResult}
        }
        `;
    }
    let beforeLoadStatement = '';
    if (isCustomType(type)) {
        const operandId = 'el';
        beforeLoadStatement = returnsList
            ? `await Promise.all(${elementsVarName}.map(${operandId} => ${operandId}.${BEFORE_LOAD_METHOD_NAME}()));`
            : `await ${elementsVarName}.${BEFORE_LOAD_METHOD_NAME}();`;
    }
    const statements = [
        basicElementConstructorStatement,
        findStatement,
        nullableStatement,
        createStatement,
        filterStatement,
        beforeLoadStatement,
        // Filter falsy values to remove unnecesary "\n"
    ]
        .filter(Boolean)
        .join('\n');
    const jsDoc = buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code `
        ${jsDoc}
        async ${methodName}(${methodArguments}) {
            const driver = this.driver;
            const root = await this.getRootElement();
            ${statements}
            return ${elementsVarName};
        }`;
}
// accumulate all args of an element getter: parent, selector, filter
function getElementMethodArgs({ hasSelector, parentArgs = [], args = [], filterFunctionArgs = [], type, }) {
    return [
        ...parentArgs,
        ...args,
        ...(isContainerElement(type)
            ? hasSelector
                ? [UTAM_CONTAINER_CTOR]
                : [UTAM_CONTAINER_CTOR, UTAM_CONTAINER_LOCATOR]
            : []),
        ...filterFunctionArgs,
    ];
}
// generate element getter method signature for type definition
function generateElementMethodTypeDefinition({ methodName, type, parentArgs, args, hasSelector, argsTypeMap: rawArgsMap, argsDescriptionMap, nullable, parentNullable, filterFunctionArgs, typeConstructor, returnsList, description, }, typeIdentifiers) {
    const { _containerType, _containerReturnTypeGenericBound, _byIdentifier } = typeIdentifiers;
    const containerType = type && isContainerElement(type);
    const listType = returnsList ? '[]' : '';
    const nullableType = nullable || parentNullable ? ' | null' : '';
    let constructorType = typeConstructor;
    if (Array.isArray(type)) {
        constructorType = createBasicElementCtorType(type);
    }
    else if (containerType) {
        constructorType = 'T';
    }
    const genericPrefixType = containerType && _containerReturnTypeGenericBound ? `<T extends ${_containerReturnTypeGenericBound}>` : '';
    const orderedArgs = [
        ...parentArgs,
        ...args,
        ...(containerType ? (hasSelector ? [UTAM_CONTAINER_CTOR] : [UTAM_CONTAINER_CTOR, UTAM_CONTAINER_LOCATOR]) : []),
        ...filterFunctionArgs,
    ];
    const argsTypeMap = containerType
        ? modifyArgumentsForContainer(rawArgsMap, _containerType, _byIdentifier)
        : rawArgsMap;
    const methodArgumentsTyped = generateArgsForMethodSignature(orderedArgs, argsTypeMap, typeIdentifiers);
    const jsDoc = buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code `
        ${jsDoc}
        ${methodName}${genericPrefixType}(${methodArgumentsTyped}): Promise<${constructorType}${listType}${nullableType}>;
    `;
}
// find element AST by element name
function findElementAst(elementName, elementMethodsAst) {
    if (!elementMethodsAst) {
        throw new Error(`Unable to search for an element "${elementName}" accessor: context of element methods is undefined`);
    }
    const elementRefAst = elementMethodsAst.find((ast) => ast.elementName === elementName);
    if (!elementRefAst) {
        // never happens in reality, checked during validation phase
        throw new Error(`Unable to find accessor for an element with name "${elementName}".`);
    }
    return elementRefAst;
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * convert a argNode into a Map where keys are the name property value and the value are the node itself.
 * this only works with arguments that doesn't hold literal argument as it's meant to be used for
 * compose arguments.
 * @param argNode method arguments that are being converted
 * @returns a map whose key is the node's name and the value the node itself
 */
function buildArgsNodeMap(argNode) {
    if (!argNode?.children?.length)
        return new Map();
    return argNode.children.reduce((argsMap, rootArgNode) => {
        // The method arguments were already validated in validateMethod
        const nameNode = findNodeAtLocation(rootArgNode, ['name']);
        const nameValue = getNodeValue(nameNode);
        argsMap.set(nameValue, rootArgNode);
        return argsMap;
    }, new Map());
}
/**
 * if type is argumentReference - find node in a top level map or return undefined, invocator will throw an error
 * @param nameValue name of the argument to find in map of declared args
 * @param rootArgsMap map with declared args at the top level
 * @returns undefined if nothing found
 */
function getReferencedArgument(nameValue, rootArgsMap) {
    // ensure one can't reference unexisting arguments
    if (rootArgsMap && rootArgsMap.has(nameValue)) {
        // replace the reference type by it's associated type
        // defined in the root arguments map
        const argNode = rootArgsMap.get(nameValue);
        const typeNode = findNodeAtLocation(argNode, ['type']);
        if (typeNode) {
            return getNodeValue(typeNode);
        }
    }
    return undefined;
}
/**
 * Return the last predicate statement from a function argument
 * @param composeAction compose statement
 * @returns last item in the predicate array
 */
function getLastPredicateStatement(composeAction) {
    const { args } = composeAction;
    const { predicate } = args[0];
    const lastPredicateStatement = predicate[predicate.length - 1];
    return lastPredicateStatement;
}
function isOnlyValueAllowed(supports) {
    return supports === 'onlyValues';
}
function isValueNotAllowed(supports) {
    return supports === 'onlyNameType';
}
function isSameArgumentType(expectedType, actualType) {
    return expectedType === actualType;
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const UTAM_CURRENT_PO_INSTANCE = 'this';
const RETURN_TYPE_VOID = {
    returnTypeValue: UTAM_VOID_RETURN_TYPE,
    returnTypeKind: UTAM_RETURN_CATEGORY_VOID,
};
// -- Type Guards and utilites for return types
function isReturnTypePrimitive(type) {
    return (typeof type === 'string' &&
        [UTAM_STRING_RETURN_TYPE, UTAM_BOOLEAN_RETURN_TYPE, UTAM_NUMBER_RETURN_TYPE].includes(type));
}
function isReturnTypePageObject(type) {
    return typeof type === 'string' && UTAM_PAGE_OBJECT_RETURN_TYPE === type;
}
function isReturnTypeRootPageObject(type) {
    return typeof type === 'string' && UTAM_ROOT_PAGE_OBJECT_RETURN_TYPE === type;
}
function isReturnTypeFrame(type) {
    return typeof type === 'string' && UTAM_FRAME_RETURN_TYPE === type;
}
function isReturnTypeSelf(apply) {
    return RETURN_SELF_ACTION === apply;
}
function isBasicElementAction(composeAction, type) {
    const { apply, chain } = composeAction;
    if (!chain && apply) {
        return Array.isArray(type) || BASIC_ELEMENT_TYPES.includes(type);
    }
    return false;
}
function isGetterWithoutReturnType(composeAction) {
    const { element, returnType, apply, chain } = composeAction;
    if (chain || apply || returnType) {
        return false;
    }
    return element ? true : false;
}
/**
 * Get abstract method return type from the declared returnType
 *
 * @param returnType return type declared in the page object
 * @param typesTracker tracks names collisions
 * @returns the TypeScript type name returned by the method
 */
function getExplicitReturnType(returnType, typesTracker) {
    // string, number, boolean
    if (isReturnTypePrimitive(returnType)) {
        return {
            returnTypeValue: returnType,
            returnTypeKind: UTAM_RETURN_CATEGORY_PRIMITIVE,
        };
    }
    // pageObject - returnPageObject<T extends _UtamBasePageObject>(): Promise<T>;
    if (isReturnTypePageObject(returnType)) {
        return {
            returnTypeValue: getImportNameFromPath(UTAM_BASE_CLASS_NAME, typesTracker),
            returnTypeKind: UTAM_RETURN_CATEGORY_PAGE_OBJECT,
        };
    }
    // rootPageObject - returnRootPageObject<T extends _UtamBaseRootPageObject>(): Promise<T>;
    if (isReturnTypeRootPageObject(returnType)) {
        return {
            returnTypeValue: getImportNameFromPath(UTAM_BASE_ROOT_CLASS_NAME, typesTracker),
            returnTypeKind: UTAM_RETURN_CATEGORY_ROOT_PAGE_OBJECT,
        };
    }
    // frame - returnFrame(): Promise<_FrameUtamElement>
    if (isReturnTypeFrame(returnType)) {
        return {
            returnTypeValue: getImportNameFromPath(UTAM_FRAME_ELEMENT_CTOR, typesTracker),
            returnTypeKind: UTAM_RETURN_CATEGORY_FRAME_ELEMENT,
        };
    }
    // for interface return type covers basic elements, custom elements, 'void'
    const elementType = returnType;
    if (isCustomType(elementType)) {
        return {
            returnTypeValue: getImportNameFromPath(elementType, typesTracker),
            returnTypeKind: UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT,
        };
    }
    else if (isBasicElement(elementType)) {
        const basicElementType = wrapSingleBasicTypeInArray(elementType);
        return {
            returnTypeValue: createBasicElementCtorType(basicElementType),
            returnTypeKind: UTAM_RETURN_CATEGORY_BASIC_ELEMENT,
        };
    }
    return RETURN_TYPE_VOID;
}
/**
 * Return type generator for compose statement
 * @param typesTracker
 * @param elementMethodsAst
 * @returns
 */
function createReturnTypeGenerator(typesTracker, elementMethodsAst) {
    // create a closure to have access to the elements AST for waitFor predicate's statements
    return function generateReturnType(composeAction, elementType) {
        const { matcher, apply, returnType } = composeAction;
        if (matcher) {
            return {
                returnTypeValue: UTAM_BOOLEAN_RETURN_TYPE,
                returnTypeKind: UTAM_RETURN_CATEGORY_PRIMITIVE,
            };
        }
        const explicitReturnType = returnType ? getExplicitReturnType(returnType, typesTracker) : undefined;
        // predicate, should be checked prior to basic action: it's basic action when called on basic element
        if (apply === 'waitFor') {
            const lastPredicateStatement = getLastPredicateStatement(composeAction);
            const generateReturnType = createReturnTypeGenerator(typesTracker, elementMethodsAst);
            const { element, chain: isChain = false } = lastPredicateStatement;
            const elementAst = element && !isChain ? findElementAst(element, elementMethodsAst).type : undefined;
            const returnType = generateReturnType(lastPredicateStatement, elementAst);
            return returnType;
        }
        // basic element action - return type can be inferred
        if (isBasicElementAction(composeAction, elementType)) {
            const { apply: applyAction } = composeAction;
            const basicAction = buildActionByName(applyAction);
            const returnTypeValue = basicAction?.return ?? UTAM_VOID_RETURN_TYPE;
            const returnTypeKind = returnTypeValue !== UTAM_VOID_RETURN_TYPE ? UTAM_RETURN_CATEGORY_PRIMITIVE : UTAM_RETURN_CATEGORY_VOID;
            // basic action can only return primitive, so string is same as value
            return { returnTypeValue, returnTypeKind };
        }
        // getter invocation, not chain
        if (isGetterWithoutReturnType(composeAction) && elementType) {
            const { returnTypeValue, returnTypeKind } = inferReturnTypeFromElementType(elementType, typesTracker);
            return { returnTypeValue, returnTypeKind };
        }
        // this is needed for method to return Promise<this> in a declaration file
        if (apply && isReturnTypeSelf(apply)) {
            return {
                returnTypeValue: UTAM_CURRENT_PO_INSTANCE,
                returnTypeKind: UTAM_RETURN_CATEGORY_SELF,
            };
        }
        // since we can't infer return for other types of statements - return explicit or void
        return explicitReturnType ? explicitReturnType : RETURN_TYPE_VOID;
    };
}
/**
 * Infer return type for non-chained element getter
 * @param elementType type of the element whose getter is invoked
 * @param typesTracker names collisions types tracker
 * @returns inferred return type
 */
function inferReturnTypeFromElementType(elementType, typesTracker) {
    let returnTypeValue;
    let returnTypeKind;
    if (isFrameElement(elementType)) {
        returnTypeValue = getImportNameFromPath(elementType, typesTracker);
        returnTypeKind = UTAM_RETURN_CATEGORY_FRAME_ELEMENT;
    }
    else if (isCustomType(elementType)) {
        returnTypeValue = getImportNameFromPath(elementType, typesTracker);
        returnTypeKind = UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT;
    }
    else if (isBasicElement(elementType)) {
        const basicElementType = wrapSingleBasicTypeInArray(elementType);
        returnTypeValue = createBasicElementCtorType(basicElementType);
        returnTypeKind = UTAM_RETURN_CATEGORY_BASIC_ELEMENT;
    }
    else {
        // We don't infer return type for other element types
        return RETURN_TYPE_VOID;
    }
    return {
        returnTypeValue,
        returnTypeKind,
    };
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
class UtamValidationError extends Error {
    constructor(diagnostic) {
        super(diagnostic.message);
        this.utamError = true;
        this.position = diagnostic.position;
    }
}
/**
 * build diagnostics error based on compiler config
 * @param errCode configured code
 * @returns diagnostics object to pass to exception
 */
function buildDiagnostics(errCode, args) {
    const error = getConfiguredError(errCode);
    return { message: buildMessageFromConfig(error, args) };
}
/**
 * error thrown in Json validation phase using error codes
 */
class UtamCompilerValidationError extends UtamValidationError {
    constructor({ offset }, errCode, args) {
        super(buildDiagnostics(errCode, args));
        this.position = { offset };
    }
}
/**
 * error thrown during validation of Json (prior to generation)
 */
class UtamSchemaValidationError extends UtamValidationError {
    constructor(diagnostic) {
        super(diagnostic);
        this.position = diagnostic.position;
    }
}
/**
 * error thrown by Json parser
 */
class UtamJsonValidationError extends UtamValidationError {
    constructor(diagnostic) {
        super(diagnostic);
        this.json = true;
        this.position = diagnostic.position;
    }
}
function calculatePositionFromSource(error, source) {
    const partialPosition = error.position;
    if (partialPosition !== undefined) {
        const lines = source.split('\n');
        let countedChars = 0;
        for (const [index, line] of lines.entries()) {
            const newLength = countedChars + line.length;
            if (newLength >= partialPosition.offset - 1) {
                error.position = {
                    offset: partialPosition.offset,
                    line: index + 1,
                    length: partialPosition.length,
                    column: partialPosition.offset - countedChars,
                };
                return partialPosition;
            }
            countedChars = newLength + 1;
        }
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * find and return element reference together with collected element args
 * if element was already "visited" (args already collected), return empty array of element args
 * @param elementName name of the element
 * @param elementMethodsAst array of known element getters
 * @param visitedElements tracker of visited elements
 * @returns array of non literal args and reference to a getter method
 */
function findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst) {
    const elementRefAst = findElementAst(elementName, elementMethodsAst);
    // element was already "visited" (args already collected)
    if (visitedElements.has(elementName)) {
        return { elementRefAst, elementArgs: [] };
    }
    visitedElements.add(elementName);
    const elementArgs = Object.entries(elementRefAst.argsTypeMap).map(([name, type]) => {
        const description = elementRefAst.argsDescriptionMap[name];
        const arg = {
            name,
            type,
            // can be undefined
            description,
            literal: false,
        };
        return arg;
    });
    return { elementRefAst, elementArgs };
}
/**
 * find and return referenced method parameter
 * @param arg argument object
 * @param context traversal context with visited args and method args
 * @returns undefined if element was already referenced or found arg
 */
function findReferencedArg(arg, context) {
    const { visitedMethodArgsNames, methodArgs } = context;
    const { name: argName } = arg;
    if (!visitedMethodArgsNames.has(argName)) {
        const methodArg = methodArgs.find((methodArg) => methodArg.name === argName);
        // Here we explicitly cast methodArg.
        // We know that methodArg will be defined as all reference args points to
        // existing method args. Otherwise the validation of the PO would have thrown
        const { name, type, description } = methodArg;
        visitedMethodArgsNames.add(argName);
        return { type, name, literal: false, description };
    }
}
function traverseElementReference(reducer, arg, astConfig, options, context) {
    const { visitedElements } = context;
    const { elementMethodsAst } = astConfig;
    const nestedLiteralArgs = arg.args;
    // if element reference has nested literal args - recursive traversal
    if (nestedLiteralArgs) {
        const nestedArgs = traverseArguments(nestedLiteralArgs, astConfig, options, context);
        reducer.push(...nestedArgs);
    }
    else {
        const elementName = arg.value;
        // collect args of the element getter if exist
        const inferredArgs = findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst)
            .elementArgs;
        reducer.push(...inferredArgs);
    }
}
function traversePredicateStatement(reducer, predicate, astConfig, options, context) {
    const { visitedElements } = context;
    const { elementMethodsAst } = astConfig;
    const { chain: isChain = false } = predicate;
    const elementName = predicate.element ?? 'self';
    // collect args of the element getter if exist
    const elementArgs = elementName === 'self' || isChain
        ? []
        : findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst).elementArgs;
    elementArgs.forEach((arg) => reducer.push(arg));
    // recursive traversal of predicate statements
    const nestedArgs = traverseArguments(predicate.args, astConfig, options, context);
    reducer.push(...nestedArgs);
    // predicate statement can have matcher that requires further traversal
    if (predicate.matcher && predicate.matcher.args) {
        const matcherArgs = traverseArguments(predicate.matcher.args, astConfig, options, context);
        reducer.push(...matcherArgs);
    }
}
function traverseSelectorValue(reducer, arg, astConfig, options, context) {
    const nestedArgs = traverseArguments(arg.args, astConfig, options, context);
    reducer.push(...nestedArgs);
}
/**
 * traverse args deep into predicates to collect ALL method parameters
 * @param args declared args
 * @param astConfig context of the processed page object
 * @param options context to processed args
 * @returns array of explicit args
 */
function traverseArguments(args, astConfig = { typeNamesTracker: new Map() }, options = {}, context) {
    const flatArgs = [];
    if (!args) {
        return flatArgs;
    }
    return args.reduce((reducer, arg) => {
        const implicitLiteral = !arg.type || arg.type === 'literal';
        const value = arg.value;
        const type = implicitLiteral ? deriveLiteralType(value) : arg.type;
        const literal = 'value' in arg || type === 'function';
        const explicitArg = { ...arg, type, literal };
        // Early return of reference arg that aren't considered literal anymore
        // as they must be added to the compose method's parameters.
        // This block ensure we only add reference arg once to the compose args
        if (type === UTAM_ARGUMENT_REFERENCE_ARG_TYPE && context) {
            const referencedArg = findReferencedArg(arg, context);
            // if same arg was already referenced, method returned undefined
            // so nothing is pushed to returned args as it's already there
            if (referencedArg) {
                reducer.push(referencedArg);
            }
            return reducer;
        }
        if (!literal || !options.excludeLiterals) {
            // Skip literals when option being passed
            reducer.push(explicitArg);
        }
        // Recursively walk all the nested arguments on the function, locator or element
        // We need to get both explicit arguments and implicit element arguments
        if (options.deep && literal && astConfig && context) {
            if (type === 'elementReference') {
                traverseElementReference(reducer, arg, astConfig, options, context);
            }
            else if (type === 'locator') {
                traverseSelectorValue(reducer, value, astConfig, options, context);
            }
            else if (type === 'function') {
                arg.predicate.forEach((predicate) => {
                    traversePredicateStatement(reducer, predicate, astConfig, options, context);
                });
            }
        }
        return reducer;
    }, flatArgs);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var _ArgImportsBuilder_rules;
function isUtamMethodUtility(method) {
    return method.applyExternal !== undefined;
}
/**
 * build utility statement with "applyExternal"
 * @param composeAction JSON object with the method statement
 * @param context statement context
 * @param traversalContext traversal context
 * @returns method statement ast
 */
function buildUtilityStatement(composeAction, context, traversalContext) {
    const { astConfig, importsDestination } = context;
    const { applyExternal, returnAll: returnsList = false, returnType = UTAM_VOID_RETURN_TYPE } = composeAction;
    const moduleSpecifier = applyExternal.type;
    const namedImport = applyExternal.invoke;
    const applyArgs = traverseArguments(applyExternal.args, astConfig);
    const nonLiteralArgs = traverseArguments(applyExternal.args, astConfig, {
        deep: true,
        excludeLiterals: true,
    }, traversalContext);
    const { composeArgs, argsNamesValidator } = traversalContext;
    argsNamesValidator(nonLiteralArgs);
    composeArgs.push(...nonLiteralArgs);
    // inside predicate not needed
    addImport(moduleSpecifier, namedImport, importsDestination.extensions);
    // utility relies only on explicitely declared return type
    const explicitReturnType = getExplicitReturnType(returnType, astConfig.typeNamesTracker);
    return {
        applyFunction: applyExternal.invoke,
        applyFunctionArgs: applyArgs,
        moduleReference: applyExternal.type,
        returnType: explicitReturnType,
        returnsList,
    };
}
/**
 * build getter statement, could be chained or with self element
 * @param composeAction JSON object with the method statement
 * @param elementReferense reference if an element is from same JSON
 * @param explicitArgs getter explicit args declared in JSON
 * @param returnType return type object
 * @returns method statement ast
 */
function buildGetterStatement(composeAction, elementReferense, explicitArgs, returnType) {
    const { element: elementName = 'self', chain: isChain = false, returnAll: returnsList = false, matcher, } = composeAction;
    // element getter is called on self from same page object
    if (elementReferense?.elementRefAst) {
        const { elementArgs, elementRefAst } = elementReferense;
        // if args are explicitely set - use those that are explicit instead ones from ElementReferenceAst
        const getterArgs = mergeElementAndExplicitArgs(elementArgs, explicitArgs);
        // todo - if returnType or returnAll is set - verify
        return {
            elementName: 'self',
            applyFunction: elementRefAst.methodName,
            applyFunctionArgs: getterArgs,
            isChain,
            returnsList: matcher ? false : elementRefAst.selectorReturnsList && elementRefAst.filterReturnsList,
            returnType,
            matcher: matcher,
        };
    }
    // chain element getter from another PO
    if (!isChain) {
        // never happens in reality, checked during validation phase
        throw new Error(`Unable to find accessor for an element with name "${elementName}".`);
    }
    return {
        applyFunction: elementToMethodName(elementName, true),
        applyFunctionArgs: explicitArgs,
        isChain,
        returnType,
        returnsList,
        matcher: matcher,
    };
}
/**
 * Infer cardinality of return type if possible. We can do it only if statement uses an element from the same page object.
 *
 * @param composeAction JSON statement
 * @param returnTypeKind if return type is void, cardinality is not list
 * @param context elements context to access element types
 * @returns boolean true if inferred to return list and last statement (for predicate) or current statement
 */
function inferStatementReturnCardinality(composeAction, returnTypeKind, context) {
    const elementMethodsAst = context.astConfig.elementMethodsAst;
    const lastStatement = composeAction.apply === 'waitFor' ? getLastPredicateStatement(composeAction) : composeAction;
    if (lastStatement.matcher || returnTypeKind === UTAM_RETURN_CATEGORY_VOID) {
        return { returnsList: false, lastStatement };
    }
    const { element, chain: isChain = false, returnAll: returnsList = false } = lastStatement;
    if (element && !isChain) {
        // returnAll might be inferred if getter invoked
        const elementRefAst = findElementRefWithCollectedArgs(element, new Set(), elementMethodsAst).elementRefAst;
        if (elementRefAst) {
            return { returnsList: elementRefAst.selectorReturnsList && elementRefAst.filterReturnsList, lastStatement };
        }
    }
    return { returnsList, lastStatement };
}
/**
 * transform compose statements array with apply/applyExternal into
 * array of AST objects and accumulated args
 * @param context statements context
 * @param compose compose statements
 * @param methodArgs args at the method level
 * @returns transformed statements
 */
function transformComposeStatements(context, compose, methodArgs) {
    const { astConfig } = context;
    const { elementMethodsAst, typeNamesTracker } = astConfig;
    const validateUniqueArgumentsNames = createUniqueNamesValidator(context.methodName);
    const generateReturnType = createReturnTypeGenerator(typeNamesTracker, elementMethodsAst);
    const traversalContext = {
        visitedElements: new Set(),
        visitedMethodArgsNames: new Set(),
        argsNamesValidator: validateUniqueArgumentsNames,
        methodArgs: methodArgs,
        composeArgs: [],
    };
    const { visitedElements, composeArgs } = traversalContext;
    const importsBuilder = new ArgImportsBuilder(typeNamesTracker);
    let returnType = RETURN_TYPE_VOID;
    let lastStatementReturn = compose[compose.length - 1].returnType;
    let lastStatementReturnAll = false;
    const composeStatements = compose.map((composeAction, index) => {
        const isLastStatement = index === compose.length - 1;
        if (isUtamMethodUtility(composeAction)) {
            return buildUtilityStatement(composeAction, context, traversalContext);
        }
        // for waitFor always replace caller element by "this"
        if (composeAction.apply === 'waitFor') {
            composeAction.element = 'self';
        }
        const { element: elementName = 'self', chain: isChain = false, matcher } = composeAction;
        // collect compose arguments
        const applyArgs = traverseArguments(composeAction.args, astConfig);
        const elementAst = elementName === 'self' || isChain
            ? { elementArgs: [] }
            : findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst);
        const { elementRefAst } = elementAst;
        // first check if explicit returnType is set or use default
        const statementReturnType = generateReturnType(composeAction, elementRefAst?.type);
        // then try to infer
        const { returnsList, lastStatement } = inferStatementReturnCardinality(composeAction, statementReturnType.returnTypeKind, context);
        if (isLastStatement) {
            returnType = statementReturnType;
            addImportForGetterReturnType(lastStatement, context);
            lastStatementReturn = lastStatement.returnType;
            lastStatementReturnAll = returnsList;
        }
        // getter can be invoked with explicit args, so ignore its default args
        const elementArgs = !composeAction.apply && applyArgs.length > 0 && !isChain ? [] : elementAst.elementArgs;
        // collect element arguments, empty for 'self' and chain statements
        validateUniqueArgumentsNames(elementArgs);
        composeArgs.push(...elementArgs);
        // add missing imports for locator, frame, pageObject and rootPageObject from statement args
        const importsData = importsBuilder.mapArgToImports(applyArgs);
        addMissingImportsFromStatementsArgs(context, importsData);
        const nonLiteralArgs = traverseArguments(composeAction.args, astConfig, {
            deep: true,
            excludeLiterals: true,
        }, traversalContext);
        // collect matcher arguments
        const nonLiteralMatcherArgs = traverseArguments(composeAction.matcher?.args, astConfig, {
            excludeLiterals: true,
        });
        const statementNonLiteralArgs = [
            ...nonLiteralArgs,
            ...nonLiteralMatcherArgs,
        ];
        validateUniqueArgumentsNames(statementNonLiteralArgs);
        composeArgs.push(...statementNonLiteralArgs);
        // element getters
        if (!composeAction.apply) {
            return buildGetterStatement(composeAction, elementAst, applyArgs, statementReturnType);
        }
        if (!elementRefAst) {
            if (!isChain) {
                // self method called
                return {
                    elementName,
                    applyFunction: composeAction.apply,
                    applyFunctionArgs: applyArgs,
                    matcher,
                    isChain,
                    returnType: statementReturnType,
                    returnsList,
                };
            }
            // action applied to element(s) returned from previous statement
            return {
                applyFunction: composeAction.apply,
                applyFunctionArgs: applyArgs,
                matcher,
                isChain,
                returnType: statementReturnType,
                returnsList,
            };
        }
        // regular element + apply action
        return {
            elementName,
            elementType: elementRefAst.type,
            elementNullable: elementRefAst.nullable ?? false,
            elementGetMethod: elementRefAst.methodName,
            elementArgs: elementRefAst.orderedArgs,
            isChain,
            returnType: statementReturnType,
            returnsList,
            applyFunction: composeAction.apply,
            applyFunctionArgs: applyArgs,
            matcher,
        };
    });
    return { statements: composeStatements, composeArgs, returnType, lastStatementReturnAll, lastStatementReturn };
}
/**
 * Class that creates imports objects from the compose statement arguments.
 * Those object can be destructured and passed to the addImport function to update
 * the class imports maps.
 */
class ArgImportsBuilder {
    /**
     * Creates a new ArgImportsBuilder object
     * @param typesNamesTracker type names collisions tracker for imports
     */
    constructor(typesNamesTracker) {
        /** import rules maps */
        _ArgImportsBuilder_rules.set(this, void 0);
        __classPrivateFieldSet(this, _ArgImportsBuilder_rules, new Map()
            .set(UTAM_FRAME_ARG_TYPE, this.buildFrameArgImports)
            .set(UTAM_LOCATOR_ARG_TYPE, this.buildLocatorArgImports)
            .set(UTAM_ROOT_PAGE_OBJECT_ARG_TYPE, (arg) => this.buildPageObjectArgImports(arg, typesNamesTracker))
            .set(UTAM_PAGE_OBJECT_ARG_TYPE, (arg) => this.buildPageObjectArgImports(arg, typesNamesTracker)), "f");
    }
    /**
     * Construct and return import data for non literal frame argument
     * @param arg internal representation of a utam argument
     */
    buildFrameArgImports(arg) {
        if (arg.literal)
            return [];
        return [
            {
                moduleSpecifier: UTAM_CORE_MODULE,
                name: UTAM_FRAME_ELEMENT_CTOR,
                destination: 'typedImports',
                defaultImport: false,
            },
        ];
    }
    /**
     * Construct and return import data for literal css locator argument
     * @param arg internal representation of a utam argument
     */
    buildLocatorArgImports(arg) {
        if (!arg.literal)
            return [];
        return [
            {
                moduleSpecifier: UTAM_CORE_MODULE,
                name: UTAM_LOCATOR_BY,
                destination: 'imports',
                defaultImport: false,
            },
        ];
    }
    /**
     * Construct and return import data for rootPageObject and pageObject argument
     * @param arg internal representation of a utam argument
     */
    buildPageObjectArgImports(arg, typeNamesTracker) {
        if (arg.literal) {
            const moduleSpecifier = arg
                .value;
            const name = buildImportNameFromModulePath(moduleSpecifier, typeNamesTracker);
            return [
                {
                    moduleSpecifier,
                    name,
                    destination: 'imports',
                    defaultImport: true,
                },
            ];
        }
        return [
            {
                moduleSpecifier: UTAM_CORE_MODULE,
                name: UTAM_PAGE_OBJECT_CTOR,
                destination: 'typedImports',
                defaultImport: false,
            },
            {
                moduleSpecifier: UTAM_CORE_MODULE,
                name: arg.type === UTAM_ROOT_PAGE_OBJECT_ARG_TYPE ? UTAM_BASE_ROOT_CLASS_NAME : UTAM_BASE_CLASS_NAME,
                destination: 'typedImports',
                defaultImport: false,
            },
        ];
    }
    /**
     * Map a list of compose statement arguments to imports data.
     * Those imports data are added to the class body import maps in order
     * to generate imports for some identifiers that would be missing otherwise
     *
     * @param args compose statement arguments
     * @returns a list of imports data
     */
    mapArgToImports(args) {
        return args.flatMap((arg) => {
            const { type } = arg;
            if (!__classPrivateFieldGet(this, _ArgImportsBuilder_rules, "f").has(type)) {
                return [];
            }
            const createImportsFromArg = __classPrivateFieldGet(this, _ArgImportsBuilder_rules, "f").get(type);
            const imports = createImportsFromArg(arg);
            return imports;
        });
    }
}
_ArgImportsBuilder_rules = new WeakMap();
/**
 * Adds imports for basic element who might be private but returned by a getter inside a compose method
 *
 * @param lastStatement last statement
 * @param context statements context
 */
function addImportForGetterReturnType(lastStatement, context) {
    const { astConfig, importsDestination } = context;
    const { typeNamesTracker } = astConfig;
    const { element, apply, chain: isChain = false } = lastStatement;
    if (element && !apply && !isChain) {
        const { typedImports } = importsDestination;
        const elementAst = findElementAst(element, astConfig.elementMethodsAst);
        const { type } = elementAst;
        if (type !== UTAM_DOCUMENT_ELEMENT && type !== UTAM_NAVIGATION_ELEMENT && isCustomType(type)) {
            addImport(type, buildImportNameFromModulePath(type, typeNamesTracker), typedImports, true);
        }
        else if (isBasicElement(type)) {
            const elementType = wrapSingleBasicTypeInArray(type);
            addImport(UTAM_CORE_MODULE, getBasicElementTypeCtor(UTAM_ELEMENT_DEFAULT_TYPE), typedImports, false);
            elementType.forEach((utamElementType) => {
                addImport(UTAM_CORE_MODULE, getBasicElementTypeCtor(utamElementType), typedImports, false);
            });
        }
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function isExtensionStatement(statement) {
    return statement.moduleReference !== undefined;
}
function isSelfStatement(statement) {
    return statement.elementName === 'self';
}
function isChainStatement(statement) {
    return statement.isChain && !('elementName' in statement);
}
// depending on the matcher, generate result string
function generateResultStatement(matcher, statementIndex, byId) {
    const resultId = `_result${statementIndex}`;
    if (matcher) {
        // matcher does not have nested or referenced args
        const args = traverseArguments(matcher.args);
        const matcherArgsStr = args.map((arg) => generateArgumentValueCode(arg, byId)).join(', ');
        const matcherExpression = generateMatcherCode(matcher.type, matcherArgsStr);
        const matcherId = `_matcher${statementIndex}`;
        return { matcherCode: `const ${matcherId} = ${resultId}${matcherExpression};`, resultId: matcherId };
    }
    else {
        return { matcherCode: '', resultId: resultId };
    }
}
function generateReturnStatement(isLastStatementAndReturnsValue, resultId) {
    return isLastStatementAndReturnsValue ? `return ${resultId};` : '';
}
function isLastStatementAndReturnsValue(returnType, isLastStatement) {
    const returnsVoid = returnType.returnTypeValue === UTAM_VOID_RETURN_TYPE;
    const returnsStatementValue = isLastStatement && !returnsVoid;
    return returnsStatementValue;
}
function generateChainStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, applyFunctionArgs = [], matcher, returnsList, returnType } = statement;
    const { index, isPreviousStatementList, isLastStatement } = statementContext;
    const calleeName = `_statement${index - 1}`;
    const resultId = `_result${index}`;
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const flatFn = returnsList && isPreviousStatementList ? `.flat()` : ``;
    const invokeExpr = isPreviousStatementList
        ? `(await Promise.all(${calleeName}.map(_it => _it.${applyFunction}(${applyArgs}))))${flatFn};`
        : `await ${calleeName}.${applyFunction}(${applyArgs});`;
    // Invoke
    const invokeStatement = !isLastStatement
        ? `const _statement${index} = ${invokeExpr}`
        : returnsStatementValue || matcher
            ? `const ${resultId} = ${invokeExpr}`
            : `${invokeExpr}`;
    // Match
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    const resultStatement = generateResultStatement(matcher, index, byId);
    // Return
    const returnStatement = generateReturnStatement(returnsStatementValue, resultStatement.resultId);
    return code `
        ${invokeStatement}
        ${resultStatement.matcherCode}
        ${returnStatement}
    `;
}
// generates code for a statement with "self"
function generateSelfStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, matcher, applyFunctionArgs = [], isChain, returnType } = statement;
    const { index, isNextStatementChain, isLastStatement } = statementContext;
    const resultId = `_result${index}`;
    const statementId = `_statement${index}`;
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    // We need to save the result of the getter invocation in a variable if next statement is chained
    const calleeName = isChain ? `_statement${index - 1}` : `this`;
    const invokeStatementSingle = isNextStatementChain && !isLastStatement
        ? `const ${statementId} = await ${calleeName}.${applyFunction}(${applyArgs});`
        : `await ${calleeName}.${applyFunction}(${applyArgs});`;
    // Invoke
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const invokeStatement = returnsStatementValue || matcher ? `const ${resultId} = ${invokeStatementSingle}` : `${invokeStatementSingle}`;
    // Match
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    const resultStatement = generateResultStatement(matcher, index, byId);
    // Return
    const returnStatement = generateReturnStatement(returnsStatementValue, resultStatement.resultId);
    return code `
                ${invokeStatement}
                ${resultStatement.matcherCode}
                ${returnStatement}
            `;
}
// generates code for a statement that invokes an imperative extension
// unlike other statement types it does not have "element" or "matcher"
function generateImperativeExtensionStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, applyFunctionArgs = [], returnType } = statement;
    const { index, isNextStatementChain, isLastStatement } = statementContext;
    const resultId = `_result${index}`;
    const statementId = `_statement${index}`;
    const pageObjectContext = `{ pageObject: this }`;
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    const parameters = applyArgs.length ? [pageObjectContext, applyArgs].join(', ') : pageObjectContext;
    const invokeStatementSingle = `await _${applyFunction}(${parameters})`;
    // Invoke
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const invokeStatement = returnsStatementValue
        ? `const ${resultId} = ${invokeStatementSingle}`
        : isNextStatementChain
            ? `const ${statementId} = ${invokeStatementSingle}`
            : `${invokeStatementSingle}`;
    // Return (matcher not allowed inside applyExternal statement)
    const returnStatement = generateReturnStatement(returnsStatementValue, resultId);
    return code `
                ${invokeStatement}
                ${returnStatement}
            `;
}
// generates code for a regular "element" + "apply" statement
function generateRegularStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, applyFunctionArgs = [], matcher, elementName, isChain, returnsList, elementGetMethod: elementCaller, elementArgs = [], returnType, } = statement;
    const { index, isLastStatement, isPreviousStatementList, visitedElements } = statementContext;
    const { astConfig } = context;
    const { elementMethodsAst } = astConfig;
    let elementNullable = false;
    if (!isChain) {
        const elementAst = findElementAst(elementName, elementMethodsAst);
        elementNullable = elementAst.nullable;
    }
    // Setup args and identifiers
    const elementAlreadyVisited = visitedElements.has(elementName);
    const elmId = elementAlreadyVisited ? visitedElements.get(elementName) : `_statement${index}`;
    // add the element to visited
    visitedElements.set(elementName, elmId);
    // Setup args and identifiers
    const resultId = `_result${index}`;
    const elmArgs = elementArgs.join(', ');
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    // Separate the expression in two for readability (otherwise should be ternary operator)
    const applyExpressionSingle = `await ${elmId}.${applyFunction}(${applyArgs})`;
    const applyExpressionList = `await Promise.all(${elmId}.map((_it) => _it.${applyFunction}(${applyArgs})))`;
    // if apply function is 'size', we return number of found elements
    const applyExpressionLength = `${elmId}.length`;
    const applyExpr = applyFunction === 'size'
        ? applyExpressionLength
        : returnsList || isPreviousStatementList
            ? applyExpressionList
            : applyExpressionSingle;
    // Invoke
    const elementStatement = elementAlreadyVisited ? '' : `const ${elmId} = await this.${elementCaller}(${elmArgs});`;
    const elementNullStatement = elementNullable
        ? `if(${elmId} === null) { return ${returnsList ? '[]' : 'null'}; }`
        : '';
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const applyStatement = returnsStatementValue || matcher ? `const ${resultId} = ${applyExpr};` : `${applyExpr};`;
    // Match
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    const resultStatement = generateResultStatement(matcher, index, byId);
    // Return
    const returnStatement = generateReturnStatement(returnsStatementValue, resultStatement.resultId);
    return code `
            ${elementStatement}
            ${elementNullStatement}
            ${applyStatement}
            ${resultStatement.matcherCode}
            ${returnStatement}
        `;
}
// generate code lines for statements
function generateStatementsCode(context, statements, typeIdentifiers) {
    const visited = new Map();
    return statements.map((statement, index, all) => {
        const isLastStatement = all.length - 1 === index;
        const isFirstStatement = index === 0;
        const previousStatement = isFirstStatement ? null : all[index - 1];
        const nextStatement = isLastStatement ? null : all[index + 1];
        const isNextStatementChain = nextStatement && !isExtensionStatement(nextStatement) ? !!nextStatement?.isChain : false;
        const { returnTypeKind, returnTypeValue } = statement.returnType;
        if (returnTypeKind !== UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT && isNextStatementChain) {
            const { methodName } = context;
            throw new UtamValidationError(descriptions.METHOD.INFERRED_TYPE_NOT_CUSTOM_NEXT_STATEMENT_IS_CHAIN(methodName, returnTypeValue));
        }
        const statementContext = {
            index,
            isPreviousStatementList: !!previousStatement?.returnsList,
            isNextStatementChain,
            isLastStatement,
            visitedElements: visited,
        };
        if (RETURN_SELF_ACTION === statement.applyFunction) {
            return 'return this;';
        }
        if (isExtensionStatement(statement)) {
            return generateImperativeExtensionStatement(context, typeIdentifiers, statement, statementContext);
        }
        if (isChainStatement(statement)) {
            return generateChainStatement(context, typeIdentifiers, statement, statementContext);
        }
        if (isSelfStatement(statement)) {
            return generateSelfStatement(context, typeIdentifiers, statement, statementContext);
        }
        return generateRegularStatement(context, typeIdentifiers, statement, statementContext);
    });
}
/**
 * generate code for a method composed of declared statements
 *
 * @param astConfig context of the current page object with elements and methods information
 * @param methodAst abstract representation of the method declared in JSON
 */
function generateComposeMethodCode(context, methodAst, typeIdentifiers) {
    const { methodName, statements, orderedArgs, description, argsDescriptionMap } = methodAst;
    const statementsCode = generateStatementsCode(context, statements, typeIdentifiers);
    const jsDoc = buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code `
    ${jsDoc}
    async ${methodName}(${orderedArgs.join(', ')}) {
        ${statementsCode.join('\n')}
    }`;
}
// generate predicate statements inside "waitFor" inside compose or beforeLoad methods
function generatePredicateStatement(context, predicate, typeIdentifiers) {
    context.methodName = 'predicate';
    // get all statements for each predicate recurcively
    const preProcessedStatements = transformComposeStatements(context, predicate, []).statements;
    // generate code lines for each statement, those can have other waitFor/predicates inside
    const statementsCodeLines = generateStatementsCode(context, preProcessedStatements, typeIdentifiers).join('\n');
    // combine all statements into one async
    return (predicate &&
        code `
        async () => {
            ${statementsCodeLines}
        }`);
}
function generateElementReferenceCode(context, arg, typeIdentifiers) {
    const { astConfig } = context;
    const { elementMethodsAst } = astConfig;
    const elementName = arg.value;
    const elementAst = findElementAst(elementName, elementMethodsAst);
    let elmGetterArgs = '';
    if (arg.args) {
        // args were already traversed earlier and parameters were added to a method context
        // we just need to collect them and build a string, hence no context passed to traversal
        const nestedArgs = traverseArguments(arg.args, astConfig);
        elmGetterArgs = generateArgumentsCodeFromExplicitArgs(context, nestedArgs, typeIdentifiers);
    }
    else {
        const elementArgs = elementAst.orderedArgs;
        // infer args from getter
        elmGetterArgs = elementArgs.join(', ');
    }
    return `await this.${elementAst.methodName}(${elmGetterArgs})`;
}
function generateArgumentsCodeFromExplicitArgs(context, args, typeIdentifiers) {
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    return args
        .map((arg) => {
        if (arg.literal) {
            if (arg.type === 'function') {
                // if type is "function", need to accumulate code from inside the predicate
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                return generatePredicateStatement(context, arg.predicate, typeIdentifiers);
            }
            if (arg.type === 'elementReference') {
                return generateElementReferenceCode(context, arg, typeIdentifiers);
            }
            // literal selector or element can have nested args and should be processed separately
            const value = arg.value;
            if (arg.type === UTAM_LOCATOR_ARG_TYPE) {
                return buildLiteralSelectorCode(value, byId);
            }
            if (arg.type === UTAM_ROOT_PAGE_OBJECT_ARG_TYPE || arg.type === UTAM_PAGE_OBJECT_ARG_TYPE) {
                const importName = buildImportNameFromModulePath(value, context.astConfig.typeNamesTracker);
                return buildIdentifier(importName);
            }
        }
        // if not a function or object with nested args - get code from primitive args utils
        return generateArgumentValueCode(arg, byId);
    })
        .join(', ');
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getBasicElementTypeCtor(type) {
    return UTAM_ELEMENT_TYPE_TO_CTOR[type];
}
function selectModuleConstructorByType(type, typesTracker) {
    let moduleSpecifier = UTAM_CORE_MODULE;
    let defaultImport = false;
    let external = false;
    let namedImport;
    if (isBasicElement(type)) {
        namedImport = UTAM_ELEMENT_CTOR;
    }
    else if (isContainerElement(type)) {
        namedImport = UTAM_CONTAINER_CTOR;
    }
    else if (isFrameElement(type)) {
        namedImport = UTAM_FRAME_ELEMENT_CTOR;
    }
    else {
        // Custom Types
        defaultImport = true;
        moduleSpecifier = type;
        namedImport = buildImportNameFromModulePath(type, typesTracker);
        external = true;
    }
    return { moduleSpecifier, namedImport, defaultImport, external };
}
class ClassBody {
    constructor(className, rootSelector, options = { format: 'es' }) {
        /**
         * page objects imports
         * key is full module name "my/page/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.imports = new Map();
        /**
         * page objects type declarations imports (d.ts file)
         * key is full module name "my/page/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.typedImports = new Map();
        /**
         * page objects extensions imports: used to import exposed extensions functions
         * key is full module name "my/utility/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.utilityImports = new Map();
        /**
         * shared paged objects and page objects type declarations imports
         * key is full module name "my/page/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.sharedImports = new Map();
        this._elementMethodsAst = [];
        this._composeMethodsAst = [];
        this._interfaceMethodAst = [];
        this._rootMethod = [];
        this._beforeLoadMethod = [];
        this._className = className;
        this._options = options;
        this._rootSelector = rootSelector;
        this._isInterface = !!options.isInterface;
        this._platform = options.platform;
        this._description = buildRootDescription(options.commentsOptions?.jsonPath, options.commentsOptions?.version, options.description);
        this._isRootPageObject = !!options.isRoot;
        // Auto Generate imports for the class
        this._webdriverTypeIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_TYPES_DRIVER, {
            importDestination: this.typedImports,
        });
        this._webelementTypeIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_TYPES_ELEMENT, {
            importDestination: this.typedImports,
        });
        this._locatorTypeIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_TYPES_LOCATOR, {
            importDestination: this.typedImports,
        });
        // Interfaces can be marked as root without a selector
        if (this._isRootPageObject) {
            this._extendsClassNameIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_BASE_ROOT_CLASS_NAME, {
                importDestination: this.sharedImports,
            });
            if (rootSelector) {
                this._byIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_LOCATOR_BY, {
                    importDestination: this.imports,
                });
            }
        }
        else {
            this._extendsClassNameIdentifier = this.addImport(UTAM_CORE_MODULE, UTAM_BASE_CLASS_NAME, {
                importDestination: this.sharedImports,
            });
        }
        this.initializeDocumentElement();
        this.initializeNavigationElement();
        const { _byIdentifier, _locatorTypeIdentifier } = this;
        this._typeIdentifiers = {
            _byIdentifier,
            _locatorTypeIdentifier,
            _elementTypeIdentifier: buildIdentifier(UTAM_ELEMENT_CTOR_BASE),
            _frameElementTypeIdentifier: buildIdentifier(UTAM_FRAME_ELEMENT_CTOR),
            _pageObjectTypeIdentifier: buildIdentifier(UTAM_PAGE_OBJECT_CTOR),
            _rootPageObjectTypeIdentifier: buildIdentifier(UTAM_PAGE_OBJECT_CTOR),
            // container types identifiers will be added later if at least one container found
        };
        this.typeNamesTracker = new Map();
    }
    initializeDocumentElement() {
        this._elementMethodsAst.push({
            elementName: UTAM_DOCUMENT_ELEMENT,
            type: UTAM_DOCUMENT_ELEMENT,
            typeConstructor: UTAM_ELEMENT_CTOR_DOCUMENT,
            methodName: 'getDocument',
            hoistedFunctionIdentifier: '_doc',
            args: [],
            parentArgs: [],
            nullable: false,
            parentNullable: false,
            filterFunctionArgs: [],
            filterReturnsList: false,
            argsTypeMap: {},
            argsDescriptionMap: {},
            orderedArgs: [],
            hasSelector: true,
            selectorReturnsList: false,
            returnsList: false,
            isPublic: false,
            description: [],
        });
    }
    // TODO returns the common properties from a function
    initializeNavigationElement() {
        this._elementMethodsAst.push({
            elementName: UTAM_NAVIGATION_ELEMENT,
            type: UTAM_NAVIGATION_ELEMENT,
            typeConstructor: UTAM_ELEMENT_CTOR_NAVIGATION,
            methodName: 'getNavigation',
            hoistedFunctionIdentifier: '_nav',
            args: [],
            parentArgs: [],
            nullable: false,
            parentNullable: false,
            filterFunctionArgs: [],
            filterReturnsList: false,
            argsTypeMap: {},
            argsDescriptionMap: {},
            orderedArgs: [],
            hasSelector: true,
            selectorReturnsList: false,
            returnsList: false,
            isPublic: false,
            description: [],
        });
    }
    addImport(module, name, options) {
        const { importDestination, defaultImport = false } = options;
        return addImport(module, name, importDestination, defaultImport);
    }
    addElementMethod(config) {
        const { name, hoistedFunctionIdentifier, args = [], argsTypeMap = {}, argsDescriptionMap = {}, nullable, parentNullable, hasSelector, selectorReturnsList, isPublic, parentArgs = [], filterFunctionIdentifier, filterFunctionArgs = [], filterReturnsList, description, } = config;
        let { type = [] } = config;
        const methodName = elementToMethodName(name, isPublic);
        const containerType = isContainerElement(type);
        const { moduleSpecifier, namedImport, defaultImport } = selectModuleConstructorByType(type, this.typeNamesTracker);
        const typeConstructor = containerType
            ? UTAM_CONTAINER_CTOR
            : this.addImport(moduleSpecifier, namedImport, {
                importDestination: isPublic && namedImport !== UTAM_ELEMENT_CTOR ? this.sharedImports : this.imports,
                defaultImport,
            });
        const returnsList = selectorReturnsList && (!filterFunctionIdentifier || filterReturnsList);
        if (containerType && isPublic) {
            const _containerType = this.addImport(moduleSpecifier, namedImport, {
                importDestination: this.typedImports,
                defaultImport: false,
            });
            this._typeIdentifiers._containerType = _containerType;
            // add import for base page object type returned by container method
            const _containerReturnTypeGenericBound = this.addImport(UTAM_CORE_MODULE, UTAM_BASE_CLASS_NAME, {
                importDestination: this.typedImports,
            });
            this._typeIdentifiers._containerReturnTypeGenericBound = _containerReturnTypeGenericBound;
        }
        // Add imports for basic elements as basic elements are now declared as a list of 1..N interfaces to satisfy
        if (isBasicElement(type)) {
            type = wrapSingleBasicTypeInArray(type);
            this._addBasicElementsTypesImports(type, { isPublic });
        }
        // Add import for Custom Element factory function
        if (isCustomType(type)) {
            this.addImport(UTAM_CORE_MODULE, UTAM_ELEMENT_FACTORY_FN, {
                importDestination: this.imports,
            });
        }
        this._elementMethodsAst.push({
            elementName: name,
            type,
            typeConstructor,
            methodName,
            hoistedFunctionIdentifier,
            args,
            parentArgs,
            nullable: nullable ?? false,
            parentNullable: parentNullable ?? false,
            filterFunctionIdentifier,
            filterFunctionArgs,
            filterReturnsList,
            argsTypeMap,
            argsDescriptionMap,
            orderedArgs: [...parentArgs, ...args, ...filterFunctionArgs],
            hasSelector,
            selectorReturnsList,
            returnsList,
            isPublic,
            description: buildMethodDescription(description),
        });
        return methodName;
    }
    /**
     * Add imports for basic elements as basic elements are now declared as a list of 1..N interfaces to satisfy
     * @param type type of the element parsed from the declaration in the JSON file
     * @param isPublic indicates that the function is a public PO API
     */
    _addBasicElementsTypesImports(type, { isPublic, isRootElement = false }) {
        if (isPublic) {
            // add BaseUtamElement to typed imports as all basic element types are intersection of
            // BaseUtamElement and other types mixins (activable, clickable...)
            this.addImport(UTAM_CORE_MODULE, getBasicElementTypeCtor(UTAM_ELEMENT_DEFAULT_TYPE), {
                importDestination: this.typedImports,
                defaultImport: false,
            });
        }
        // For interface, methods aren't implemented so we only want to add the types to the type declaration files
        // with the execption of the root element as it's getter is still part of the interface
        // Otherwise, we only adds the types to the JS page objects and to the type declaration if it's public
        // (private APIs aren't in the type declaration)
        const elementTypesImportDestination = this._isInterface && !isRootElement ? this.typedImports : isPublic ? this.sharedImports : this.imports;
        type.forEach((utamElementType) => {
            this.addImport(UTAM_CORE_MODULE, getBasicElementTypeCtor(utamElementType), {
                importDestination: elementTypesImportDestination,
                defaultImport: false,
            });
        });
    }
    addCustomMethod(method) {
        const { name, description } = method;
        if (this._isInterface) {
            const { args: methodArgs = [], returnType = UTAM_VOID_RETURN_TYPE, returnAll, } = method;
            const explicitReturnType = getExplicitReturnType(returnType, this.typeNamesTracker);
            this.addReturnTypeImportsForAbstractMethod(explicitReturnType, returnType);
            // Add imports for args types
            if (methodArgs.length > 0) {
                const importsBuilder = new ArgImportsBuilder(this.typeNamesTracker);
                const imports = importsBuilder.mapArgToImports(methodArgs);
                for (const i of imports) {
                    const { moduleSpecifier, name, destination, defaultImport } = i;
                    this.addImport(moduleSpecifier, name, {
                        importDestination: this[destination],
                        defaultImport,
                    });
                }
            }
            this._interfaceMethodAst.push({
                methodName: name,
                isPublic: true,
                orderedArgs: getArgumentsNames(methodArgs),
                argsTypeMap: getArgumentsTypeMap(methodArgs),
                argsDescriptionMap: getArgumentsDescriptionMap(methodArgs),
                typeConstructor: explicitReturnType.returnTypeValue,
                returnsList: !!returnAll,
                description: buildMethodDescription(description),
            });
        }
        else {
            const { compose, args: methodArgs = [] } = method;
            const { statements, composeArgs, lastStatementReturnAll, returnType, lastStatementReturn } = this.addComposeStatements(name, compose, methodArgs);
            // import for return types in type definiton
            this.addReturnTypeImportsForComposeMethod(returnType, lastStatementReturn);
            const methodArgsTypeMap = { ...getArgumentsTypeMap(composeArgs), ...getArgumentsTypeMap(methodArgs) };
            const methodArgsDescrMap = {
                ...getArgumentsDescriptionMap(composeArgs),
                ...getArgumentsDescriptionMap(methodArgs),
            };
            const orderedArgs = [...composeArgs.map((c) => c.name)];
            this._composeMethodsAst.push({
                methodName: name,
                isPublic: true,
                orderedArgs,
                statements,
                argsTypeMap: methodArgsTypeMap,
                argsDescriptionMap: methodArgsDescrMap,
                typeConstructor: returnType.returnTypeValue,
                returnsList: lastStatementReturnAll,
                description: buildMethodDescription(description),
            });
        }
        return name;
    }
    getPageObjectOrFrameReturnTypeImport(returnTypeKind) {
        if (returnTypeKind === UTAM_RETURN_CATEGORY_PAGE_OBJECT) {
            return UTAM_BASE_CLASS_NAME;
        }
        else if (returnTypeKind === UTAM_RETURN_CATEGORY_ROOT_PAGE_OBJECT) {
            return UTAM_BASE_ROOT_CLASS_NAME;
        }
        else if (returnTypeKind === UTAM_RETURN_CATEGORY_FRAME_ELEMENT) {
            return UTAM_FRAME_ELEMENT_CTOR;
        }
    }
    addReturnTypeImportsForComposeMethod({ returnTypeKind }, lastStatementReturn) {
        if (returnTypeKind === UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT && lastStatementReturn) {
            addImport(lastStatementReturn, buildImportNameFromModulePath(lastStatementReturn, this.typeNamesTracker), this.typedImports, true);
        }
        else {
            // for "frame", "pageObject", "rootPageObject"
            const typeName = this.getPageObjectOrFrameReturnTypeImport(returnTypeKind);
            if (typeName) {
                addImport(UTAM_CORE_MODULE, typeName, this.typedImports);
            }
        }
    }
    addReturnTypeImportsForAbstractMethod({ returnTypeKind }, returnType) {
        if (returnTypeKind === UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT) {
            const { moduleSpecifier, namedImport, defaultImport } = selectModuleConstructorByType(returnType, this.typeNamesTracker);
            this.addImport(moduleSpecifier, namedImport, {
                importDestination: this.typedImports,
                defaultImport,
            });
        }
        else if (returnTypeKind === UTAM_RETURN_CATEGORY_BASIC_ELEMENT) {
            const type = wrapSingleBasicTypeInArray(returnType);
            this._addBasicElementsTypesImports(type, { isPublic: true });
        }
        else {
            // for "frame", "pageObject", "rootPageObject"
            const typeName = this.getPageObjectOrFrameReturnTypeImport(returnTypeKind);
            if (typeName) {
                addImport(UTAM_CORE_MODULE, typeName, this.typedImports);
            }
        }
    }
    addComposeStatements(methodName, compose, methodArgs) {
        const { _elementMethodsAst, utilityImports, imports, typedImports, _typeIdentifiers, typeNamesTracker } = this;
        const astConfig = { elementMethodsAst: _elementMethodsAst, typeNamesTracker };
        const classBodyContext = {
            methodName,
            astConfig,
            importsDestination: {
                extensions: utilityImports,
                imports,
                typedImports,
            },
            typeIdentifiers: _typeIdentifiers,
        };
        return transformComposeStatements(classBodyContext, compose, methodArgs);
    }
    applyRootOptions({ type, exposeRootElement, beforeLoad }) {
        const name = UTAM_ROOT_ELEMENT;
        let rootType = type ?? [];
        rootType = wrapSingleBasicTypeInArray(rootType);
        const { moduleSpecifier, namedImport, defaultImport } = selectModuleConstructorByType(rootType, this.typeNamesTracker);
        const typeConstructor = this.addImport(moduleSpecifier, namedImport, {
            importDestination: this.imports,
            defaultImport,
        });
        const methodName = elementToMethodName(name, exposeRootElement);
        const rootAst = {
            elementName: name,
            type: rootType,
            typeConstructor,
            methodName,
            isPublic: !!exposeRootElement,
            argsTypeMap: {},
            argsDescriptionMap: {},
            orderedArgs: [],
            returnsList: false,
            selectorReturnsList: false,
            beforeLoad,
            description: [],
        };
        this._rootMethod.push(rootAst);
        const { isPublic } = rootAst;
        this._addBasicElementsTypesImports(rootType, { isPublic, isRootElement: true });
        // Create a default root element AST
        this._elementMethodsAst.push({
            ...rootAst,
            nullable: false,
            parentNullable: false,
            hoistedFunctionIdentifier: 'root',
            args: [],
            parentArgs: [],
            filterFunctionArgs: [],
            hasSelector: false,
            filterReturnsList: false,
            description: [],
        });
        // should be after previous statement so that root element getter would be already added!
        if (beforeLoad) {
            // beforeLoad statements have same syntax as compose except cannot accept non-literal args
            // all differences with compose should be checked during validation phase, method level args are empty
            const { statements } = this.addComposeStatements(BEFORE_LOAD_METHOD_NAME, beforeLoad, []);
            this._beforeLoadMethod.push({
                methodName: BEFORE_LOAD_METHOD_NAME,
                statements: statements,
                orderedArgs: [],
                description: [],
                argsTypeMap: {},
                argsDescriptionMap: {},
            });
        }
        return methodName;
    }
    generateCode() {
        const { _extendsClassNameIdentifier, _className, _rootSelector, _byIdentifier, _typeIdentifiers, _isInterface, _platform, _description, } = this;
        const { _rootMethod, _beforeLoadMethod, _elementMethodsAst, _composeMethodsAst, typeNamesTracker } = this;
        const { utilityImports, imports, typedImports } = this;
        const camelCaseName = kebabcaseToCamelcase(_className);
        const astConfig = { elementMethodsAst: _elementMethodsAst, typeNamesTracker };
        // Generate elements code
        const elementsWithoutRoot = _elementMethodsAst.filter(({ elementName }) => elementName !== UTAM_ROOT_ELEMENT &&
            elementName !== UTAM_DOCUMENT_ELEMENT &&
            elementName !== UTAM_NAVIGATION_ELEMENT);
        const elementClassMethods = elementsWithoutRoot.map((e) => generateElementMethodCode(e));
        // pass the class body context so that's it's accessible to all types of compose statements (method, predicates...)
        const classBodyContext = {
            methodName: '',
            astConfig,
            importsDestination: {
                extensions: utilityImports,
                imports,
                typedImports,
            },
            typeIdentifiers: _typeIdentifiers,
            typeNamesTracker,
        };
        // Generate methods code
        const composeClassMethods = _composeMethodsAst.map((m) => {
            classBodyContext.methodName = m.methodName;
            return generateComposeMethodCode(classBodyContext, m, _typeIdentifiers);
        });
        const interfaceMethods = this._interfaceMethodAst.map((c) => generateInterfaceMethodCode(c));
        // Generate beforeLoad code
        classBodyContext.methodName = BEFORE_LOAD_METHOD_NAME;
        const beforeLoadMethod = _beforeLoadMethod.map((m) => generateComposeMethodCode(classBodyContext, {
            methodName: BEFORE_LOAD_METHOD_NAME,
            statements: m.statements,
            orderedArgs: [],
            description: [],
            argsTypeMap: {},
            argsDescriptionMap: {},
        }, _typeIdentifiers));
        // Generate root code
        const rootClassMethods = _rootMethod.map((root) => generateRootElementMethodCode(root));
        const publicClassMethods = [
            ...beforeLoadMethod,
            ...rootClassMethods,
            ...elementClassMethods,
            ...composeClassMethods,
            ...interfaceMethods,
        ].join('\n\n');
        // Interface
        const isInterfaceStaticProp = _isInterface ? `static isInterface = true;` : '';
        const locator = _byIdentifier && _rootSelector
            ? `locator = ${buildLiteralSelectorCode(_rootSelector, _byIdentifier)}`
            : 'locator';
        // Platform
        const mobileContextStaticProp = _platform ? `static mobileContext = "${_platform}";` : '';
        const jsDocString = textToJsDoc(_description);
        return code `
            ${jsDocString}
            export default class ${camelCaseName} extends ${_extendsClassNameIdentifier} {
                constructor(driver, element, ${locator}) {
                    super(driver, element, locator);
                }

                ${publicClassMethods}
                ${isInterfaceStaticProp}
                ${mobileContextStaticProp}
            }
        `;
    }
    generateTypeDefinition() {
        const { _className, _extendsClassNameIdentifier, _webdriverTypeIdentifier, _webelementTypeIdentifier, _locatorTypeIdentifier, _typeIdentifiers, _description, } = this;
        const kebabClassName = kebabcaseToCamelcase(_className);
        const elementClassMethods = this._elementMethodsAst.filter((p) => p.isPublic);
        const classMethods = [...this._composeMethodsAst, ...this._interfaceMethodAst]
            .map((method) => generateBaseMethodTypeDefinition(method, _typeIdentifiers))
            .join('\n');
        const elementClassDefMethods = elementClassMethods.map((elMethod) => generateElementMethodTypeDefinition(elMethod, _typeIdentifiers));
        const jsDocString = textToJsDoc(_description);
        return code `
            ${jsDocString}
            export default class ${kebabClassName} extends ${_extendsClassNameIdentifier} {
                constructor(driver: ${_webdriverTypeIdentifier}, element?: ${_webelementTypeIdentifier}, locator?: ${_locatorTypeIdentifier});
                ${classMethods}
                ${elementClassDefMethods}
            }
        `;
    }
    render() {
        const { skipCodeGen, skipTypeGen } = this._options;
        return {
            code: skipCodeGen ? undefined : this.generateCode(),
            typeDefinition: skipTypeGen ? undefined : this.generateTypeDefinition(),
        };
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
class Renderer {
    constructor() {
        this._declarations = new BlockDeclarations();
    }
    createClassBody(className = 'UnknownPageObjectName', rootSelector, opts) {
        this._classBody = new ClassBody(className, rootSelector, opts);
    }
    get classBody() {
        if (!this._classBody) {
            throw new Error('Class body must be created before accessing it');
        }
        return this._classBody;
    }
    get declarations() {
        return this._declarations;
    }
    addElementMethod(config) {
        return this.classBody.addElementMethod(config);
    }
    applyRootOptions(opts) {
        return this.classBody.applyRootOptions(opts);
    }
    addCustomMethod(method) {
        return this.classBody.addCustomMethod(method);
    }
    addSelectorFunctionDeclaration(selector, context) {
        return this._declarations.addSelectorFunctionDeclaration(selector, context);
    }
    addFilterFunctionDeclaration(filter, context) {
        return this._declarations.addFilterFunctionDeclaration(filter, context);
    }
    addFilterApplicationFunctionDeclaration(filter, context) {
        return this._declarations.addFilterApplicationFunctionDeclaration(filter, context);
    }
    render(alias) {
        const { _classBody: classBody, declarations } = this;
        if (!classBody) {
            throw new Error('Unexpected error: ClassBody should have been defined');
        }
        // Generate the source code and the imports separately (so we can dedupe them)
        const { code: classBodySource = '', typeDefinition: classBodyTypeDef = '' } = classBody.render();
        const declarationsSource = declarations.render();
        const declarationImports = Array.from(declarations.imports.entries());
        const classBodyImports = Array.from(classBody.imports.entries());
        const classBodyTypedImports = Array.from(classBody.typedImports.entries());
        const classBodySharedImports = Array.from(classBody.sharedImports.entries());
        const classBodyUtilityImports = Array.from(classBody.utilityImports.entries());
        // We collect the import from both body and declaration so we can dedupe them
        const pageObjectImports = generateImports([...declarationImports, ...classBodyImports, ...classBodySharedImports, ...classBodyUtilityImports], alias);
        const pageObjectTypedImports = generateImports([...classBodyTypedImports, ...classBodySharedImports], alias);
        const pageObjectCode = code `
            ${pageObjectImports}

            ${declarationsSource}

            ${classBodySource}
        `;
        const pageObjectTypeDefinition = code `
            ${pageObjectTypedImports}

            ${classBodyTypeDef}
        `;
        return {
            code: pageObjectCode,
            typeDefinition: pageObjectTypeDefinition,
        };
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function generateElement(renderer, element, options = {}) {
    const { selector = {}, name, elements, shadow, type, filter, nullable } = element;
    const { insideShadow, parentName, parentArgs = [], parentArgTypes = {}, parentArgDescriptions = {}, parentNullable, parentSelectorReturnsList, parentFilterApplicationName, } = options;
    const isContainer = isContainerElement(type);
    let filterFunctionIdentifier;
    let appliedFunctionApplicationIdentifier;
    let filterFunctionArgs = [];
    let filterArgsTypes;
    let filterArgsDescriptions;
    // if filter is not set, default is true as it's used as condition to return list
    const filterReturnsList = filter ? !filter.findFirst : true;
    // if container element does not have selector, assign default
    const elementSelector = isContainer && !element.selector ? { css: ':scope > *:first-child' } : selector;
    // Creates a stateless function that will be hoisted at the module level to apply filtering criteria
    if (filter) {
        filterFunctionArgs = getArgumentsNames(filter.args).concat(getArgumentsNames(filter.matcher.args));
        filterArgsTypes = getArgumentsTypeMap(filter.args);
        filterArgsDescriptions = getArgumentsDescriptionMap(filter.args);
        Object.assign(filterArgsTypes, getArgumentsTypeMap(filter.matcher.args));
        // Creates a stateless function that will be hoisted at the module level to apply element filter
        filterFunctionIdentifier = renderer.addFilterFunctionDeclaration(filter, {
            name,
            parentName,
            parentArgs,
        });
        const hasNestedElements = elements || shadow ? true : false;
        if (hasNestedElements) {
            appliedFunctionApplicationIdentifier = renderer.addFilterApplicationFunctionDeclaration(filter, {
                name,
                filterFunctionIdentifier,
            });
        }
    }
    // Creates a stateless function that will be hoisted at the module level to get a particular element
    const hoistedFunctionIdentifier = renderer.addSelectorFunctionDeclaration(elementSelector, {
        isContainer,
        insideShadow,
        parentName,
        parentArgs,
        parentNullable,
        parentSelectorReturnsList,
        nullable,
        name,
        parentFilterApplicationName,
    });
    const argsTypes = getSelectorArgTypes(elementSelector);
    const argsDescriptions = getSelectorArgDescriptions(elementSelector);
    const args = getArgumentsNames(elementSelector.args);
    // Merge all types
    const mergedArgTypes = { ...parentArgTypes, ...argsTypes, ...filterArgsTypes };
    const mergedArgDescriptions = { ...parentArgDescriptions, ...argsDescriptions, ...filterArgsDescriptions };
    const orderedArgs = [...parentArgs, ...args, ...filterFunctionArgs];
    renderer.addElementMethod({
        name,
        type,
        args,
        nullable,
        parentArgs,
        parentNullable: parentNullable,
        hoistedFunctionIdentifier,
        filterFunctionIdentifier,
        appliedFunctionApplicationIdentifier,
        filterFunctionArgs,
        filterReturnsList,
        argsTypeMap: mergedArgTypes,
        argsDescriptionMap: mergedArgDescriptions,
        hasSelector: !!elementSelector.css,
        selectorReturnsList: !!elementSelector.returnAll,
        isPublic: !!element.public,
        description: element.description,
    });
    // Recursively continue resolving elements
    if (elements) {
        for (const element of elements) {
            generateElement(renderer, element, {
                parentName: hoistedFunctionIdentifier,
                parentArgs: orderedArgs,
                parentNullable: parentNullable ?? nullable,
                parentArgTypes: mergedArgTypes,
                parentSelectorReturnsList: selector.returnAll,
                parentFilterApplicationName: appliedFunctionApplicationIdentifier,
            });
        }
    }
    if (shadow) {
        for (const shadowElement of shadow.elements) {
            generateElement(renderer, shadowElement, {
                insideShadow: true,
                parentName: hoistedFunctionIdentifier,
                parentArgs: orderedArgs,
                parentNullable: parentNullable ?? nullable,
                parentArgTypes: mergedArgTypes,
                parentSelectorReturnsList: selector.returnAll,
                parentFilterApplicationName: appliedFunctionApplicationIdentifier,
            });
        }
    }
}
function generateMethods(renderer, methods) {
    for (const method of methods) {
        renderer.addCustomMethod(method);
    }
}
function generatePageObject(pageObject, metadata, compilerConfig, alias) {
    const renderer = new Renderer();
    const { elements = [], shadow, methods, type, beforeLoad, exposeRootElement } = pageObject;
    const { interface: isInterface, platform, root: isRoot, description } = pageObject;
    const { skipCodeGen, skipTypeGen, format } = compilerConfig;
    const { name, commentsOptions } = metadata;
    renderer.createClassBody(name, pageObject.selector, {
        skipCodeGen,
        skipTypeGen,
        format,
        isInterface,
        isRoot,
        platform,
        description,
        commentsOptions,
    });
    // TODO: pass interface
    // We declare method for root element
    renderer.applyRootOptions({ type, exposeRootElement, beforeLoad });
    for (const element of elements) {
        generateElement(renderer, element);
    }
    if (shadow) {
        for (const shadowElement of shadow.elements) {
            generateElement(renderer, shadowElement, { insideShadow: true });
        }
    }
    if (methods) {
        generateMethods(renderer, methods);
    }
    return renderer.render(alias);
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * context of an element including its name, type, cardinality and expected parameter types
 */
class ElementContext {
    constructor(name, nodeType, elementType, isList) {
        // expected args types of selector and filter, used in validation for elementReference
        this.expectedArgs = new Array();
        this.name = name;
        this.nodeType = nodeType;
        this.elementType = elementType;
        this.isList = isList;
    }
    /**
     * expected types of args for an element including selector and filter
     * @returns array of type names for args
     */
    getExpectedTypes() {
        return this.expectedArgs;
    }
    /**
     * set expected args types for an element
     * @param types set expected args types for an element
     */
    addExpectedArgTypes(types) {
        this.expectedArgs.push(...types);
    }
}
/**
 * traversal context created per each validated Page Object
 * accumulates information about elements and provides validations across different nodes
 */
class Context {
    constructor() {
        this.visitedElements = new Map();
        this.visitedMethods = new Set();
        /** Indicates if the page object was declared as an interface (interface: true in the root scope) */
        this.isInterface = false;
    }
    addUniqueElement(elementContext) {
        const name = elementContext.name;
        if (this.visitedElements.has(name)) {
            return false;
        }
        this.visitedElements.set(name, elementContext);
        return true;
    }
    addUniqueMethod(name) {
        if (this.visitedMethods.has(name)) {
            return false;
        }
        this.visitedMethods.add(name);
        return true;
    }
    getElementContext(name) {
        return this.visitedElements.get(name);
    }
}
/**
 * Represents a decorated statement with context information used to validate returnTypes
 */
class StatementContext {
    constructor(statementNode, isLast, nextIsChain) {
        this.statementNode = statementNode;
        this.isLast = isLast;
        this.isNextStatementChain = nextIsChain;
    }
}
/**
 * Traversal context for statements (in compose method or in beforeLoad). This class decorates the statement nodes
 * object with properties that add some context around the statement. This is used for the validation of the returnType
 * in statements that can require information about siblings statements (n +/- 1).
 */
class StatementsContext {
    constructor(statementNodes) {
        this.statementsContext = statementNodes.map((statementNodeObject, index, statementsNodeObjects) => {
            const isLast = index === statementsNodeObjects.length - 1;
            const nextStatement = !isLast ? statementsNodeObjects[index + 1] : null;
            const nextIsChain = this.isNextStatementChain(nextStatement);
            return new StatementContext(statementNodeObject, isLast, nextIsChain);
        });
    }
    isNextStatementChain(nextStatement) {
        if (!nextStatement)
            return false;
        const chainNode = findNodeAtLocation(nextStatement, ['chain']);
        if (!chainNode)
            return false;
        const chainNodeValue = getNodeValue(chainNode);
        return chainNodeValue;
    }
}

/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const SINGLE_DOLLARSIGN = '$';
const SINGLE_BACKTICK = '`';
/**
 * Returns a set of the supported operators values
 */
class MobileSelectorOperator {
    constructor(value) {
        this.value = value;
    }
    static get operators() {
        return new Set(Object.values(this).map(({ value }) => value));
    }
}
/**
 * Represents all supported classchain predicates operators
 * @link https://appium.io/docs/en/writing-running-appium/ios/ios-predicate/
 */
class ClasschainOperator extends MobileSelectorOperator {
}
ClasschainOperator.EQUALS = new ClasschainOperator('==');
ClasschainOperator.BEGINSWITH = new ClasschainOperator('BEGINSWITH');
ClasschainOperator.ENDSWITH = new ClasschainOperator('ENDSWITH');
ClasschainOperator.CONTAINS = new ClasschainOperator('CONTAINS');
ClasschainOperator.OR = new ClasschainOperator('OR');
ClasschainOperator.AND = new ClasschainOperator('AND');
/**
 * Represents all support uiautomator uiselectors
 * @link - https://developer.android.com/reference/androidx/test/uiautomator/UiSelector
 */
class UiautomatorSelectors extends MobileSelectorOperator {
}
UiautomatorSelectors.CHECKABLE = new UiautomatorSelectors('checkable');
UiautomatorSelectors.CHECKED = new UiautomatorSelectors('checked');
UiautomatorSelectors.CLASSNAME = new UiautomatorSelectors('className');
UiautomatorSelectors.DESCRIPTION = new UiautomatorSelectors('description');
UiautomatorSelectors.DESCRIPTIONCONTAINS = new UiautomatorSelectors('descriptionContains');
UiautomatorSelectors.DESCRIPTIONSTARTSWITH = new UiautomatorSelectors('descriptionStartsWith');
UiautomatorSelectors.ENABLED = new UiautomatorSelectors('enabled');
UiautomatorSelectors.SELECTED = new UiautomatorSelectors('selected');
UiautomatorSelectors.RESOURCEID = new UiautomatorSelectors('resourceId');
UiautomatorSelectors.RESOURCEIDMATCHES = new UiautomatorSelectors('resourceIdMatches');
/**
 * Route a selector value to it's appropriate validation routine depending on it's type
 * @param selectorType type of the selector
 * @param selectorValue value of the selector coming from the JSON
 */
function validateSelectorValue(selectorType, selectorValue) {
    switch (selectorType) {
        case 'classchain':
            validClassChain(selectorValue);
            break;
        case 'uiautomator':
            validateUiAutomator(selectorValue);
            break;
    }
}
/**
 * Routine for validating the supplied classchain string
 * @param classchain locator string
 */
function validClassChain(classchain) {
    classchain.split('/').forEach(validateSubClassChainSelector);
}
/**
 * Validate claschain string for square brackets,single quotes and other classchain operators
 * @param classchain locator string
 */
function validateSubClassChainSelector(classchain) {
    if (classchain.includes('[')) {
        const classchainSubStr = classchain.substring(classchain.indexOf('[') + 1, classchain.indexOf(']'));
        if (!/\d/.test(classchainSubStr)) {
            validateQuote(classchainSubStr);
            validateOperator(classchainSubStr);
        }
    }
}
/**
 * Validate classchain string for quotes and dollar signs
 * @param classchain locator string
 * @throws {UtamValidationError} Classchain validation error when invalid quotes are used in the selector.
 */
function validateQuote(classchain) {
    if (!classchain.startsWith(SINGLE_BACKTICK.toString()) && !classchain.startsWith(SINGLE_DOLLARSIGN.toString())) {
        throw new UtamValidationError(descriptions.SELECTOR.CLASS_CHAIN_INVALID_QUOTES());
    }
}
/**
 * Validate classchain string for supported predicate operators
 * @param classchain locator string
 * @throws {UtamValidationError} Classchain validation error when invalid operators
 */
function validateOperator(classchain) {
    const classchainQuery = classchain.split(' ');
    const classChainOperators = ClasschainOperator.operators;
    if (classchainQuery.length < 3) {
        throw new UtamValidationError(descriptions.SELECTOR.CLASS_CHAIN_INVALID_OPERATORS(classchain, classChainOperators));
    }
    if (!classchainQuery
        .filter((subString) => subString === ClasschainOperator.EQUALS.value || /^[A-Z]+$/g.test(subString))
        .every((operator) => classChainOperators.has(operator))) {
        throw new UtamValidationError(descriptions.SELECTOR.CLASS_CHAIN_INVALID_OPERATORS(classchain, classChainOperators));
    }
}
/**
 * Validate uiautomator string against supported uiautomator methods
 * @param uiautomator locator string
 * @throws {UtamValidationError} Uiautomator validation error when supplied string is either in incorrect
 * format or is not part of supported methods list.
 */
function validateUiAutomator(uiautomator) {
    const { operators: uiAutomatorMethods } = UiautomatorSelectors;
    validateUiAutomatorMethods(validateUISelector(validateScrollable(uiautomator, uiAutomatorMethods)));
}
function validateScrollable(locator, uiAutomatorMethods) {
    if (!locator.startsWith('new UiScrollable')) {
        return { locator, uiAutomatorMethods };
    }
    const SCROLLABLE = 'scrollable';
    const innerLocator = locator.split('.')[1].split('(')[0];
    if (innerLocator !== SCROLLABLE) {
        if (!uiAutomatorMethods.has(innerLocator)) {
            throw new UtamValidationError(descriptions.SELECTOR.UIAUTOMATOR_UNSUPPORTED_METHOD(locator, uiAutomatorMethods));
        }
    }
    const innerMethod = locator.substring(locator.indexOf('))') + 3);
    return { locator: innerMethod.substring(innerMethod.indexOf('(') + 1), uiAutomatorMethods };
}
function validateUISelector({ locator, uiAutomatorMethods }) {
    if (!locator.startsWith('new UiSelector')) {
        return { locator, uiAutomatorMethods };
    }
    return { locator: locator.substring(locator.indexOf('.') + 1), uiAutomatorMethods };
}
/**
 * Validate uiautomator string against supported uiautomator methods
 * @param locator locator string
 * @param uiAutomatorMethods saleforce supported uiAutomator methods
 * @throws {UtamValidationError} Uiautomator validation error when supplied string is either in incorrect
 */
function validateUiAutomatorMethods({ locator, uiAutomatorMethods }) {
    const resourceLocator = locator.split('(')[0];
    if (!uiAutomatorMethods.has(resourceLocator)) {
        throw new UtamValidationError(descriptions.SELECTOR.UIAUTOMATOR_UNSUPPORTED_METHOD(locator, uiAutomatorMethods));
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const UTAM_CUSTOM_PARSE_ERROR_CODE = 17;
/**
 * Wrap errors into UtamParseError to add context around parsing errors
 * @param err either an error coming from the jsonc-parser or an error throwed by the visitor function
 * @returns an error with context representing a UTAM parse error
 */
function createUtamParseError(err) {
    if (isParseError(err)) {
        const { error, offset, length } = err;
        const message = printParseErrorCode(error);
        return {
            error,
            message,
            isInvalidPageObjectError: false,
            offset,
            length,
        };
    }
    else {
        const { message, position } = err;
        const { offset, length = 0 } = position;
        return {
            error: UTAM_CUSTOM_PARSE_ERROR_CODE,
            message,
            isInvalidPageObjectError: true,
            offset,
            length,
        };
    }
}
/**
 * User defined type guard to narrow errors down to ParseError
 * @param err any error that needs some narrowing
 * @returns type predicate indicating if the error is a ParseError
 */
function isParseError(err) {
    return 'error' in err && typeof err.error === 'number';
}
/**
 * User defined type guard to narrow errors down to UtamParseError
 * @param err any error that needs some narrowing
 * @returns type predicate indicating if the error is a UtamParseError
 */
function isUtamParseError(err) {
    return 'isInvalidPageObjectError' in err;
}
/**
 * Facade function that augment the parseTree function from jsonc-parser to invalidate JSON
 * objects with duplicated keys in the same scope.
 *
 * @param jsonSourceText json page object to validate
 * @param errors errors objects returned by the visitor or via the jsonc-parser parseTree function
 * @param options configuration object to configure the behavior of the facade function
 * @returns the root node object if the text has been successfully parsed
 */
function parseTree(jsonSourceText, errors, options = { disallowDuplicatedKeys: true, disallowInlineComments: true }) {
    try {
        const visitor = new PageObjectsVisitor(options);
        visit(jsonSourceText, visitor);
    }
    catch (err) {
        errors.push(createUtamParseError(err));
    }
    return parseTree$1(jsonSourceText, errors);
}
/**
 * Visitor object used to detect duplicated key tokens in the same context
 */
class PageObjectsVisitor {
    /**
     * Creates a new Visitor object and binds methods implemented from JSONVisitor to the current object
     * @param options parser configuration object
     */
    constructor(options) {
        this.scopes = [];
        this.visitedKeys = new Set();
        this.structure = ['root'];
        this.newNestedContext = false;
        this.parserOptions = options;
        this.onObjectBegin = this.onObjectBegin.bind(this);
        this.onObjectEnd = this.onObjectEnd.bind(this);
        this.onObjectProperty = this.onObjectProperty.bind(this);
        this.onComment = this.onComment.bind(this);
    }
    /**
     * Callback function triggered when parsing comments tokens
     * @param offset offset of the key token
     * @param length key length
     */
    onComment(offset, length) {
        if (this.parserOptions.disallowInlineComments) {
            const message = `Inline comments are not allowed, use the 'description' property instead`;
            throw new UtamJsonValidationError({
                message,
                position: { offset, length },
            });
        }
    }
    /** Callback function triggered when parsing a '{' token */
    onObjectBegin() {
        this.scopes.push(new Set());
        this.visitedKeys = this.scopes[this.scopes.length - 1];
        // We set newNestedContext to true after visited the first property
        if (this.structure.length > 1)
            this.newNestedContext = false;
    }
    /** Callback function triggered when parsing a '}' token */
    onObjectEnd() {
        this.scopes.pop();
        this.visitedKeys = this.scopes[this.scopes.length - 1];
        this.structure.pop();
    }
    /**
     * Callback function triggered when parsing a new key
     * @param property visited key token
     * @param offset offset of the key token
     * @param length key length
     */
    onObjectProperty(property, offset, length) {
        if (this.parserOptions.disallowDuplicatedKeys && this.visitedKeys.has(property)) {
            // We don't keep the last item in the array to stop at the parent
            // of the duplicated key
            const structurePath = this.structure.slice(0, -1).join(' > ');
            const message = `Duplicate "${property}" keys in ${structurePath}`;
            throw new UtamJsonValidationError({
                message,
                position: { offset, length },
            });
        }
        else {
            this.visitedKeys.add(property);
            this.updateStructure(property);
        }
    }
    /**
     * Utility function that updates the structure depending on the context the visitor is in.
     * This function store the context hierarchy in the structure field
     *
     * @property current key being visited
     */
    updateStructure(property) {
        if (!this.newNestedContext) {
            this.structure.push(property);
            this.newNestedContext = true;
        }
        else {
            this.structure[this.structure.length - 1] = property;
        }
    }
}

/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * check that property is a non empty string
 * @param node JSON node
 * @param parserContext context of the validation, ex. method or element name
 * @param propertyName name of the property
 */
function assertNotEmptyString(node, parserContext, propertyName) {
    if (node.type !== 'string') {
        throw new UtamCompilerValidationError(node, 10, [parserContext, propertyName, node.type]);
    }
    if (node.value.length === 0) {
        throw new UtamCompilerValidationError(node, 10, [parserContext, propertyName, 'empty string']);
    }
    return node.value;
}
/**
 * Check that parent node contains given property and it's a non-empty string
 * @param parentNode JSON node
 * @param parserContext validation context
 * @param objectName name of the property
 * @returns non empty value
 */
function assertHasNotEmptyString(parentNode, parserContext, objectName) {
    const node = findNodeAtLocation(parentNode, [objectName]);
    if (!node) {
        throw new UtamCompilerValidationError(parentNode, 10, [parserContext, objectName, 'undefined']);
    }
    return assertNotEmptyString(node, parserContext, objectName);
}
/**
 * Check that each array member is a non empty string
 * @param node JSON node
 * @param structure context of the validation, ex. method or element name
 * @param key name of the array property
 */
function assertArrayMemberIsString(node, structure, key) {
    const parserContext = `${structure}, "${key}" array`;
    if (node.children) {
        for (const memberNode of node.children) {
            if (memberNode.type !== 'string') {
                throw new UtamCompilerValidationError(node, 11, [parserContext, memberNode.type]);
            }
            if (!memberNode.value || memberNode.value.length === 0) {
                throw new UtamCompilerValidationError(node, 11, [parserContext, 'empty string']);
            }
        }
    }
}
/**
 * Check that node is an array
 * @param node JSON node
 * @param structure validation context
 * @param objectName property name
 */
function assertOptionalNotEmptyArray(node, structure, objectName) {
    if (node.type !== 'array' || !node.children || node.children.length === 0) {
        throw new UtamCompilerValidationError(node, 12, [structure, objectName]);
    }
}
/**
 * Check that parent node contains given property and it's non empty array
 * @param parentNode JSON node
 * @param structure validation context
 * @param objectName property name
 */
function assertNotEmptyArray(parentNode, structure, objectName) {
    const node = findNodeAtLocation(parentNode, [objectName]);
    if (!node) {
        throw new UtamCompilerValidationError(parentNode, 12, [structure, objectName]);
    }
    assertOptionalNotEmptyArray(node, structure, objectName);
    return node;
}
/**
 * check that array member is an object, does not need key name because it's not a map
 * @param node - JSON node to check
 * @param structure - string to identify structure
 * @param objectName - name of the object in array
 */
function assertIsArrayMemberObject(node, structure, objectName) {
    if (node.type !== 'object') {
        throw new UtamCompilerValidationError(node, 13, [structure, objectName]);
    }
}
/**
 * Check that parent node contains given property and it's non null object
 * @param parentNode JSON node
 * @param structure validation context
 * @param objectName property name
 */
function assertNotNullObject(parentNode, structure, objectName) {
    const node = findNodeAtLocation(parentNode, [objectName]);
    const propertyName = `property "${objectName}"`;
    if (!node || node.type !== 'object') {
        throw new UtamCompilerValidationError(parentNode, 13, [structure, propertyName]);
    }
    return node;
}
/**
 * Check that node is an object
 * @param node JSON node
 * @param structure validation context
 * @param objectName property name
 */
function assertIsObject(node, structure, objectName) {
    if (node.type !== 'object') {
        throw new UtamCompilerValidationError(node, 13, [structure, objectName]);
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const ROOT_PROPERTIES = [
    'root',
    'interface',
    'implements',
    'profile',
    'platform',
    'selector',
    'elements',
    'shadow',
    'methods',
    'type',
    'exposeRootElement',
    'beforeLoad',
    'description',
    'metadata',
];
const INTERFACE_PROPERTIES = [
    'root',
    'interface',
    'methods',
    'type',
    'exposeRootElement',
    'description',
    'metadata',
];
const SELECTOR_PROPERTIES = [
    'accessid',
    'classchain',
    'css',
    'uiautomator',
    'args',
    'returnAll',
];
const ROOT_SELECTOR_PROPERTIES = ['accessid', 'classchain', 'css', 'uiautomator'];
const ELEMENT_PROPERTIES = [
    'elements',
    'filter',
    'name',
    'public',
    'selector',
    'nullable',
    'shadow',
    'type',
    'description',
];
const FRAME_ELEMENT_SELECTOR_PROPERTIES = [
    'accessid',
    'classchain',
    'css',
    'uiautomator',
    'args',
];
const FRAME_ELEMENT_PROPERTIES = [
    'name',
    'public',
    'selector',
    'type',
    'description',
];
const FILTER_PROPERTIES = ['matcher', 'apply', 'args', 'findFirst'];
const FILTER_MATCHER_PROPERTIES = ['args', 'type'];
const METHOD_ACTION_PROPERTIES = [
    'element',
    'apply',
    'args',
    'matcher',
    'applyExternal',
    'chain',
    'returnAll',
    'returnType',
];
const UTILITY_STATEMENT_PROPERTIES = [
    'applyExternal',
    'element',
    'returnAll',
    'returnType',
];
const RETURN_SELF_STATEMENT_PROPERTIES = ['apply'];
const METHOD_PROPERTIES = ['name', 'compose', 'args', 'description'];
const INTERFACE_METHOD_PROPERTIES = [
    'name',
    'args',
    'returnType',
    'returnAll',
    'description',
];
const ARGS_PROPERTIES = ['type', 'name', 'value', 'predicate', 'args', 'description'];
const UTAM_CONTAINER_ELEMENT_TYPE = 'container';
const UTAM_FRAME_ELEMENT_TYPE = 'frame';
const UTAM_BASIC_ELEMENT_TYPE = new Set([
    'actionable',
    'clickable',
    'editable',
    'draggable',
    'touchable',
]);
const UTAM_NAVIGATION_ACTIONS = new Set(['back', 'forward']);
const SUPPORTED_MATCHERS = ['isTrue', 'isFalse', 'notNull', 'stringContains', 'stringEquals'];
const SUPPORTED_MOBILE_CONTEXT_TYPE = new Set(['web', 'native']);
const ROOT_ELEMENT_NAME = 'root';
const DOCUMENT_OBJECT_NAME = 'document';
const ROOT_DESCRIPTION_PROPERTIES = ['text', 'author', 'deprecated'];
const METHOD_DESCRIPTION_PROPERTIES = ['text', 'return', 'deprecated', 'throws'];
/**
 * Validation routine used to ensure that a property that takes a finite set of string
 * has a value in that set
 *
 * @param structure enclosing structure name
 * @param parentNode parsed parent node from the JSON document
 * @param propertyName name of the property being validated
 * @param supportedValues finite set of valid values for the property
 */
function assertValueInSet(structure, parentNode, propertyName, supportedValues) {
    const node = findNodeAtLocation(parentNode, [propertyName]);
    if (node) {
        const { type, offset, value } = node;
        if (type !== 'string') {
            throw new UtamSchemaValidationError(descriptions.JSON.INVALID_TYPE_FOR_VALUE(propertyName, structure, 'string', type, {
                offset,
            }));
        }
        else if (!supportedValues.has(value)) {
            throw new UtamSchemaValidationError(descriptions.ROOT.PLATFORM_INVALID_VALUE(value, supportedValues, {
                offset,
            }));
        }
    }
}
function assertBooleanProperty(structure, parentNode, propertyName, defaultValue) {
    const node = findNodeAtLocation(parentNode, [propertyName]);
    if (!node) {
        return defaultValue;
    }
    if (node && node.type !== 'boolean') {
        throw new UtamSchemaValidationError(descriptions.JSON.INVALID_TYPE_FOR_VALUE(propertyName, structure, 'boolean', node.type, {
            offset: node.offset,
        }));
    }
    return node.value;
}
// return property indicating element's type, used later in validations
function assertValidElementType(type) {
    if (isCustomTypePredicate(type)) {
        if (!VALID_CUSTOM_TYPE.test(type)) {
            throw new UtamSchemaValidationError(descriptions.ELEMENT.INVALID_CUSTOM_TYPE(type));
        }
        return 'custom';
    }
    else if (UTAM_CONTAINER_ELEMENT_TYPE === type) {
        return 'container';
    }
    else if (UTAM_FRAME_ELEMENT_TYPE === type) {
        return 'frame';
    }
    else if (UTAM_BASIC_ELEMENT_TYPE.has(type)) {
        return 'basic';
    }
    else {
        throw new UtamSchemaValidationError(descriptions.ELEMENT.INVALID_ELEMENT_TYPE(type, UTAM_BASIC_ELEMENT_TYPE));
    }
}
// return property indicating element's type, used later in validations
// TODO update the error message if needed
function assertValidBasicElementTypes(basicElementType, name) {
    if (!Array.isArray(basicElementType)) {
        if (!UTAM_BASIC_ELEMENT_TYPE.has(basicElementType)) {
            throw new UtamSchemaValidationError(descriptions.ELEMENT.INVALID_BASIC_ELEMENT_TYPE(basicElementType, UTAM_BASIC_ELEMENT_TYPE));
        }
    }
    else {
        const visitedElementTypes = new Set();
        for (const type of basicElementType) {
            if (!UTAM_BASIC_ELEMENT_TYPE.has(type)) {
                throw new UtamSchemaValidationError(descriptions.ELEMENT.INVALID_BASIC_ELEMENT_TYPE(type, UTAM_BASIC_ELEMENT_TYPE));
            }
            if (visitedElementTypes.has(type)) {
                throw new UtamSchemaValidationError(descriptions.ELEMENT.DUPLICATE_BASIC_TYPE(type, name));
            }
            visitedElementTypes.add(type);
        }
    }
    return 'basic';
}
function assertElementIsNestable(structureContext, elementContext) {
    const { structure, position } = structureContext;
    if (elementContext.isList) {
        throw new UtamSchemaValidationError(descriptions.ELEMENT.LIST_CANNOT_HAVE_NESTED_ELEMENTS(structure, position));
    }
    if (elementContext.nodeType !== 'basic') {
        throw new UtamSchemaValidationError(descriptions.ELEMENT.ONLY_BASIC_TYPE_CAN_HAVE_NESTED_ELEMENTS(structure, position));
    }
}
function assertValidKeys(node, structure, properties) {
    if (node.children) {
        for (const propertyNode of node.children) {
            if (propertyNode.type === 'property' && propertyNode.children) {
                const [keyNode] = propertyNode.children;
                const { type, value, offset, length } = keyNode;
                if (type === 'string' && !properties.includes(value)) {
                    throw new UtamSchemaValidationError(descriptions.JSON.INVALID_PROPERTY_KEY(value, structure, properties, { offset, length }));
                }
            }
        }
    }
}
function validateLiteralValue(structureContext, valueNode, typeNode, expectedType, methodContext, elementContext) {
    const position = { offset: valueNode.offset };
    const { structure, context } = structureContext;
    const valueType = valueNode.type;
    const parserContext = `${structure}, argument "selector"`;
    if (valueType === 'object') {
        if (expectedType) {
            if (expectedType !== 'locator') {
                // unknown object type in "value"
                throw new UtamSchemaValidationError(descriptions.JSON.INVALID_TYPE_FOR_VALUE('value', structure, expectedType, 'object', position));
            }
            if (!typeNode) {
                throw new UtamSchemaValidationError(descriptions.ARGS.MISSING_REQUIRED_TYPE_KEY_LITERAL_ARG(structure, expectedType, position));
            }
        }
        // at the moment selector is the only supported object type node for "value"
        assertIsObject(valueNode, structure, 'property "selector"');
        validateSelector({ context, methodContext, elementContext, parserContext }, valueNode);
        return 'locator';
    }
    if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') {
        throw new UtamSchemaValidationError(descriptions.JSON.INVALID_TYPE_FOR_VALUE('value', structure, 'string | boolean | number', valueType, position));
    }
    if (expectedType) {
        if (['elementReference', 'pageObject', 'rootPageObject'].includes(expectedType)) {
            if (!typeNode) {
                throw new UtamSchemaValidationError(descriptions.ARGS.MISSING_REQUIRED_TYPE_KEY_LITERAL_ARG(structure, expectedType, position));
            }
        }
        if (expectedType === 'elementReference' && valueType === 'string') {
            return 'elementReference';
        }
        if (expectedType !== valueType) {
            throw new UtamSchemaValidationError(generation.ARGS.INCORRECT_TYPE(structure, getNodeValue(valueNode), expectedType, valueType, position));
        }
    }
    return valueType;
}
function validateElementReference(argNode, argContext, elementName) {
    const { structure, supports, context, methodContext } = argContext;
    const position = { offset: argNode.offset };
    if (isValueNotAllowed(supports)) {
        throw new UtamSchemaValidationError(descriptions.ARGS.VALUE_NOT_SUPPORTED(structure, position));
    }
    const elementContext = context.getElementContext(elementName);
    if (!elementContext) {
        throw new UtamValidationError(descriptions.METHOD.NONEXISTENT_ELEMENT_REFERENCE(structure, elementName, position));
    }
    const nestedArgs = findNodeAtLocation(argNode, ['args']);
    const expectedTypes = nestedArgs
        ? elementContext.getExpectedTypes().map((type) => {
            return {
                required: true,
                type,
            };
        })
        : [];
    validateArguments(nestedArgs, {
        structure: `element reference '${elementName}' in ${structure}`,
        supports: 'onlyValues',
        methodContext,
        context,
        expectedTypes,
    });
}
function validatePredicateArgument(predicateNode, validationContext) {
    const { structure, context, methodContext } = validationContext;
    const statementStructure = `${structure} predicate`;
    if (!methodContext) {
        throw new Error('Compiler error: predicate needs method context');
    }
    if (predicateNode.children) {
        const { statementsContext } = new StatementsContext(predicateNode.children);
        for (const statementContext of statementsContext) {
            const { statementNode } = statementContext;
            assertIsArrayMemberObject(statementNode, structure, 'predicate');
            validateComposeObject(context, statementContext, statementStructure, methodContext);
        }
    }
}
function getArgumentTypeAsString(structure, typeNode, nameValue, methodContext) {
    if (!typeNode) {
        return undefined;
    }
    assertNotEmptyString(typeNode, structure, 'type');
    const typeValue = getNodeValue(typeNode);
    if (typeValue === 'argumentReference') {
        if (!nameValue) {
            throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('name', structure));
        }
        if (!methodContext) {
            throw new UtamValidationError(descriptions.ARGS.NONEXISTENT_ARGUMENT_REFERENCE(structure, nameValue));
        }
        const referencedType = getReferencedArgument(nameValue, methodContext.methodArgsMap);
        if (!referencedType) {
            throw new UtamValidationError(descriptions.ARGS.NONEXISTENT_ARGUMENT_REFERENCE(structure, nameValue));
        }
        return referencedType;
    }
    return typeValue;
}
function validateArguments(argsNode, validationContext) {
    const types = [];
    const { expectedTypes, structure, supports, context, methodContext } = validationContext;
    const requiredExpectedTypes = expectedTypes ? expectedTypes.filter(({ required }) => required) : [];
    const expectedArgs = requiredExpectedTypes.length;
    if (argsNode) {
        const position = { offset: argsNode.offset };
        if (expectedTypes && expectedTypes.length == 0) {
            throw new UtamSchemaValidationError(descriptions.JSON.REDUNDANT_PROPERTY_KEY_FOR_STRUCTURE('args', structure, position));
        }
        assertOptionalNotEmptyArray(argsNode, structure, 'args');
        if (argsNode.children) {
            // validate that the action don't declares more args than it takes (required + optional)
            if (expectedTypes && expectedTypes.length < argsNode.children.length) {
                throw new UtamSchemaValidationError(generation.ARGS.INCORRECT_COUNT(structure, expectedTypes.length, argsNode.children.length));
            }
            // Validate that the action declares all required args
            if (requiredExpectedTypes.length > argsNode.children.length) {
                throw new UtamSchemaValidationError(generation.ARGS.INCORRECT_COUNT(structure, expectedArgs, argsNode.children.length));
            }
            const parserContext = `${structure} argument`;
            for (let i = 0; i < argsNode.children.length; i++) {
                const argNode = argsNode.children[i];
                const expectedType = expectedTypes ? expectedTypes[i].type : undefined;
                assertIsArrayMemberObject(argNode, structure, `argument`);
                assertValidKeys(argNode, structure, ARGS_PROPERTIES);
                const valueNode = findNodeAtLocation(argNode, ['value']);
                const typeNode = findNodeAtLocation(argNode, ['type']);
                const nameNode = findNodeAtLocation(argNode, ['name']);
                if (nameNode) {
                    assertNotEmptyString(nameNode, structure, 'name');
                }
                const nameValue = nameNode ? getNodeValue(nameNode) : undefined;
                const typeValue = getArgumentTypeAsString(structure, typeNode, nameValue, methodContext);
                const nestedArgsNode = findNodeAtLocation(argNode, ['args']);
                const predicateNode = findNodeAtLocation(argNode, ['predicate']);
                const descriptionNode = findNodeAtLocation(argNode, ['description']);
                if (typeValue === 'function') {
                    const predicateNode = assertNotEmptyArray(argNode, validationContext.structure, 'predicate');
                    validatePredicateArgument(predicateNode, validationContext);
                    if (valueNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.REDUNDANT_KEYS('value'));
                    }
                    if (nestedArgsNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.UNSUPPORTED_NESTED_ARGS(structure, position));
                    }
                    if (isValueNotAllowed(supports)) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.VALUE_NOT_SUPPORTED(structure, position));
                    }
                    if (descriptionNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.DESCRIPTION_NOT_SUPPORTED(position));
                    }
                    types.push('function');
                }
                else if (valueNode) {
                    if (isValueNotAllowed(supports)) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.VALUE_NOT_SUPPORTED(structure, position));
                    }
                    if (nameNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.REDUNDANT_KEYS('name'));
                    }
                    if (predicateNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.REDUNDANT_KEYS('predicate'));
                    }
                    if (descriptionNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.DESCRIPTION_NOT_SUPPORTED(position));
                    }
                    if (typeValue === 'elementReference') {
                        assertNotEmptyString(valueNode, structure, 'value');
                        validateElementReference(argNode, validationContext, getNodeValue(valueNode));
                    }
                    else if (nestedArgsNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.UNSUPPORTED_NESTED_ARGS(structure, position));
                    }
                    types.push(validateLiteralValue({ context, structure }, valueNode, typeNode, expectedType, methodContext));
                }
                else {
                    if (isOnlyValueAllowed(supports)) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.ONLY_VALUE_SUPPORTED(structure, position));
                    }
                    if (!typeValue) {
                        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('type', structure));
                    }
                    if (!nameValue) {
                        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('name', structure));
                    }
                    if (nestedArgsNode) {
                        throw new UtamSchemaValidationError(descriptions.ARGS.UNSUPPORTED_NESTED_ARGS(structure, position));
                    }
                    if (expectedType && !isSameArgumentType(expectedType, typeValue)) {
                        throw new UtamSchemaValidationError(generation.ARGS.INCORRECT_TYPE(structure, nameValue, expectedType, typeValue));
                    }
                    if (descriptionNode) {
                        assertNotEmptyString(descriptionNode, parserContext, 'description');
                    }
                    types.push(typeValue);
                }
            }
        }
    }
    else if (expectedArgs > 0) {
        throw new UtamSchemaValidationError(generation.ARGS.INCORRECT_COUNT(structure, expectedArgs, 0));
    }
    return types;
}
/**
 * validate selector type
 *
 * @param structure string passed usually as "selector"
 * @param selectorNode JSON node
 * @returns selector type and node
 */
function validateSelectorStrategy(structure, selectorNode) {
    const declaredSelectorStrategies = new Map();
    const supportedSelectorStrategies = ['accessid', 'classchain', 'css', 'uiautomator'];
    const position = { offset: selectorNode.offset };
    for (const selectorStrategy of supportedSelectorStrategies) {
        const selectorStrategyNode = findNodeAtLocation(selectorNode, [selectorStrategy]);
        if (selectorStrategyNode) {
            declaredSelectorStrategies.set(selectorStrategy, selectorStrategyNode);
        }
    }
    if (declaredSelectorStrategies.size === 0) {
        throw new UtamSchemaValidationError(descriptions.SELECTOR.VALUE_CANT_BE_EMPTY(structure, supportedSelectorStrategies, position));
    }
    else if (declaredSelectorStrategies.size > 1) {
        // Duplicated selector strategies the offset starts at the first declared key
        const { offset } = [...declaredSelectorStrategies.values()][0];
        const position = { offset };
        throw new UtamSchemaValidationError(descriptions.SELECTOR.DUPLICATE_SELECTOR_STRATEGIES([...declaredSelectorStrategies.keys()], supportedSelectorStrategies, position));
    }
    else {
        const [selectorStrategy, selectorStrategyNode] = [...declaredSelectorStrategies.entries()][0];
        assertNotEmptyString(selectorStrategyNode, structure, selectorStrategy);
        return { selectorType: selectorStrategy, selectorValue: selectorStrategyNode };
    }
}
function validateSelector(selectorContext, selectorNode) {
    const { context, elementContext, methodContext } = selectorContext;
    const isFrameElement = elementContext?.nodeType === 'frame';
    const isRootElement = elementContext?.name === ROOT_ELEMENT_NAME;
    const VALID_SELECTOR_PROPERTIES = isRootElement
        ? ROOT_SELECTOR_PROPERTIES
        : isFrameElement
            ? FRAME_ELEMENT_SELECTOR_PROPERTIES
            : SELECTOR_PROPERTIES;
    const structure = selectorContext.parserContext;
    assertValidKeys(selectorNode, structure, VALID_SELECTOR_PROPERTIES);
    const { selectorType, selectorValue } = validateSelectorStrategy(structure, selectorNode);
    const selectorString = getNodeValue(selectorValue);
    validateSelectorValue(selectorType, selectorString);
    const selectorStringArgs = getSelectorArgTypesFromString(selectorString);
    const expectedTypes = selectorStringArgs.map((argType) => {
        return { required: true, type: argType };
    });
    //remember selector args for an element
    if (elementContext) {
        elementContext.addExpectedArgTypes(selectorStringArgs);
    }
    const argsNode = findNodeAtLocation(selectorNode, ['args']);
    // values are not allowed - does not make sense to have hardcoded selector with '%s'/'%d' and values
    validateArguments(argsNode, {
        context,
        structure: `${selectorContext.parserContext} arguments`,
        supports: 'onlyNameType',
        methodContext,
        expectedTypes,
    });
    if (!isFrameElement) {
        assertBooleanProperty(structure, selectorNode, 'returnAll', false);
    }
}
function validateProfile(profileNode, tracker) {
    if (profileNode.children && profileNode.children.length === 1) {
        const nameNode = profileNode.children[0];
        if (nameNode.type === 'property' && nameNode.children && nameNode.children.length === 2) {
            const name = nameNode.children[0].value;
            if (tracker.has(name)) {
                throw new UtamCompilerValidationError(profileNode, 801, [name]);
            }
            tracker.add(name);
            const valuesNode = nameNode.children[1];
            if (valuesNode.type === 'array') {
                assertOptionalNotEmptyArray(valuesNode, 'root', `profile "${name}"`);
                if (valuesNode.children) {
                    const valuesTracker = new Set();
                    for (const valueNode of valuesNode.children) {
                        const valueStr = assertNotEmptyString(valueNode, `profile "${name}"`, 'value');
                        if (valuesTracker.has(valueStr)) {
                            throw new UtamCompilerValidationError(profileNode, 802, [name, valueStr]);
                        }
                        valuesTracker.add(valueStr);
                    }
                }
            }
            else if (valuesNode.type !== 'string') {
                throw new UtamCompilerValidationError(profileNode, 806, [name]);
            }
        }
        else {
            throw new UtamCompilerValidationError(profileNode, 800);
        }
    }
    else {
        throw new UtamCompilerValidationError(profileNode, 800);
    }
}
function validateReturnType(methodName, structureContext, statementContext) {
    const { structure, position } = structureContext;
    const { statementNode: composeObjectNode, isNextStatementChain } = statementContext;
    const returnTypeNode = findNodeAtLocation(composeObjectNode, ['returnType']);
    const returnAllNode = findNodeAtLocation(composeObjectNode, ['returnAll']);
    if (returnTypeNode) {
        assertNotEmptyString(returnTypeNode, structure, 'returnType');
        const returnTypeNodeValue = getNodeValue(returnTypeNode);
        if (!isValidReturnType(returnTypeNodeValue)) {
            throw new UtamSchemaValidationError(descriptions.METHOD.UNSUPPORTED_RETURN_TYPE_VALUE(structure, returnTypeNodeValue, position));
        }
        if (isNextStatementChain && !isCustomTypePredicate(returnTypeNodeValue)) {
            throw new UtamSchemaValidationError(descriptions.METHOD.INVALID_RETURN_TYPE_NEXT_STATEMENT_IS_CHAIN(structure, position));
        }
        if (returnAllNode) {
            assertBooleanProperty(structure, composeObjectNode, 'returnAll', false);
        }
    }
    else if (returnAllNode) {
        throw new UtamCompilerValidationError(returnAllNode, 603, [methodName]);
    }
}
function validateAppliedAction(structureContext, elementContext, apply) {
    const action = buildActionByName(apply, elementContext.elementType);
    const { structure, position } = structureContext;
    if (!action) {
        throw new UtamValidationError(descriptions.ACTION.UNKNOWN_APPLICABLE_METHOD(structure, apply, elementContext.elementType, position));
    }
    if (!action.external && !isActionApplicableForTypes(action, elementContext.elementType)) {
        throw new UtamValidationError(descriptions.ACTION.INVALID_APPLICABLE_TYPE(structure, action.applyFunction, action.applicableTo, position));
    }
    if (!isCorrectElementCardinality(action, elementContext.isList)) {
        throw new UtamValidationError(descriptions.ACTION.APPLICABLE_ONLY_TO_LIST(structure, action.applyFunction, position));
    }
    return action;
}
/**
 * custom element filter has matcher object, args and apply
 * @param structure context of validation
 * @param filterNode node
 */
function validateElementFilter(structureContext, elementContext, filterNode) {
    const position = { offset: filterNode.offset };
    const { structure, context } = structureContext;
    const applyNode = findNodeAtLocation(filterNode, ['apply']);
    if (!applyNode) {
        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('apply', structure, position));
    }
    const action = validateAppliedAction({ structure, position, context }, elementContext, getNodeValue(applyNode));
    const matcherNode = assertNotNullObject(filterNode, structure, 'matcher');
    assertValidKeys(matcherNode, structure, FILTER_MATCHER_PROPERTIES);
    const matcherTypeNode = findNodeAtLocation(matcherNode, ['type']);
    if (!matcherTypeNode) {
        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('matcher.type', structure, position));
    }
    const matcherType = getMatcherType(matcherTypeNode.value);
    if (!matcherType) {
        throw new UtamValidationError(descriptions.ELEMENT.INVALID_FILTER_MATCHER(structure, matcherTypeNode.value, SUPPORTED_MATCHERS, position));
    }
    const isBasicElement = elementContext.nodeType === 'basic';
    if (isBasicElement) {
        const compatibleMatchers = getCompatibleMatchers(action);
        if (!compatibleMatchers.includes(matcherType)) {
            throw new UtamValidationError(descriptions.ELEMENT.UNSUPPORTED_FILTER_MATCHER(structure, action.applyFunction, matcherType, compatibleMatchers, position));
        }
    }
    const filterArgsExpectedTypes = isBasicElement ? getActionExpectedArgs(action) : undefined;
    const filterArgsNode = findNodeAtLocation(filterNode, ['args']);
    const filterArgsTypes = validateArguments(filterArgsNode, {
        context,
        structure,
        supports: 'any',
        expectedTypes: filterArgsExpectedTypes,
    });
    // remember filter args in element context
    if (elementContext) {
        elementContext.addExpectedArgTypes(filterArgsTypes);
    }
    const matcherExpectedArgs = getMatcherExpectedArgs(matcherType);
    const matcherArgsExpectedTypes = matcherExpectedArgs
        ? matcherExpectedArgs.map((matcherArg) => ({ type: matcherArg, required: true }))
        : [];
    const matcherArgsNode = findNodeAtLocation(matcherNode, ['args']);
    const matcherArgsTypes = validateArguments(matcherArgsNode, {
        context,
        structure,
        supports: 'any',
        expectedTypes: matcherArgsExpectedTypes,
    });
    // remember filter args in element context
    if (elementContext) {
        elementContext.addExpectedArgTypes(matcherArgsTypes);
    }
}
function validateElementRecursive(parentName, context, elementNode) {
    const position = { offset: elementNode.offset };
    assertIsObject(elementNode, `element "${parentName}"`, 'member of "elements" array');
    const nameNode = findNodeAtLocation(elementNode, ['name']);
    if (!nameNode) {
        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('name', 'element', position));
    }
    const elementName = assertNotEmptyString(nameNode, `element "${nameNode.value}"`, 'name');
    const parserContext = `element "${elementName}"`;
    assertValidKeys(elementNode, parserContext, ELEMENT_PROPERTIES);
    const descriptionNode = findNodeAtLocation(elementNode, ['description']);
    if (descriptionNode) {
        validateMethodDescription(parserContext, descriptionNode);
    }
    assertBooleanProperty(parserContext, elementNode, 'public', false);
    const typeNode = findNodeAtLocation(elementNode, ['type']);
    let elementType = 'basic';
    let typeNodeValue = ['basic'];
    if (typeNode) {
        if (typeNode.type === 'array') {
            typeNodeValue = getNodeValue(typeNode);
            elementType = assertValidBasicElementTypes(typeNodeValue, elementName);
            if (typeNodeValue.length === 0) {
                typeNodeValue = ['basic'];
            }
        }
        else {
            typeNodeValue = assertNotEmptyString(typeNode, parserContext, 'type');
            elementType = assertValidElementType(typeNodeValue);
        }
    }
    const elementContext = new ElementContext(elementName, elementType, typeNodeValue, false);
    const selectorParserContext = `${parserContext}, "selector" property`;
    if (elementType === 'container') {
        for (const key of ['filter', 'nullable']) {
            if (findNodeAtLocation(elementNode, [key])) {
                throw new UtamSchemaValidationError(descriptions.JSON.REDUNDANT_PROPERTY_KEY_FOR_STRUCTURE(key, 'container element', position));
            }
        }
    }
    else if (elementType === 'frame') {
        assertValidKeys(elementNode, parserContext, FRAME_ELEMENT_PROPERTIES);
        const selectorNode = assertNotNullObject(elementNode, parserContext, 'selector');
        validateSelector({ context, elementContext, parserContext: selectorParserContext }, selectorNode);
    }
    else {
        // only for non-container we should check selector and filter
        const selectorNode = assertNotNullObject(elementNode, parserContext, 'selector');
        validateSelector({ context, elementContext, parserContext: selectorParserContext }, selectorNode);
        elementContext.isList = assertBooleanProperty(parserContext, selectorNode, 'returnAll', false);
        assertBooleanProperty(parserContext, elementNode, 'nullable', false);
        const filterNode = findNodeAtLocation(elementNode, ['filter']);
        if (filterNode) {
            const filterStructure = `${parserContext} filter`;
            assertIsObject(filterNode, parserContext, 'property "filter"');
            assertValidKeys(filterNode, filterStructure, FILTER_PROPERTIES);
            if (!elementContext.isList) {
                throw new UtamSchemaValidationError(descriptions.ELEMENT.INVALID_FILTER_WITHOUT_SELECTOR_LIST(elementName, position));
            }
            validateElementFilter({ context, structure: filterStructure }, elementContext, filterNode);
            // if filter does not set "findFirst" to true, it's still a list
            elementContext.isList = !assertBooleanProperty(filterStructure, filterNode, 'findFirst', false);
        }
    }
    if (!context.addUniqueElement(elementContext)) {
        throw new UtamValidationError(descriptions.JSON.DUPLICATE_NODE_DECLARED(elementName, 'element', position));
    }
    const elementsNode = findNodeAtLocation(elementNode, ['elements']);
    const structureContext = { structure: elementName, position: { offset: elementNode.offset }, context };
    if (elementsNode) {
        assertElementIsNestable(structureContext, elementContext);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        validateElementsRecursive(elementName, context, elementsNode);
    }
    const shadowNode = findNodeAtLocation(elementNode, ['shadow']);
    if (shadowNode) {
        assertElementIsNestable(structureContext, elementContext);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        validateShadowRecursive(elementName, context, shadowNode);
    }
}
function validateElementsRecursive(parentElement, context, elementsNode) {
    assertOptionalNotEmptyArray(elementsNode, `element "${parentElement}"`, 'elements');
    if (elementsNode.children) {
        for (const elementObjectNode of elementsNode.children) {
            validateElementRecursive(parentElement, context, elementObjectNode);
        }
    }
}
function validateShadowRecursive(parentElement, context, shadowNode) {
    assertIsObject(shadowNode, `element "${parentElement}"`, 'property "shadow"');
    assertValidKeys(shadowNode, `element "${parentElement}" shadow`, ['elements']);
    const elementsNode = findNodeAtLocation(shadowNode, ['elements']);
    if (elementsNode) {
        validateElementsRecursive(parentElement, context, elementsNode);
    }
}
function validateUtilityComposeStatement(structureContext, applyExternalNode, methodContext) {
    assertIsObject(applyExternalNode, structureContext.structure, 'property "applyExternal"');
    assertValidKeys(applyExternalNode, structureContext.structure, ['type', 'invoke', 'args']);
    const structure = `${structureContext.structure} in applyExternal`;
    const { position, context } = structureContext;
    const typeNode = findNodeAtLocation(applyExternalNode, ['type']);
    if (!typeNode) {
        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('type', structure, position));
    }
    const parserContext = `${structureContext.structure}, property "applyExternal"`;
    assertNotEmptyString(typeNode, parserContext, 'type');
    const invokeNode = findNodeAtLocation(applyExternalNode, ['invoke']);
    if (!invokeNode) {
        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('invoke', structure, position));
    }
    assertNotEmptyString(invokeNode, parserContext, 'invoke');
    const argsNode = findNodeAtLocation(applyExternalNode, ['args']);
    validateArguments(argsNode, { structure, supports: 'any', methodContext, context });
}
function validateReturnSelfStatement(structureContext, statementContext) {
    const { structure, position } = structureContext;
    const { statementNode: composeObjectNode, isLast } = statementContext;
    const returnSelfStruncture = `${structure} "returnSelf"`;
    // all properties except "apply" are redundant
    assertValidKeys(composeObjectNode, returnSelfStruncture, RETURN_SELF_STATEMENT_PROPERTIES);
    // "returnSelf" can only be last statement
    if (!isLast) {
        throw new UtamSchemaValidationError(descriptions.ACTION.INVALID_RETURN_SELF_NOT_LAST_STATEMENT(returnSelfStruncture, position));
    }
    // statement does not have Element Context, hence return undefined
    return;
}
function validateApplyComposeStatement(structureContext, composeObjectNode, elementName, applyNode, methodContext) {
    const { structure, position, context } = structureContext;
    const applyValue = getNodeValue(applyNode);
    if (elementName === 'self') {
        const argsNode = findNodeAtLocation(composeObjectNode, ['args']);
        validateArguments(argsNode, { structure, supports: 'any', methodContext, context });
        return;
    }
    // TODO remove this and add proper validations once we implement arguments validation on document element
    const FRAME_ACTIONS = ['enterFrame', 'enterFrameAndLoad', 'exitFrame', 'exitToParentFrame'];
    if (elementName === 'document' && FRAME_ACTIONS.includes(applyValue)) {
        return;
    }
    if (elementName === 'navigation' && UTAM_NAVIGATION_ACTIONS.has(applyValue)) {
        return;
    }
    const elementContext = context.getElementContext(elementName);
    if (!elementContext) {
        throw new UtamValidationError(descriptions.METHOD.NONEXISTENT_ELEMENT_REFERENCE(structure, elementName, position));
    }
    const isBasicElement = elementContext.nodeType === 'basic';
    const action = validateAppliedAction(structureContext, elementContext, applyValue);
    const expectedArgsTypes = isBasicElement ? getActionExpectedArgs(action) : undefined;
    const argsNode = findNodeAtLocation(composeObjectNode, ['args']);
    validateArguments(argsNode, {
        structure,
        supports: 'any',
        methodContext,
        expectedTypes: expectedArgsTypes,
        context,
    });
    return elementContext;
}
// compose statement with only "element"
function validateGetterComposeStatement(structureContext, composeObjectNode, 
// element inside compose stmnt - findNodeAtLocation(composeObjectNode, ['element']);
elementNode, methodContext) {
    const { structure, position, context } = structureContext;
    const elementName = assertNotEmptyString(elementNode, structure, 'element');
    const chainNode = findNodeAtLocation(composeObjectNode, ['chain']);
    const isChain = chainNode ? getNodeValue(chainNode) : false;
    const elementContext = context.getElementContext(elementName);
    if (!elementContext && !isChain) {
        throw new UtamValidationError(descriptions.METHOD.NONEXISTENT_ELEMENT_REFERENCE(structure, elementName, position));
    }
    const argsNode = findNodeAtLocation(composeObjectNode, ['args']);
    validateArguments(argsNode, { structure, supports: 'any', methodContext, context });
    return elementContext;
}
function validateComposeObject(context, statementContext, structure, methodContext) {
    const { statementNode: composeObjectNode } = statementContext;
    const position = { offset: composeObjectNode.offset };
    const structureContext = { structure, position, context };
    assertValidKeys(composeObjectNode, structure, METHOD_ACTION_PROPERTIES);
    const applyExternalNode = findNodeAtLocation(composeObjectNode, ['applyExternal']);
    const applyNode = findNodeAtLocation(composeObjectNode, ['apply']);
    const elementNode = findNodeAtLocation(composeObjectNode, ['element']);
    let elementName = 'self';
    if (elementNode) {
        elementName = assertNotEmptyString(elementNode, structure, 'element');
    }
    validateReturnType(methodContext.methodName, structureContext, statementContext);
    // statement can be one of:
    // "apply" (to self or to element)
    if (applyNode) {
        const applyValue = assertNotEmptyString(applyNode, structure, 'apply');
        if (`returnSelf` === applyValue) {
            validateReturnSelfStatement(structureContext, statementContext);
        }
        else {
            validateApplyComposeStatement(structureContext, composeObjectNode, elementName, applyNode, methodContext);
        }
    }
    else if (applyExternalNode) {
        // or "applyExternal" (imperative extension)
        assertValidKeys(composeObjectNode, structure, UTILITY_STATEMENT_PROPERTIES);
        validateUtilityComposeStatement(structureContext, applyExternalNode, methodContext);
    }
    else if (elementNode) {
        // or "element" (call element getter)
        validateGetterComposeStatement(structureContext, composeObjectNode, elementNode, methodContext);
    }
    else {
        throw new UtamSchemaValidationError(descriptions.JSON.REQUIRED_EXCLUSIVE_KEYS_ON_STRUCTURE(['applyExternal', 'apply', 'element'], structure, position));
    }
    if ('beforeLoad' === methodContext.methodType &&
        elementName &&
        elementName !== 'root' &&
        elementName !== 'document' &&
        elementName !== 'self') {
        throw new UtamValidationError(descriptions.ROOT.BEFORE_LOAD_UNSUPPORTED_ELEMENT(position));
    }
}
/**
 * Routine function that validates interfaces methods' returnType.
 * A valid returnType for an interface method is the sum of the returnType from element getters and compose methods.
 * The set of valid values for interface method's returnType is the following:
 *
 * - Primitive: 'string' | 'number' | 'boolean'
 * - Custom Element Types: utam-lightning/pageObjects/input
 * - Page Object or Root Page Object
 * - Frame
 *
 * @param returnTypeValue returnType value declared in the page object
 * @returns true if the value is valid, false otherwise
 */
function isValidReturnType(returnTypeValue) {
    if (isCustomTypePredicate(returnTypeValue)) {
        // custom type
        return VALID_CUSTOM_TYPE.test(returnTypeValue);
    }
    return [
        UTAM_STRING_RETURN_TYPE,
        UTAM_BOOLEAN_RETURN_TYPE,
        UTAM_NUMBER_RETURN_TYPE,
        UTAM_FRAME_RETURN_TYPE,
        UTAM_PAGE_OBJECT_RETURN_TYPE,
        UTAM_ROOT_PAGE_OBJECT_RETURN_TYPE,
    ].includes(returnTypeValue);
}
/**
 * Routine function that validates interfaces' methods.
 * An interface is a page object with a root property set to true. It's methods describe the signatures
 * of the interface API that are implemented by concrete classes.
 *
 * @param context page object traversal context
 * @param methodNode current method being validated
 */
function validateInterfaceMethod(context, methodNode) {
    const position = { offset: methodNode.offset };
    assertIsArrayMemberObject(methodNode, 'methods', 'method');
    assertValidKeys(methodNode, 'interface method', INTERFACE_METHOD_PROPERTIES);
    const methodName = assertHasNotEmptyString(methodNode, 'interface method', 'name');
    const structure = `method "${methodName}"`;
    if (!context.addUniqueMethod(methodName)) {
        throw new UtamValidationError(descriptions.JSON.DUPLICATE_NODE_DECLARED(methodName, 'method', position));
    }
    const descriptionNode = findNodeAtLocation(methodNode, ['description']);
    if (descriptionNode) {
        validateMethodDescription(`method "${methodName}"`, descriptionNode);
    }
    const argsNode = findNodeAtLocation(methodNode, ['args']);
    // check declared parameters, literals not allowed in interface method
    validateArguments(argsNode, { structure, context, supports: 'onlyNameType' });
    const returnTypeNode = findNodeAtLocation(methodNode, ['returnType']);
    const returnAllNode = findNodeAtLocation(methodNode, ['returnAll']);
    if (returnTypeNode) {
        let isValidType, returnTypeNodeValue;
        if (returnTypeNode.type === 'array') {
            assertOptionalNotEmptyArray(returnTypeNode, structure, 'returnType');
            returnTypeNodeValue = getNodeValue(returnTypeNode);
            isValidType = returnTypeNodeValue.every((basicType) => UTAM_BASIC_ELEMENT_TYPE.has(basicType));
        }
        else {
            returnTypeNodeValue = assertNotEmptyString(returnTypeNode, structure, 'returnType');
            isValidType =
                [...UTAM_BASIC_ELEMENT_TYPE].find((type) => type === returnTypeNodeValue) ||
                    isValidReturnType(returnTypeNodeValue);
        }
        if (!isValidType) {
            throw new UtamSchemaValidationError(descriptions.METHOD.UNSUPPORTED_RETURN_TYPE_VALUE(structure, returnTypeNodeValue.toString(), position));
        }
        if (returnAllNode) {
            assertBooleanProperty(structure, methodNode, 'returnAll', false);
        }
    }
    else if (returnAllNode) {
        throw new UtamCompilerValidationError(returnAllNode, 402, [methodName]);
    }
}
function validateMethodDescription(structure, descriptionNode) {
    const parserContext = `${structure} description`;
    if (descriptionNode.type === 'string') {
        return;
    }
    assertIsObject(descriptionNode, structure, 'property "description"');
    assertValidKeys(descriptionNode, parserContext, METHOD_DESCRIPTION_PROPERTIES);
    const textArrayNode = assertNotEmptyArray(descriptionNode, parserContext, 'text');
    assertArrayMemberIsString(textArrayNode, parserContext, 'text');
    const deprecatedNode = findNodeAtLocation(descriptionNode, ['deprecated']);
    if (deprecatedNode) {
        assertNotEmptyString(deprecatedNode, parserContext, 'deprecated');
    }
    const returnNode = findNodeAtLocation(descriptionNode, ['return']);
    if (returnNode) {
        assertNotEmptyString(returnNode, parserContext, 'return');
    }
    const throwsNode = findNodeAtLocation(descriptionNode, ['throws']);
    if (throwsNode) {
        assertNotEmptyString(throwsNode, parserContext, 'throws');
    }
}
function validateComposeMethod(context, methodNode) {
    const position = { offset: methodNode.offset };
    assertIsArrayMemberObject(methodNode, 'methods', 'method');
    assertValidKeys(methodNode, 'method', METHOD_PROPERTIES);
    const methodName = assertHasNotEmptyString(methodNode, 'method', 'name');
    const structure = `method "${methodName}"`;
    if (!context.addUniqueMethod(methodName)) {
        throw new UtamValidationError(descriptions.JSON.DUPLICATE_NODE_DECLARED(methodName, 'method', position));
    }
    const argsNode = findNodeAtLocation(methodNode, ['args']);
    // check declared parameters, literals not allowed in method declaration
    validateArguments(argsNode, { structure, context, supports: 'onlyNameType' });
    const composeNode = assertNotEmptyArray(methodNode, structure, 'compose');
    const descriptionNode = findNodeAtLocation(methodNode, ['description']);
    if (descriptionNode) {
        validateMethodDescription(`method "${methodName}"`, descriptionNode);
    }
    const methodContext = {
        methodArgsMap: buildArgsNodeMap(argsNode),
        methodType: 'compose',
        methodName,
    };
    if (composeNode.children) {
        const { statementsContext } = new StatementsContext(composeNode.children);
        for (const statementContext of statementsContext) {
            const { statementNode } = statementContext;
            assertIsArrayMemberObject(statementNode, `method "${methodName}"`, 'statement');
            validateComposeObject(context, statementContext, `method "${methodName}" statement`, methodContext);
        }
    }
}
function validateMethods(context, methodsNode) {
    assertOptionalNotEmptyArray(methodsNode, 'root', 'methods');
    assertValidKeys(methodsNode, 'root', ['methods']);
    // Interface & Compose methods don't have the same structural shape
    const validateMethodFunction = context.isInterface ? validateInterfaceMethod : validateComposeMethod;
    if (methodsNode.children) {
        for (const methodObjectNode of methodsNode.children) {
            validateMethodFunction(context, methodObjectNode);
        }
    }
}
function validateBeforeLoad(context, beforeLoadNode) {
    const structure = 'beforeLoad';
    assertOptionalNotEmptyArray(beforeLoadNode, 'root', 'beforeLoad');
    const methodContext = {
        methodArgsMap: buildArgsNodeMap(undefined),
        methodType: 'beforeLoad',
        methodName: 'beforeLoad',
    };
    if (beforeLoadNode.children) {
        const { statementsContext } = new StatementsContext(beforeLoadNode.children);
        for (const statementContext of statementsContext) {
            const { statementNode } = statementContext;
            assertIsArrayMemberObject(statementNode, `method "beforeLoad"`, 'statement');
            validateComposeObject(context, statementContext, structure, methodContext);
        }
    }
}
function validateRootDescription(descriptionNode) {
    const structure = 'root';
    const parserContext = `root "description"`;
    if (descriptionNode.type === 'string') {
        assertNotEmptyString(descriptionNode, parserContext, 'description');
        return;
    }
    assertIsObject(descriptionNode, structure, 'property "description"');
    assertValidKeys(descriptionNode, parserContext, ROOT_DESCRIPTION_PROPERTIES);
    const textArrayNode = assertNotEmptyArray(descriptionNode, parserContext, 'text');
    assertArrayMemberIsString(textArrayNode, parserContext, 'text');
    const deprecatedNode = findNodeAtLocation(descriptionNode, ['deprecated']);
    if (deprecatedNode) {
        assertNotEmptyString(deprecatedNode, parserContext, 'deprecated');
    }
    const authorNode = findNodeAtLocation(descriptionNode, ['author']);
    if (authorNode) {
        assertNotEmptyString(authorNode, parserContext, 'author');
    }
}
function validatePageObjectJson(jsonSourceText) {
    const errors = [];
    const rootNode = parseTree(jsonSourceText, errors);
    const structure = 'root';
    // check if preliminary parsing returned some errors
    if (errors.length) {
        const firstError = errors[0];
        const utamParseError = isUtamParseError(firstError) ? firstError : createUtamParseError(firstError);
        const { message, offset } = utamParseError;
        throw new UtamCompilerValidationError({ offset }, 900, [message]);
    }
    assertIsObject(rootNode, structure, 'json');
    assertValidKeys(rootNode, structure, ROOT_PROPERTIES);
    const selectorNode = findNodeAtLocation(rootNode, ['selector']);
    const rootMarkerNode = findNodeAtLocation(rootNode, ['root']);
    const typeNode = findNodeAtLocation(rootNode, ['type']);
    const context = new Context();
    // need to register root and document in case it's referenced from compose
    const rootElm = new ElementContext(ROOT_ELEMENT_NAME, 'basic', typeNode ? getNodeValue(typeNode) : [UTAM_ELEMENT_DEFAULT_TYPE], false);
    context.addUniqueElement(rootElm);
    const documentElm = new ElementContext(DOCUMENT_OBJECT_NAME, 'custom', 'custom/pageObjects/document', false);
    context.addUniqueElement(documentElm);
    context.isInterface = assertBooleanProperty(structure, rootNode, 'interface', false);
    if (context.isInterface) {
        assertValidKeys(rootNode, 'interface root', INTERFACE_PROPERTIES);
    }
    if (selectorNode) {
        assertIsObject(selectorNode, structure, 'property "selector"');
        validateSelector({ context, elementContext: rootElm, parserContext: 'root "selector" property' }, selectorNode);
        // if not marked as root - selector is redundant
        if (!rootMarkerNode || !rootMarkerNode?.value) {
            throw new UtamSchemaValidationError(descriptions.ROOT.REDUNDANT_SELECTOR());
        }
    }
    else {
        // if marked as root - needs selector
        if (!context.isInterface && rootMarkerNode && rootMarkerNode?.value) {
            const { offset, length } = rootMarkerNode.parent;
            throw new UtamSchemaValidationError(descriptions.ROOT.REQUIRED_SELECTOR_IF_ROOT({ offset, length }));
        }
    }
    // check that value is boolean
    assertBooleanProperty(structure, rootNode, 'root', false);
    assertBooleanProperty(structure, rootNode, 'exposeRootElement', false);
    assertValueInSet(structure, rootNode, 'platform', SUPPORTED_MOBILE_CONTEXT_TYPE);
    const metadataNode = findNodeAtLocation(rootNode, ['metadata']);
    if (metadataNode) {
        assertIsObject(metadataNode, structure, 'property "metadata"');
    }
    if (typeNode) {
        if (typeNode.type === 'array') {
            assertOptionalNotEmptyArray(typeNode, 'page object root', 'type');
        }
        else {
            assertNotEmptyString(typeNode, 'page object root', 'type');
        }
        const typeValue = getNodeValue(typeNode);
        assertValidBasicElementTypes(typeValue, 'root');
    }
    const implementsNode = findNodeAtLocation(rootNode, ['implements']);
    if (implementsNode) {
        assertNotEmptyString(implementsNode, 'page object root', 'implements');
    }
    const profileNode = findNodeAtLocation(rootNode, ['profile']);
    if (profileNode) {
        if (!implementsNode) {
            const { offset, length } = profileNode;
            throw new UtamSchemaValidationError(descriptions.ROOT.REQUIRED_IMPLEMENTS_IF_PROFILE({ offset, length }));
        }
        assertOptionalNotEmptyArray(profileNode, 'page object root', 'profile');
        if (profileNode.children) {
            const tracker = new Set();
            for (const profile of profileNode.children) {
                assertIsObject(profile, 'root', 'profile');
                validateProfile(profile, tracker);
            }
        }
    }
    const shadowNode = findNodeAtLocation(rootNode, ['shadow']);
    if (shadowNode) {
        validateShadowRecursive('root', context, shadowNode);
    }
    const elementsNode = findNodeAtLocation(rootNode, ['elements']);
    if (elementsNode) {
        validateElementsRecursive('root', context, elementsNode);
    }
    // all methods should be validated after element traversal
    const beforeLoadNode = findNodeAtLocation(rootNode, ['beforeLoad']);
    if (beforeLoadNode) {
        validateBeforeLoad(context, beforeLoadNode);
    }
    const methodsNode = findNodeAtLocation(rootNode, ['methods']);
    if (methodsNode) {
        validateMethods(context, methodsNode);
    }
    const descriptionNode = findNodeAtLocation(rootNode, ['description']);
    if (descriptionNode) {
        validateRootDescription(descriptionNode);
    }
    return parse(jsonSourceText);
}
function validatePageObject(jsonSourceText) {
    try {
        return validatePageObjectJson(jsonSourceText);
    }
    catch (error) {
        if (error instanceof UtamValidationError && error.position) {
            calculatePositionFromSource(error, jsonSourceText);
        }
        throw error;
    }
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * set default values to compiler config
 * @param config undefined
 * @returns default config
 */
function normalizeCompilerConfig(config) {
    return {
        skipCodeGen: !!config.skipCodeGen,
        skipTypeGen: !!config.skipTypeGen,
        format: config.format ?? 'es',
    };
}

/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function compile(jsonSource, pageObjectMeta, config = {}, alias = {}) {
    const normalizedConfig = normalizeCompilerConfig(config);
    const pageObject = validatePageObject(jsonSource);
    const { code, typeDefinition } = generatePageObject(pageObject, pageObjectMeta, normalizedConfig, alias);
    return { code, typeDefinition, pageObject };
}
function compileFromPath(pageObjectPath, commentsOptions, config = {}, alias = {}) {
    const sourceText = fs.readFileSync(pageObjectPath, 'utf8');
    const fileName = path.basename(pageObjectPath);
    const [pageObjectName] = fileName.split('.');
    const name = capitalize(kebabcaseToCamelcase(pageObjectName));
    return compile(sourceText, { name, commentsOptions }, config, alias);
}

export { compile, compileFromPath, replaceTypeString, textToJsDoc };
/** version: 1.2.2 */
