"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReturnTypeGenerator = exports.getExplicitReturnType = exports.RETURN_TYPE_VOID = void 0;
const class_body_generator_1 = require("../codegen/helpers/class-body-generator");
const shared_1 = require("../codegen/shared");
const element_types_1 = require("../utils/element-types");
const args_1 = require("./args");
const element_actions_1 = require("./element-actions");
const element_constructors_1 = require("./element-constructors");
const naming_1 = require("./naming");
const UTAM_CURRENT_PO_INSTANCE = 'this';
exports.RETURN_TYPE_VOID = {
    returnTypeValue: shared_1.UTAM_VOID_RETURN_TYPE,
    returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_VOID,
};
// -- Type Guards and utilites for return types
function isReturnTypePrimitive(type) {
    return (typeof type === 'string' &&
        [shared_1.UTAM_STRING_RETURN_TYPE, shared_1.UTAM_BOOLEAN_RETURN_TYPE, shared_1.UTAM_NUMBER_RETURN_TYPE].includes(type));
}
function isReturnTypePageObject(type) {
    return typeof type === 'string' && shared_1.UTAM_PAGE_OBJECT_RETURN_TYPE === type;
}
function isReturnTypeRootPageObject(type) {
    return typeof type === 'string' && shared_1.UTAM_ROOT_PAGE_OBJECT_RETURN_TYPE === type;
}
function isReturnTypeFrame(type) {
    return typeof type === 'string' && shared_1.UTAM_FRAME_RETURN_TYPE === type;
}
function isReturnTypeSelf(apply) {
    return shared_1.RETURN_SELF_ACTION === apply;
}
function isBasicElementAction(composeAction, type) {
    const { apply, chain } = composeAction;
    if (!chain && apply) {
        return Array.isArray(type) || element_actions_1.BASIC_ELEMENT_TYPES.includes(type);
    }
    return false;
}
function isGetterWithoutReturnType(composeAction) {
    const { element, returnType, apply, chain } = composeAction;
    if (chain || apply || returnType) {
        return false;
    }
    return element ? true : false;
}
/**
 * Get abstract method return type from the declared returnType
 *
 * @param returnType return type declared in the page object
 * @param typesTracker tracks names collisions
 * @returns the TypeScript type name returned by the method
 */
function getExplicitReturnType(returnType, typesTracker) {
    // string, number, boolean
    if (isReturnTypePrimitive(returnType)) {
        return {
            returnTypeValue: returnType,
            returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_PRIMITIVE,
        };
    }
    // pageObject - returnPageObject<T extends _UtamBasePageObject>(): Promise<T>;
    if (isReturnTypePageObject(returnType)) {
        return {
            returnTypeValue: naming_1.getImportNameFromPath(shared_1.UTAM_BASE_CLASS_NAME, typesTracker),
            returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_PAGE_OBJECT,
        };
    }
    // rootPageObject - returnRootPageObject<T extends _UtamBaseRootPageObject>(): Promise<T>;
    if (isReturnTypeRootPageObject(returnType)) {
        return {
            returnTypeValue: naming_1.getImportNameFromPath(shared_1.UTAM_BASE_ROOT_CLASS_NAME, typesTracker),
            returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_ROOT_PAGE_OBJECT,
        };
    }
    // frame - returnFrame(): Promise<_FrameUtamElement>
    if (isReturnTypeFrame(returnType)) {
        return {
            returnTypeValue: naming_1.getImportNameFromPath(shared_1.UTAM_FRAME_ELEMENT_CTOR, typesTracker),
            returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_FRAME_ELEMENT,
        };
    }
    // for interface return type covers basic elements, custom elements, 'void'
    const elementType = returnType;
    if (element_types_1.isCustomType(elementType)) {
        return {
            returnTypeValue: naming_1.getImportNameFromPath(elementType, typesTracker),
            returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT,
        };
    }
    else if (element_types_1.isBasicElement(elementType)) {
        const basicElementType = element_types_1.wrapSingleBasicTypeInArray(elementType);
        return {
            returnTypeValue: element_constructors_1.createBasicElementCtorType(basicElementType),
            returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_BASIC_ELEMENT,
        };
    }
    return exports.RETURN_TYPE_VOID;
}
exports.getExplicitReturnType = getExplicitReturnType;
/**
 * Return type generator for compose statement
 * @param typesTracker
 * @param elementMethodsAst
 * @returns
 */
function createReturnTypeGenerator(typesTracker, elementMethodsAst) {
    // create a closure to have access to the elements AST for waitFor predicate's statements
    return function generateReturnType(composeAction, elementType) {
        const { matcher, apply, returnType } = composeAction;
        if (matcher) {
            return {
                returnTypeValue: shared_1.UTAM_BOOLEAN_RETURN_TYPE,
                returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_PRIMITIVE,
            };
        }
        const explicitReturnType = returnType ? getExplicitReturnType(returnType, typesTracker) : undefined;
        // predicate, should be checked prior to basic action: it's basic action when called on basic element
        if (apply === 'waitFor') {
            const lastPredicateStatement = args_1.getLastPredicateStatement(composeAction);
            const generateReturnType = createReturnTypeGenerator(typesTracker, elementMethodsAst);
            const { element, chain: isChain = false } = lastPredicateStatement;
            const elementAst = element && !isChain ? class_body_generator_1.findElementAst(element, elementMethodsAst).type : undefined;
            const returnType = generateReturnType(lastPredicateStatement, elementAst);
            if (explicitReturnType) {
                // todo - check the match, throw. Will add whith refactoring of error codes.
            }
            return returnType;
        }
        // basic element action - return type can be inferred
        if (isBasicElementAction(composeAction, elementType)) {
            const { apply: applyAction } = composeAction;
            const basicAction = element_actions_1.buildActionByName(applyAction);
            if (explicitReturnType && basicAction) {
                // todo - check the match, throw. Will add whith refactoring of error codes.
            }
            const returnTypeValue = basicAction?.return ?? shared_1.UTAM_VOID_RETURN_TYPE;
            const returnTypeKind = returnTypeValue !== shared_1.UTAM_VOID_RETURN_TYPE ? shared_1.UTAM_RETURN_CATEGORY_PRIMITIVE : shared_1.UTAM_RETURN_CATEGORY_VOID;
            // basic action can only return primitive, so string is same as value
            return { returnTypeValue, returnTypeKind };
        }
        // getter invocation, not chain
        if (isGetterWithoutReturnType(composeAction) && elementType) {
            const { returnTypeValue, returnTypeKind } = inferReturnTypeFromElementType(elementType, typesTracker);
            if (explicitReturnType) {
                // todo - check the match, throw. Will add whith refactoring of error codes.
            }
            return { returnTypeValue, returnTypeKind };
        }
        // this is needed for method to return Promise<this> in a declaration file
        if (apply && isReturnTypeSelf(apply)) {
            return {
                returnTypeValue: UTAM_CURRENT_PO_INSTANCE,
                returnTypeKind: shared_1.UTAM_RETURN_CATEGORY_SELF,
            };
        }
        // since we can't infer return for other types of statements - return explicit or void
        return explicitReturnType ? explicitReturnType : exports.RETURN_TYPE_VOID;
    };
}
exports.createReturnTypeGenerator = createReturnTypeGenerator;
/**
 * Infer return type for non-chained element getter
 * @param elementType type of the element whose getter is invoked
 * @param typesTracker names collisions types tracker
 * @returns inferred return type
 */
function inferReturnTypeFromElementType(elementType, typesTracker) {
    let returnTypeValue;
    let returnTypeKind;
    if (element_types_1.isFrameElement(elementType)) {
        returnTypeValue = naming_1.getImportNameFromPath(elementType, typesTracker);
        returnTypeKind = shared_1.UTAM_RETURN_CATEGORY_FRAME_ELEMENT;
    }
    else if (element_types_1.isCustomType(elementType)) {
        returnTypeValue = naming_1.getImportNameFromPath(elementType, typesTracker);
        returnTypeKind = shared_1.UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT;
    }
    else if (element_types_1.isBasicElement(elementType)) {
        const basicElementType = element_types_1.wrapSingleBasicTypeInArray(elementType);
        returnTypeValue = element_constructors_1.createBasicElementCtorType(basicElementType);
        returnTypeKind = shared_1.UTAM_RETURN_CATEGORY_BASIC_ELEMENT;
    }
    else {
        // We don't infer return type for other element types
        return exports.RETURN_TYPE_VOID;
    }
    return {
        returnTypeValue,
        returnTypeKind,
    };
}
//# sourceMappingURL=return-types.js.map