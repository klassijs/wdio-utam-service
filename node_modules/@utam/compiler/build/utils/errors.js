"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePositionFromSource = exports.UtamJsonValidationError = exports.UtamSchemaValidationError = exports.UtamCompilerValidationError = exports.UtamValidationError = void 0;
const diagnostics_1 = require("@utam/diagnostics");
class UtamValidationError extends Error {
    constructor(diagnostic) {
        super(diagnostic.message);
        this.utamError = true;
        this.position = diagnostic.position;
    }
}
exports.UtamValidationError = UtamValidationError;
/**
 * build diagnostics error based on compiler config
 * @param errCode configured code
 * @returns diagnostics object to pass to exception
 */
function buildDiagnostics(errCode, args) {
    const error = diagnostics_1.getConfiguredError(errCode);
    return { message: diagnostics_1.buildMessageFromConfig(error, args) };
}
/**
 * error thrown in Json validation phase using error codes
 */
class UtamCompilerValidationError extends UtamValidationError {
    constructor({ offset }, errCode, args) {
        super(buildDiagnostics(errCode, args));
        this.position = { offset };
    }
}
exports.UtamCompilerValidationError = UtamCompilerValidationError;
/**
 * error thrown during validation of Json (prior to generation)
 */
class UtamSchemaValidationError extends UtamValidationError {
    constructor(diagnostic) {
        super(diagnostic);
        this.position = diagnostic.position;
    }
}
exports.UtamSchemaValidationError = UtamSchemaValidationError;
/**
 * error thrown by Json parser
 */
class UtamJsonValidationError extends UtamValidationError {
    constructor(diagnostic) {
        super(diagnostic);
        this.json = true;
        this.position = diagnostic.position;
    }
}
exports.UtamJsonValidationError = UtamJsonValidationError;
function calculatePositionFromSource(error, source) {
    const partialPosition = error.position;
    if (partialPosition !== undefined) {
        const lines = source.split('\n');
        let countedChars = 0;
        for (const [index, line] of lines.entries()) {
            const newLength = countedChars + line.length;
            if (newLength >= partialPosition.offset - 1) {
                error.position = {
                    offset: partialPosition.offset,
                    line: index + 1,
                    length: partialPosition.length,
                    column: partialPosition.offset - countedChars,
                };
                return partialPosition;
            }
            countedChars = newLength + 1;
        }
    }
}
exports.calculatePositionFromSource = calculatePositionFromSource;
//# sourceMappingURL=errors.js.map