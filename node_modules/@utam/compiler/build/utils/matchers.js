"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFilterFunctionCode = exports.generateMatcherCode = exports.getCompatibleMatchers = exports.getMatcherExpectedArgs = exports.getMatcherType = void 0;
const SUPPORTED_MATCHERS = [
    { matcher: 'isTrue', expectedArgs: [] },
    { matcher: 'isFalse', expectedArgs: [] },
    { matcher: 'stringContains', expectedArgs: ['string'] },
    { matcher: 'stringEquals', expectedArgs: ['string'] },
    { matcher: 'notNull', expectedArgs: [] },
];
function getMatcherType(matcherType) {
    const supported = SUPPORTED_MATCHERS.find((supported) => supported.matcher === matcherType);
    if (!supported) {
        return undefined;
    }
    return supported.matcher;
}
exports.getMatcherType = getMatcherType;
/**
 * depending on matcher type return expected matcher args types
 * @param structure
 * @param matcherType
 */
function getMatcherExpectedArgs(matcherType) {
    const supported = SUPPORTED_MATCHERS.find((supported) => supported.matcher === matcherType);
    if (!supported) {
        return undefined;
    }
    return supported.expectedArgs;
}
exports.getMatcherExpectedArgs = getMatcherExpectedArgs;
function getCompatibleMatchers(actionType) {
    if (!actionType.return || actionType.return === 'unknown') {
        return [];
    }
    else if (actionType.return === 'string') {
        return ['stringContains', 'stringEquals'];
    }
    else if (actionType.return === 'boolean') {
        return ['isTrue', 'isFalse', 'notNull'];
    }
    else {
        return [];
    }
}
exports.getCompatibleMatchers = getCompatibleMatchers;
function generateMatcherCode(matcherType, explicitArgumentsCode) {
    switch (matcherType) {
        case 'stringContains':
            return `?.includes(${explicitArgumentsCode}) ?? false`;
        case 'isTrue':
            return ` == true`;
        case 'isFalse':
            return ` == false`;
        case 'notNull':
            return ` !== null`;
        case 'stringEquals':
            return ` === ${explicitArgumentsCode}`;
        default:
            // should be caught in validation, never thrown here
            throw new Error(`Unsupported matcher type: "${matcherType}".`);
    }
}
exports.generateMatcherCode = generateMatcherCode;
/**
 * helper to build code of the filter method
 * @param matcherType type of the matcher
 * @param filterApplyCode with method invoked in a filter, ex. "await element.${apply}(${applyArgs})"
 * @param filterArg filter argument value
 * @returns generated code for a filter application
 */
function buildFilterFunctionCode(matcherType, filterApplyCode, filterArg) {
    if (matcherType === 'stringContains') {
        return `const result = ${filterApplyCode};\nreturn result.includes(${filterArg});`;
    }
    else if (matcherType === 'stringEquals') {
        return `const result = ${filterApplyCode};\nreturn result === ${filterArg};`;
    }
    else if (matcherType === 'isTrue') {
        return `return ${filterApplyCode};`;
    }
    else if (matcherType === 'isFalse') {
        return `return !(${filterApplyCode});`;
    }
    else if (matcherType === 'notNull') {
        return `const result = ${filterApplyCode};\nreturn result !== null;`;
    }
    else {
        // should be caught in validation, never thrown here
        throw new Error(`Unsupported matcher type: "${matcherType}".`);
    }
}
exports.buildFilterFunctionCode = buildFilterFunctionCode;
//# sourceMappingURL=matchers.js.map