"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActionExpectedArgs = exports.isCorrectElementCardinality = exports.isActionApplicableForTypes = exports.buildActionByName = exports.BASIC_ELEMENT_TYPES = void 0;
// supported element types that can use actions
const ACTIONABLE = 'actionable';
const CLICKABLE = 'clickable';
const DRAGGABLE = 'draggable';
const EDITABLE = 'editable';
const TOUCHABLE = 'touchable';
exports.BASIC_ELEMENT_TYPES = [
    'basic',
    ACTIONABLE,
    CLICKABLE,
    EDITABLE,
    DRAGGABLE,
    TOUCHABLE,
];
const BASE_TYPES = [...exports.BASIC_ELEMENT_TYPES, 'self'];
/**
 * enumeration of all supported actions for an actionable element
 * used for validations that action is supported, applicable to the element and passed arguments match expected,
 * based on return type of the action, generated code has "return" in the last compose statement and forEach or map to apply to list
 * based on applicability, compiler decides if action is applicable to the given element type
 * based on action cardinality, compiler decides if action can be applied to the single element or needs a list
 */
const SUPPORTED_ACTIONS = [
    { applyFunction: 'blur', applicableTo: [ACTIONABLE] },
    { applyFunction: 'click', applicableTo: [CLICKABLE] },
    { applyFunction: 'clickAndHold', applicableTo: [CLICKABLE], args: [{ type: 'number', required: false }] },
    { applyFunction: 'clear', applicableTo: [EDITABLE] },
    { applyFunction: 'clearAndType', applicableTo: [EDITABLE], args: [{ type: 'string', required: true }] },
    { applyFunction: 'doubleClick', applicableTo: [CLICKABLE] },
    {
        applyFunction: 'dragAndDrop',
        applicableTo: [DRAGGABLE],
        args: [
            { type: 'elementReference', required: true },
            { type: 'number', required: false },
        ],
    },
    {
        applyFunction: 'dragAndDropByOffset',
        applicableTo: [DRAGGABLE],
        args: [
            { type: 'number', required: true },
            { type: 'number', required: true },
            { type: 'number', required: false },
        ],
    },
    {
        applyFunction: 'flick',
        applicableTo: [TOUCHABLE],
        args: [
            { type: 'number', required: true },
            { type: 'number', required: true },
        ],
    },
    { applyFunction: 'focus', applicableTo: [ACTIONABLE] },
    {
        applyFunction: 'getAttribute',
        applicableTo: exports.BASIC_ELEMENT_TYPES,
        return: 'string',
        args: [{ type: 'string', required: true }],
    },
    { applyFunction: 'getClassAttribute', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'string' },
    {
        applyFunction: 'getCssPropertyValue',
        applicableTo: exports.BASIC_ELEMENT_TYPES,
        args: [{ type: 'string', required: true }],
        return: 'string',
    },
    // this action is set to return void because we do not support return type for location and size
    { applyFunction: 'getRect', applicableTo: exports.BASIC_ELEMENT_TYPES },
    { applyFunction: 'getText', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'string' },
    { applyFunction: 'getTitle', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'string' },
    { applyFunction: 'getValue', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'string' },
    { applyFunction: 'isEnabled', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'boolean' },
    { applyFunction: 'isFocused', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'boolean' },
    { applyFunction: 'moveTo', applicableTo: [ACTIONABLE] },
    { applyFunction: 'rightClick', applicableTo: [CLICKABLE] },
    { applyFunction: 'scrollToCenter', applicableTo: [ACTIONABLE] },
    { applyFunction: 'scrollToTop', applicableTo: [ACTIONABLE] },
    { applyFunction: 'setText', applicableTo: [EDITABLE], args: [{ type: 'string', required: true }] },
    { applyFunction: 'press', applicableTo: [EDITABLE], args: [{ type: 'string', required: true }] },
    { applyFunction: 'size', applicableTo: exports.BASIC_ELEMENT_TYPES, return: 'number', howToApply: 'needs list' },
    // actions applicable to a basic element type and a page object
    { applyFunction: 'isPresent', applicableTo: BASE_TYPES, return: 'boolean' },
    { applyFunction: 'isVisible', applicableTo: BASE_TYPES, return: 'boolean' },
    {
        applyFunction: 'containsElement',
        applicableTo: BASE_TYPES,
        args: [
            { type: 'locator', required: true },
            { type: 'boolean', required: false },
        ],
        return: 'boolean',
    },
    {
        applyFunction: 'waitFor',
        applicableTo: BASE_TYPES,
        args: [{ type: 'function', required: true }],
    },
    { applyFunction: 'waitForAbsence', applicableTo: BASE_TYPES },
    { applyFunction: 'waitForVisible', applicableTo: BASE_TYPES },
    { applyFunction: 'waitForInvisible', applicableTo: BASE_TYPES },
];
function isUtamElementType(elementType) {
    return exports.BASIC_ELEMENT_TYPES.includes(elementType);
}
/**
 * check if string matches one of the supported actions from grammar spec
 * return supported action metadata object if it does or undefined otherwise
 * undefined value if further processed by validator
 * @param applyString string with action type
 */
function buildActionByName(applyFunction, elementType) {
    if (elementType && !Array.isArray(elementType) && !isUtamElementType(elementType) && elementType !== 'self') {
        return {
            external: true,
            applyFunction,
            return: 'unknown',
        };
    }
    return SUPPORTED_ACTIONS.find((action) => action.applyFunction === applyFunction);
}
exports.buildActionByName = buildActionByName;
/**
 * Verify that an action is applicable to at least one element types from the set of declared types
 * @param actionType type of the action being applied
 * @param elementTypes
 * @returns false if the action can't be applied to the element, true otherwise
 */
function isActionApplicableForTypes(actionType, elementTypes) {
    let isActionAppliedToOneElementType;
    if (Array.isArray(elementTypes)) {
        isActionAppliedToOneElementType = elementTypes.some((elementType) => actionType.applicableTo.includes(elementType));
    }
    else {
        isActionAppliedToOneElementType = actionType.applicableTo.includes(elementTypes);
    }
    return isActionAppliedToOneElementType;
}
exports.isActionApplicableForTypes = isActionApplicableForTypes;
/**
 * check if action requires operand to be a list/array of elements
 * @param methodName name of the compose method being validated
 * @param actionType type of the action being applied
 * @param isElementList boolean indicator if element is a list
 * @return false if action requires list and element is not
 */
function isCorrectElementCardinality(actionType, isElementList) {
    if (actionType.external || !actionType.howToApply) {
        return true; // we don't know expected cardinality or applicable to any
    }
    return isElementList === (actionType.howToApply === 'needs list');
}
exports.isCorrectElementCardinality = isCorrectElementCardinality;
function getActionExpectedArgs(actionType) {
    return actionType.args || [];
}
exports.getActionExpectedArgs = getActionExpectedArgs;
//# sourceMappingURL=element-actions.js.map