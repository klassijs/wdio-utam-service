import { ArgumentType, ExplicitNonLiteralArg, ExplicitUtamArgument, MethodArgumentsTypeMap, MethodArgumentsDescriptionMap, UtamArgumentInternal, UtamPrimitiveLiteralValues, UtamPrimitiveTypeValues, UtamSelector, UtamArgumentPrimitive, UtamArgument } from '@utam/types';
export declare function replaceSelectorArguments(selectorExpression: string, args: string[], prefix?: string, suffix?: string): string;
/**
 * Detect and return supported literal primitive type
 *
 * @param value primitive literal value
 * @returns value's type
 */
export declare function deriveLiteralType(value: UtamPrimitiveLiteralValues): UtamPrimitiveTypeValues;
/**
 * from array of UtamArgument get string array for method declaration
 * @param args declared arguments
 */
export declare function getArgumentsNames(args: UtamArgumentInternal[] | undefined): string[];
/**
 * literal locator can have nested args
 * @param args arguments
 * @returns array of nested arguments
 */
export declare function getLocatorNestedArguments(args: UtamArgumentInternal[] | undefined): UtamArgumentPrimitive[];
/**
 * helper to build selector such as By.css('.mySelector')
 * @param selector string with selector
 * @param byId prefix for builder, usually 'By'
 */
export declare function buildLiteralSelectorCode(selector: UtamSelector, byId?: string): string;
/**
 * Extract arguments types from a given selector value.
 * This is used to extract arguments types from selector parameters.
 * @param selector selector (accessid | classchain | css uiautomator) value
 * @returns list of argument types declared in the selector value
 */
export declare function getSelectorArgTypesFromString(selector: string): ArgumentType[];
export declare function getSelectorArgTypes(selector: UtamSelector): MethodArgumentsTypeMap;
export declare function getSelectorArgDescriptions(selector: UtamSelector): MethodArgumentsDescriptionMap;
/**
 * creates map for method arguments of "name" : "type"
 * @param args declared method args
 * @returns map of names and types for method declaration
 */
export declare function getArgumentsTypeMap(args: UtamArgumentInternal[] | undefined): MethodArgumentsTypeMap;
/**
 * creates map for method arguments of "name" : "description"
 * @param args declared method args
 * @returns map of names and types for method declaration
 */
export declare function getArgumentsDescriptionMap(args: UtamArgumentInternal[] | undefined): MethodArgumentsDescriptionMap;
/**
 * generates code for the argument value to add inside a method invocations
 * @param arg argument to get value from after traversal in method
 * @param byId string for "By"
 * @returns string with arg value
 */
export declare function generateArgumentValueCode(arg: ExplicitUtamArgument, byId: string): string;
/**
 * generates code for the argument value to add in method invocations or in hoisted methods
 * @param arg UtamArgument from JSON (for hoisted methods)
 * @param byId string for "By"
 * @returns string with arg value
 */
export declare function generateUtamArgumentValueCode(arg: UtamArgument, byId: string): string;
/**
 * This function creates a function that ensure that compose method have unique arguments names.
 * This returns a closure that keep track of previous statements arguments.
 *
 * @param validationContext name of the structure that is being validated
 * @returns a closure that will ensure that the compose method has unique arguments names
 */
export declare function createUniqueNamesValidator(validationContext: string): (arg: any[] | any) => void;
/**
 * Getter invocation can have explicit args, including argumentReference.
 * This method validates number and types of arguments, literal or non literal
 * @param elementArgs required element args declared inside the element
 * @param explicitArgs declared args in a getter compose statement
 * @returns array or arguments to be used
 */
export declare function mergeElementAndExplicitArgs(elementArgs: ExplicitNonLiteralArg[], explicitArgs: ExplicitUtamArgument[]): ExplicitUtamArgument[];
//# sourceMappingURL=primitive-arguments.d.ts.map