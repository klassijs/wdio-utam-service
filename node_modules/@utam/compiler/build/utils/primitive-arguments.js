"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeElementAndExplicitArgs = exports.createUniqueNamesValidator = exports.generateUtamArgumentValueCode = exports.generateArgumentValueCode = exports.getArgumentsDescriptionMap = exports.getArgumentsTypeMap = exports.getSelectorArgDescriptions = exports.getSelectorArgTypes = exports.getSelectorArgTypesFromString = exports.buildLiteralSelectorCode = exports.getLocatorNestedArguments = exports.getArgumentsNames = exports.deriveLiteralType = exports.replaceSelectorArguments = void 0;
const diagnostics_1 = require("@utam/diagnostics");
const code_1 = require("./code");
const ARGS_TYPE_REGEX = /(%[s|d])/g;
// this type of error is thrown for args validations
class UtamArgsValidationError extends Error {
    constructor(diagnostic) {
        super(diagnostic.message);
        this.utamError = true;
    }
}
function replaceSelectorArguments(selectorExpression, args, prefix = '" + ', suffix = ' + "') {
    const argx = args.slice();
    return selectorExpression.replace(ARGS_TYPE_REGEX, function x() {
        const argName = argx.shift();
        if (!argName) {
            throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.SELECTOR_MISSING_ARGUMENT(selectorExpression, args));
        }
        return `${prefix}${argName}${suffix}`;
    });
}
exports.replaceSelectorArguments = replaceSelectorArguments;
function isPrimitiveType(type) {
    return type === 'string' || type === 'number' || type === 'boolean';
}
/**
 * Detect and return supported literal primitive type
 *
 * @param value primitive literal value
 * @returns value's type
 */
function deriveLiteralType(value) {
    switch (typeof value) {
        case 'string': {
            return 'string';
        }
        case 'number': {
            return 'number';
        }
        case 'boolean': {
            return 'boolean';
        }
        default: {
            throw new Error(`Unsupported literal argument type: ${typeof value}`);
        }
    }
}
exports.deriveLiteralType = deriveLiteralType;
function checkArgType(validationContextStr, argNameOrValue, expectedType, argType) {
    if (argType !== expectedType)
        throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.INCORRECT_TYPE(validationContextStr, argNameOrValue, expectedType, argType));
}
/**
 * from array of UtamArgument get string array for method declaration
 * @param args declared arguments
 */
function getArgumentsNames(args) {
    const argNames = [];
    if (!args) {
        return [];
    }
    // Add support for literal argument by filtering them explicitly
    // as we don't want literal arguments to be present in the method signatures
    const nonLiteralArg = args.filter((arg) => !('value' in arg));
    nonLiteralArg.forEach((arg) => argNames.push(arg.name));
    const nestedArgs = getLocatorNestedArguments(args);
    nestedArgs.forEach((arg) => {
        if (arg.name) {
            argNames.push(arg.name);
        }
    });
    return argNames;
}
exports.getArgumentsNames = getArgumentsNames;
/**
 * type predicates that narrows the literal arguments parameter down to UtamSelector
 * if the predicate is satisfied.
 * @param literalArg non-primitive literal argument ({ value: { ... }})
 * @returns true if the predicate condition is satisfied, false otherwise
 */
function isUtamSelector(literalArg) {
    return (typeof literalArg === 'object' &&
        ('css' in literalArg || 'accessid' in literalArg || 'classchain' in literalArg || 'uiautomator' in literalArg));
}
/**
 * literal locator can have nested args
 * @param args arguments
 * @returns array of nested arguments
 */
function getLocatorNestedArguments(args) {
    const res = [];
    if (!args) {
        return res;
    }
    args.forEach((arg) => {
        if ('value' in arg && isUtamSelector(arg.value)) {
            const selector = arg.value;
            if (selector.args) {
                res.push(...selector.args);
            }
        }
    });
    return res;
}
exports.getLocatorNestedArguments = getLocatorNestedArguments;
/**
 * helper to build selector such as By.css('.mySelector')
 * @param selector string with selector
 * @param byId prefix for builder, usually 'By'
 */
function buildLiteralSelectorCode(selector, byId) {
    if (!byId) {
        throw new Error(`Identifier for "By" must be present`);
    }
    const { args = [] } = selector;
    const selectorType = getDeclaredSelector(selector);
    const byApiId = getByApiId(selectorType);
    const selectorValue = selector[selectorType];
    if (!selectorValue) {
        throw new Error(`Selector "${JSON.stringify(selector)}" should have a value`);
    }
    if (!args.length) {
        return `${byId}.${byApiId}("${code_1.escapeDoubleQuotes(selectorValue)}")`;
    }
    // Note: we replace single quotes (') and double quotes (") with escaped double quotes (\")
    // as it seems that Appium doesn't recognize single quotes as strings
    return `${byId}.${byApiId}("${replaceSelectorArguments(code_1.escapeDoubleQuotes(code_1.singleToDoubleQuotes(selectorValue)), getArgumentsNames(args))}")`;
}
exports.buildLiteralSelectorCode = buildLiteralSelectorCode;
/**
 * Return the selector that has been specified in the page object
 *
 * @param selector element selector parsed from the JSON page object
 * @returns the element selector type
 */
function getDeclaredSelector(selector) {
    return selector.css ? 'css' : selector.accessid ? 'accessid' : selector.classchain ? 'classchain' : 'uiautomator';
}
/**
 * Return the By method identifier that is use to locate the element from the type of selector
 * declared in the page object
 *
 * @param selectorType the selector type declared in the page object
 * @returns the invoked By API used to find the element
 */
function getByApiId(selectorType) {
    switch (selectorType) {
        case 'accessid':
            return 'accessibilityId';
        case 'classchain':
            return 'classChain';
        case 'css':
            return 'css';
        case 'uiautomator':
            return 'uiAutomator';
    }
}
/**
 * Extract arguments types from a given selector value.
 * This is used to extract arguments types from selector parameters.
 * @param selector selector (accessid | classchain | css uiautomator) value
 * @returns list of argument types declared in the selector value
 */
function getSelectorArgTypesFromString(selector) {
    const types = [];
    const matches = selector.match(ARGS_TYPE_REGEX);
    const validationContext = `Selector "${selector}"`;
    if (matches) {
        matches.forEach((match) => {
            switch (match) {
                case '%s':
                    types.push('string');
                    break;
                case '%d':
                    types.push('number');
                    break;
                default:
                    throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.INCORRECT_TYPE(validationContext, 'selector', 'string or number', match));
            }
        });
    }
    return types;
}
exports.getSelectorArgTypesFromString = getSelectorArgTypesFromString;
function getSelectorArgTypes(selector) {
    const matchTypes = {};
    const { css, args } = selector;
    if (args && args.length) {
        if (css) {
            const matches = css.match(ARGS_TYPE_REGEX);
            const validationContext = `Selector "${css}"`;
            if (matches) {
                const argx = args.slice();
                matches.forEach((match, index) => {
                    const key = argx.shift();
                    if (!key) {
                        throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.SELECTOR_MISSING_ARGUMENT(css, getArgumentsNames(args)));
                    }
                    switch (match) {
                        case '%s':
                            matchTypes[key.name] = 'string';
                            checkArgType(validationContext, key.name, 'string', args[index].type);
                            break;
                        case '%d':
                            matchTypes[key.name] = 'number';
                            checkArgType(validationContext, key.name, 'number', args[index].type);
                            break;
                        default:
                            throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.INCORRECT_TYPE(validationContext, key.name, 'string or number', match));
                    }
                });
            }
            else {
                throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.INCORRECT_COUNT(validationContext, args.length, 0));
            }
        }
        else {
            args.forEach((arg) => {
                if (arg.name.includes(':')) {
                    const [key, type] = arg.name.split(':');
                    matchTypes[key] = type;
                }
                else {
                    matchTypes[arg.name] = 'string';
                }
            });
        }
    }
    return matchTypes;
}
exports.getSelectorArgTypes = getSelectorArgTypes;
function getSelectorArgDescriptions(selector) {
    const matchTypes = {};
    const { css, args } = selector;
    if (args && args.length) {
        if (css) {
            const matches = css.match(ARGS_TYPE_REGEX);
            const validationContext = `Selector "${css}"`;
            if (matches) {
                const argx = args.slice();
                matches.forEach(() => {
                    const key = argx.shift();
                    if (!key) {
                        throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.SELECTOR_MISSING_ARGUMENT(css, getArgumentsNames(args)));
                    }
                    const description = key.description;
                    matchTypes[key.name] = description;
                });
            }
            else {
                throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.INCORRECT_COUNT(validationContext, args.length, 0));
            }
        }
        else {
            args.forEach((arg) => {
                const description = arg.description;
                if (arg.name.includes(':')) {
                    const [key] = arg.name.split(':');
                    matchTypes[key] = description;
                }
                else {
                    matchTypes[arg.name] = description;
                }
            });
        }
    }
    return matchTypes;
}
exports.getSelectorArgDescriptions = getSelectorArgDescriptions;
/**
 * creates map for method arguments of "name" : "type"
 * @param args declared method args
 * @returns map of names and types for method declaration
 */
function getArgumentsTypeMap(args) {
    const matchTypes = {};
    if (!args) {
        return matchTypes;
    }
    args.forEach((arg) => {
        // only get arg type for non literal args
        if (arg.type !== 'literal' && !('value' in arg) && arg.name) {
            matchTypes[arg.name] = arg.type;
        }
        if ('value' in arg && isUtamSelector(arg.value)) {
            const selector = arg.value;
            if (selector.args) {
                selector.args.forEach((arg) => {
                    matchTypes[arg.name] = arg.type;
                });
            }
        }
    });
    return matchTypes;
}
exports.getArgumentsTypeMap = getArgumentsTypeMap;
/**
 * creates map for method arguments of "name" : "description"
 * @param args declared method args
 * @returns map of names and types for method declaration
 */
function getArgumentsDescriptionMap(args) {
    const matchTypes = {};
    if (!args) {
        return matchTypes;
    }
    args.forEach((arg) => {
        // only get arg type for non literal args
        if (arg.type !== 'literal' && !('value' in arg) && arg.name) {
            matchTypes[arg.name] = arg.description;
        }
        if ('value' in arg && isUtamSelector(arg.value)) {
            const selector = arg.value;
            if (selector.args) {
                selector.args.forEach((arg) => {
                    matchTypes[arg.name] = arg.description;
                });
            }
        }
    });
    return matchTypes;
}
exports.getArgumentsDescriptionMap = getArgumentsDescriptionMap;
/**
 * generates code for the argument value to add inside a method invocations
 * @param arg argument to get value from after traversal in method
 * @param byId string for "By"
 * @returns string with arg value
 */
function generateArgumentValueCode(arg, byId) {
    const { literal, type } = arg;
    if (arg.type === 'argumentReference') {
        return arg.name;
    }
    if (!literal) {
        return arg.name;
    }
    if (isPrimitiveType(type)) {
        const value = arg.value;
        return type === 'string' ? `"${code_1.escapeDoubleQuotes(value)}"` : value.toString();
    }
    if (type === 'locator') {
        const value = arg.value;
        return buildLiteralSelectorCode(value, byId);
    }
    throw new Error(`Unsupported argument type: ${JSON.stringify(arg)}`);
}
exports.generateArgumentValueCode = generateArgumentValueCode;
function isPrimitiveValue(value) {
    return typeof value === 'string' || typeof value === 'boolean' || typeof value === 'number';
}
/**
 * generates code for the argument value to add in method invocations or in hoisted methods
 * @param arg UtamArgument from JSON (for hoisted methods)
 * @param byId string for "By"
 * @returns string with arg value
 */
function generateUtamArgumentValueCode(arg, byId) {
    if (!('value' in arg)) {
        return arg.name;
    }
    const { value } = arg;
    if (isPrimitiveValue(value)) {
        return typeof value === 'string' ? `"${code_1.escapeDoubleQuotes(value)}"` : value.toString();
    }
    if (isUtamSelector(value)) {
        return buildLiteralSelectorCode(value, byId);
    }
    throw new Error(`Unsupported argument type: ${JSON.stringify(arg)}`);
}
exports.generateUtamArgumentValueCode = generateUtamArgumentValueCode;
/**
 * This function creates a function that ensure that compose method have unique arguments names.
 * This returns a closure that keep track of previous statements arguments.
 *
 * @param validationContext name of the structure that is being validated
 * @returns a closure that will ensure that the compose method has unique arguments names
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function createUniqueNamesValidator(validationContext) {
    const composeArgNames = new Set();
    /**
     * This closure is called anytime we try to add new parameters to the compose
     * method signature. It will throw if we have duplicated arguments.
     * It act as a safeguard to ensure we don't generate JS that is invalid (e.g function method(arg, arg) {})
     *
     * @param args argument(s) that need(s) to be validated
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function validateUniqueArgumentsNames(args) {
        if (!Array.isArray(args))
            args = [args];
        for (const arg of args) {
            const { name: argName } = arg;
            if (composeArgNames.has(argName)) {
                throw new UtamArgsValidationError(diagnostics_1.generation.ARGS.COMPOSE_METHOD_DUPLICATED_ARGUMENT_NAMES(argName, validationContext));
            }
            else {
                composeArgNames.add(argName);
            }
        }
    };
}
exports.createUniqueNamesValidator = createUniqueNamesValidator;
/**
 * Getter invocation can have explicit args, including argumentReference.
 * This method validates number and types of arguments, literal or non literal
 * @param elementArgs required element args declared inside the element
 * @param explicitArgs declared args in a getter compose statement
 * @returns array or arguments to be used
 */
function mergeElementAndExplicitArgs(elementArgs, explicitArgs) {
    // if explicit args are not set - return original
    if (explicitArgs.length === 0) {
        return elementArgs;
    }
    // todo - add validation and error codes
    return explicitArgs;
}
exports.mergeElementAndExplicitArgs = mergeElementAndExplicitArgs;
//# sourceMappingURL=primitive-arguments.js.map