import type { UtamMethodAction } from '@utam/types';
import { Node } from 'jsonc-parser';
/**
 * convert a argNode into a Map where keys are the name property value and the value are the node itself.
 * this only works with arguments that doesn't hold literal argument as it's meant to be used for
 * compose arguments.
 * @param argNode method arguments that are being converted
 * @returns a map whose key is the node's name and the value the node itself
 */
export declare function buildArgsNodeMap(argNode: Node | undefined): Map<string, Node>;
/**
 * if type is argumentReference - find node in a top level map or return undefined, invocator will throw an error
 * @param nameValue name of the argument to find in map of declared args
 * @param rootArgsMap map with declared args at the top level
 * @returns undefined if nothing found
 */
export declare function getReferencedArgument(nameValue: string, rootArgsMap?: Map<string, Node>): string | undefined;
/**
 * Return the last predicate statement from a function argument
 * @param composeAction compose statement
 * @returns last item in the predicate array
 */
export declare function getLastPredicateStatement(composeAction: UtamMethodAction): UtamMethodAction;
export declare type SupportedArgsType = 'onlyValues' | 'onlyNameType' | 'any';
export declare function isOnlyValueAllowed(supports: SupportedArgsType): boolean;
export declare function isValueNotAllowed(supports: SupportedArgsType): boolean;
export declare function isSameArgumentType(expectedType: string, actualType: string): boolean;
//# sourceMappingURL=args.d.ts.map