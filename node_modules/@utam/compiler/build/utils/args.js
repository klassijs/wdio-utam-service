"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameArgumentType = exports.isValueNotAllowed = exports.isOnlyValueAllowed = exports.getLastPredicateStatement = exports.getReferencedArgument = exports.buildArgsNodeMap = void 0;
const jsonc_parser_1 = require("jsonc-parser");
/**
 * convert a argNode into a Map where keys are the name property value and the value are the node itself.
 * this only works with arguments that doesn't hold literal argument as it's meant to be used for
 * compose arguments.
 * @param argNode method arguments that are being converted
 * @returns a map whose key is the node's name and the value the node itself
 */
function buildArgsNodeMap(argNode) {
    if (!argNode?.children?.length)
        return new Map();
    return argNode.children.reduce((argsMap, rootArgNode) => {
        // The method arguments were already validated in validateMethod
        const nameNode = jsonc_parser_1.findNodeAtLocation(rootArgNode, ['name']);
        const nameValue = jsonc_parser_1.getNodeValue(nameNode);
        argsMap.set(nameValue, rootArgNode);
        return argsMap;
    }, new Map());
}
exports.buildArgsNodeMap = buildArgsNodeMap;
/**
 * if type is argumentReference - find node in a top level map or return undefined, invocator will throw an error
 * @param nameValue name of the argument to find in map of declared args
 * @param rootArgsMap map with declared args at the top level
 * @returns undefined if nothing found
 */
function getReferencedArgument(nameValue, rootArgsMap) {
    // ensure one can't reference unexisting arguments
    if (rootArgsMap && rootArgsMap.has(nameValue)) {
        // replace the reference type by it's associated type
        // defined in the root arguments map
        const argNode = rootArgsMap.get(nameValue);
        const typeNode = jsonc_parser_1.findNodeAtLocation(argNode, ['type']);
        if (typeNode) {
            return jsonc_parser_1.getNodeValue(typeNode);
        }
    }
    return undefined;
}
exports.getReferencedArgument = getReferencedArgument;
/**
 * Return the last predicate statement from a function argument
 * @param composeAction compose statement
 * @returns last item in the predicate array
 */
function getLastPredicateStatement(composeAction) {
    const { args } = composeAction;
    const { predicate } = args[0];
    const lastPredicateStatement = predicate[predicate.length - 1];
    return lastPredicateStatement;
}
exports.getLastPredicateStatement = getLastPredicateStatement;
function isOnlyValueAllowed(supports) {
    return supports === 'onlyValues';
}
exports.isOnlyValueAllowed = isOnlyValueAllowed;
function isValueNotAllowed(supports) {
    return supports === 'onlyNameType';
}
exports.isValueNotAllowed = isValueNotAllowed;
function isSameArgumentType(expectedType, actualType) {
    return expectedType === actualType;
}
exports.isSameArgumentType = isSameArgumentType;
//# sourceMappingURL=args.js.map