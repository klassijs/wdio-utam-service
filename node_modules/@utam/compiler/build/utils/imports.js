"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMissingImportsFromStatementsArgs = exports.generateImports = exports.replaceTypeString = exports.addImport = exports.buildIdentifier = void 0;
const shared_1 = require("../codegen/shared");
const STAR_WILDCARD = '*';
/**
 * Add an underscode to guarantee no conflict with anything in user land
 * an even more correct approach would be to use `${module}__${name}`
 * @param name original type name
 * @returns string with modified identifier
 */
function buildIdentifier(name) {
    const toIdentifier = (str) => str.replace(/[^a-zA-Z0-9_]+/g, '_').replace(/^\d/, '_$&');
    return toIdentifier(`_${name}`);
}
exports.buildIdentifier = buildIdentifier;
/**
 *
 * @param module full module name to import type from, ex. "@utam/lightning/pageobjects/input"
 * @param name short module name, ex. "Input"
 * @param imports map with imports: key is full module name, value is pairs of name and identifier
 * @param defaultImport indicates if import is default
 * @returns string with identifier, ex. "_Input"
 */
function addImport(module, name, imports, defaultImport = false) {
    let moduleMap = imports.get(module);
    if (!moduleMap) {
        moduleMap = new Map();
        imports.set(module, moduleMap);
    }
    let importIdentifier = moduleMap.get(name);
    if (!importIdentifier) {
        importIdentifier = buildIdentifier(name);
        moduleMap.set(defaultImport ? 'default' : name, importIdentifier);
    }
    return importIdentifier;
}
exports.addImport = addImport;
// If two imports have the same specifier merge their importedNames
// so we generate one import declaration rather than two
// Ex. import { a } from "m"; import { b } from "m" => import { a, b } from "m";
function mergeImports(importsMap) {
    const visitedImportsMap = new Map();
    importsMap.forEach((importMap) => {
        const [name, importees] = importMap;
        if (!visitedImportsMap.has(name)) {
            visitedImportsMap.set(name, importMap);
        }
        else {
            const mergedImportMaps = visitedImportsMap.get(name);
            if (mergedImportMaps) {
                mergedImportMaps[1] = new Map([...mergedImportMaps[1], ...importees]);
            }
        }
    });
    return Array.from(visitedImportsMap.values());
}
/**
 * Get the type's substring matched by the wildcard '*' from a given pattern.
 *
 * For instance: if the type value is "utam-foo/pageObjects/path/to/po"
 * and the pattern is "utam-foo/{wildcard}/po", the function returns
 * "pageObjects/path/to"
 *
 * @param type element type value (as declared in the JSON file)
 * @param pattern matching pattern from which we want to extract the wildcard vale=
 * @returns either the substring that '*' matches, either the empty string if no matches are found
 */
function getWildcardValue(type, pattern) {
    if (!pattern.includes(STAR_WILDCARD))
        return '';
    const [preWildcardStr, postWildcardStr] = pattern.split(STAR_WILDCARD);
    const postIndex = type.indexOf(postWildcardStr);
    return type.slice(0, postIndex).replace(preWildcardStr, '');
}
/**
 * Get the type alias from the alias config if there's a match
 *
 * @param type element type value (as declared in the JSON file)
 * @param aliasConfig type alias configuration mappings
 * @returns the alias matching this type, null if none alias are found for this type
 */
function getMatchingAliasForType(type, aliasConfig) {
    for (const matchPattern in aliasConfig) {
        const isMatchingPattern = matchPattern.split('*').every((matchSubPattern) => type.includes(matchSubPattern));
        if (isMatchingPattern) {
            return {
                matchPattern,
                replacePattern: aliasConfig[matchPattern],
            };
        }
    }
    return null;
}
/**
 * Update the module specifier by applying the replacement pattern if there's an alias for this type
 *
 * @param type type element type value (as declared in the JSON file)
 * @param aliasConfig type alias configuration mappings
 * @returns the original module specifier or the updated module specifier if there's an alias matching the type
 */
function replaceTypeString(type, aliasConfig) {
    const alias = getMatchingAliasForType(type, aliasConfig);
    if (!alias) {
        return type;
    }
    else {
        const { matchPattern, replacePattern } = alias;
        const wildcardValue = getWildcardValue(type, matchPattern);
        return type.replace(matchPattern.replace(STAR_WILDCARD, wildcardValue), replacePattern.replace(STAR_WILDCARD, wildcardValue));
    }
}
exports.replaceTypeString = replaceTypeString;
function generateImports(importsMap, alias) {
    const mergedImportMaps = mergeImports(importsMap);
    return mergedImportMaps.map(([name, importees]) => {
        let defaultSpecifier;
        const namedSpecifiers = [];
        for (const [imported, local] of importees.entries()) {
            if (imported === 'default') {
                defaultSpecifier = local;
            }
            else {
                namedSpecifiers.push(`${imported} as ${local}`);
            }
        }
        let specifiers = '';
        if (defaultSpecifier)
            specifiers += defaultSpecifier;
        if (namedSpecifiers.length) {
            if (specifiers.length)
                specifiers += ', ';
            specifiers += `{ ${namedSpecifiers.join(', ')} }`;
        }
        return `import ${specifiers} from '${replaceTypeString(name, alias)}';`;
    });
}
exports.generateImports = generateImports;
/**
 * Impure function that updates the context object from the imports data.
 *
 * @param context compose statement context object
 * @param imports imports data used to update the context's imports
 */
function addMissingImportsFromStatementsArgs(context, imports) {
    for (const i of imports) {
        const { moduleSpecifier, name, destination, defaultImport } = i;
        const importIdentifier = addImport(moduleSpecifier, name, context.importsDestination[destination], defaultImport);
        // update the class body _byIdentifier if not already set
        // for instance, non root PO that expose only a compose method that uses CSS locator arguments
        if (name === shared_1.UTAM_LOCATOR_BY && !context.typeIdentifiers._byIdentifier) {
            context.typeIdentifiers._byIdentifier = importIdentifier;
        }
    }
}
exports.addMissingImportsFromStatementsArgs = addMissingImportsFromStatementsArgs;
//# sourceMappingURL=imports.js.map