"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSelectorValue = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const diagnostics_1 = require("@utam/diagnostics");
const errors_1 = require("../utils/errors");
const SINGLE_DOLLARSIGN = '$';
const SINGLE_BACKTICK = '`';
/**
 * Returns a set of the supported operators values
 */
class MobileSelectorOperator {
    constructor(value) {
        this.value = value;
    }
    static get operators() {
        return new Set(Object.values(this).map(({ value }) => value));
    }
}
/**
 * Represents all supported classchain predicates operators
 * @link https://appium.io/docs/en/writing-running-appium/ios/ios-predicate/
 */
class ClasschainOperator extends MobileSelectorOperator {
}
ClasschainOperator.EQUALS = new ClasschainOperator('==');
ClasschainOperator.BEGINSWITH = new ClasschainOperator('BEGINSWITH');
ClasschainOperator.ENDSWITH = new ClasschainOperator('ENDSWITH');
ClasschainOperator.CONTAINS = new ClasschainOperator('CONTAINS');
ClasschainOperator.OR = new ClasschainOperator('OR');
ClasschainOperator.AND = new ClasschainOperator('AND');
/**
 * Represents all support uiautomator uiselectors
 * @link - https://developer.android.com/reference/androidx/test/uiautomator/UiSelector
 */
class UiautomatorSelectors extends MobileSelectorOperator {
}
UiautomatorSelectors.CHECKABLE = new UiautomatorSelectors('checkable');
UiautomatorSelectors.CHECKED = new UiautomatorSelectors('checked');
UiautomatorSelectors.CLASSNAME = new UiautomatorSelectors('className');
UiautomatorSelectors.DESCRIPTION = new UiautomatorSelectors('description');
UiautomatorSelectors.DESCRIPTIONCONTAINS = new UiautomatorSelectors('descriptionContains');
UiautomatorSelectors.DESCRIPTIONSTARTSWITH = new UiautomatorSelectors('descriptionStartsWith');
UiautomatorSelectors.ENABLED = new UiautomatorSelectors('enabled');
UiautomatorSelectors.SELECTED = new UiautomatorSelectors('selected');
UiautomatorSelectors.RESOURCEID = new UiautomatorSelectors('resourceId');
UiautomatorSelectors.RESOURCEIDMATCHES = new UiautomatorSelectors('resourceIdMatches');
/**
 * Route a selector value to it's appropriate validation routine depending on it's type
 * @param selectorType type of the selector
 * @param selectorValue value of the selector coming from the JSON
 */
function validateSelectorValue(selectorType, selectorValue) {
    switch (selectorType) {
        case 'classchain':
            validClassChain(selectorValue);
            break;
        case 'uiautomator':
            validateUiAutomator(selectorValue);
            break;
        case 'css':
            validateCssSelector(selectorValue);
            break;
    }
}
exports.validateSelectorValue = validateSelectorValue;
/**
 * Routine for validating the supplied classchain string
 * @param classchain locator string
 */
function validClassChain(classchain) {
    classchain.split('/').forEach(validateSubClassChainSelector);
}
/**
 * Validate claschain string for square brackets,single quotes and other classchain operators
 * @param classchain locator string
 */
function validateSubClassChainSelector(classchain) {
    if (classchain.includes('[')) {
        const classchainSubStr = classchain.substring(classchain.indexOf('[') + 1, classchain.indexOf(']'));
        if (!/\d/.test(classchainSubStr)) {
            validateQuote(classchainSubStr);
            validateOperator(classchainSubStr);
        }
    }
}
/**
 * Validate classchain string for quotes and dollar signs
 * @param classchain locator string
 * @throws {UtamValidationError} Classchain validation error when invalid quotes are used in the selector.
 */
function validateQuote(classchain) {
    if (!classchain.startsWith(SINGLE_BACKTICK.toString()) && !classchain.startsWith(SINGLE_DOLLARSIGN.toString())) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.SELECTOR.CLASS_CHAIN_INVALID_QUOTES());
    }
}
/**
 * Validate classchain string for supported predicate operators
 * @param classchain locator string
 * @throws {UtamValidationError} Classchain validation error when invalid operators
 */
function validateOperator(classchain) {
    const classchainQuery = classchain.split(' ');
    const classChainOperators = ClasschainOperator.operators;
    if (classchainQuery.length < 3) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.SELECTOR.CLASS_CHAIN_INVALID_OPERATORS(classchain, classChainOperators));
    }
    if (!classchainQuery
        .filter((subString) => subString === ClasschainOperator.EQUALS.value || /^[A-Z]+$/g.test(subString))
        .every((operator) => classChainOperators.has(operator))) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.SELECTOR.CLASS_CHAIN_INVALID_OPERATORS(classchain, classChainOperators));
    }
}
/**
 * Validate uiautomator string against supported uiautomator methods
 * @param uiautomator locator string
 * @throws {UtamValidationError} Uiautomator validation error when supplied string is either in incorrect
 * format or is not part of supported methods list.
 */
function validateUiAutomator(uiautomator) {
    const { operators: uiAutomatorMethods } = UiautomatorSelectors;
    validateUiAutomatorMethods(validateUISelector(validateScrollable(uiautomator, uiAutomatorMethods)));
}
function validateScrollable(locator, uiAutomatorMethods) {
    if (!locator.startsWith('new UiScrollable')) {
        return { locator, uiAutomatorMethods };
    }
    const SCROLLABLE = 'scrollable';
    const innerLocator = locator.split('.')[1].split('(')[0];
    if (innerLocator !== SCROLLABLE) {
        if (!uiAutomatorMethods.has(innerLocator)) {
            throw new errors_1.UtamValidationError(diagnostics_1.descriptions.SELECTOR.UIAUTOMATOR_UNSUPPORTED_METHOD(locator, uiAutomatorMethods));
        }
    }
    const innerMethod = locator.substring(locator.indexOf('))') + 3);
    return { locator: innerMethod.substring(innerMethod.indexOf('(') + 1), uiAutomatorMethods };
}
function validateUISelector({ locator, uiAutomatorMethods }) {
    if (!locator.startsWith('new UiSelector')) {
        return { locator, uiAutomatorMethods };
    }
    return { locator: locator.substring(locator.indexOf('.') + 1), uiAutomatorMethods };
}
/**
 * Validate uiautomator string against supported uiautomator methods
 * @param locator locator string
 * @param uiAutomatorMethods saleforce supported uiAutomator methods
 * @throws {UtamValidationError} Uiautomator validation error when supplied string is either in incorrect
 */
function validateUiAutomatorMethods({ locator, uiAutomatorMethods }) {
    const resourceLocator = locator.split('(')[0];
    if (!uiAutomatorMethods.has(resourceLocator)) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.SELECTOR.UIAUTOMATOR_UNSUPPORTED_METHOD(locator, uiAutomatorMethods));
    }
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function validateCssSelector(cssSelector) {
    // TODO implement
}
//# sourceMappingURL=selector-type-validation.js.map