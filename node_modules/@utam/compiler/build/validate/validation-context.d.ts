import { ArgumentType } from '@utam/types';
import { Node } from 'jsonc-parser';
import { SupportedArgsType } from '../utils/args';
import { ActionArgument } from '../utils/element-actions';
export declare type ElementNodeType = 'basic' | 'container' | 'custom' | 'frame';
/**
 * context of an element including its name, type, cardinality and expected parameter types
 */
export declare class ElementContext {
    name: string;
    nodeType: ElementNodeType;
    elementType: string | string[];
    isList: boolean;
    private expectedArgs;
    constructor(name: string, nodeType: ElementNodeType, elementType: string | string[], isList: boolean);
    /**
     * expected types of args for an element including selector and filter
     * @returns array of type names for args
     */
    getExpectedTypes(): Array<ArgumentType>;
    /**
     * set expected args types for an element
     * @param types set expected args types for an element
     */
    addExpectedArgTypes(types: ArgumentType[]): void;
}
/**
 * traversal context created per each validated Page Object
 * accumulates information about elements and provides validations across different nodes
 */
export declare class Context {
    private visitedElements;
    private visitedMethods;
    /** Indicates if the page object was declared as an interface (interface: true in the root scope) */
    isInterface: boolean;
    addUniqueElement(elementContext: ElementContext): boolean;
    addUniqueMethod(name: string): boolean;
    getElementContext(name: string): ElementContext | undefined;
}
/**
 * Represents a decorated statement with context information used to validate returnTypes
 */
export declare class StatementContext {
    isLast: boolean;
    isNextStatementChain: boolean;
    statementNode: Node;
    constructor(statementNode: Node, isLast: boolean, nextIsChain: boolean);
}
/**
 * Traversal context for statements (in compose method or in beforeLoad). This class decorates the statement nodes
 * object with properties that add some context around the statement. This is used for the validation of the returnType
 * in statements that can require information about siblings statements (n +/- 1).
 */
export declare class StatementsContext {
    statementsContext: StatementContext[];
    constructor(statementNodes: Node[]);
    private isNextStatementChain;
}
declare type MethodType = 'beforeLoad' | 'compose';
/**
 * Validation context of compose or beforeLoad method
 */
export interface MethodValidationContext {
    methodName: string;
    methodType: MethodType;
    methodArgsMap: Map<string, Node>;
}
/**
 * Validation context of "args" array, can be inside element (selector or filter) or method
 */
export interface ArgsValidationContext {
    context: Context;
    structure: string;
    supports: SupportedArgsType;
    methodContext?: MethodValidationContext;
    expectedTypes?: ActionArgument[];
    elementContext?: ElementContext;
}
/**
 * Selector validation context, can be inside method (as "apply" parameter) or element
 */
export interface SelectorValidationContext {
    parserContext: string;
    context: Context;
    methodContext?: MethodValidationContext;
    elementContext?: ElementContext;
}
/**
 * Combines Page Object context, structure and position in JSON
 */
export interface StructureContext {
    context: Context;
    structure: string;
    position?: {
        offset: number;
    };
}
export {};
//# sourceMappingURL=validation-context.d.ts.map