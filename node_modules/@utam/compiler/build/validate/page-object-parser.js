"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTree = exports.isUtamParseError = exports.isParseError = exports.createUtamParseError = void 0;
const jsonc_parser_1 = require("jsonc-parser");
const errors_1 = require("../utils/errors");
const UTAM_CUSTOM_PARSE_ERROR_CODE = 17;
/**
 * Wrap errors into UtamParseError to add context around parsing errors
 * @param err either an error coming from the jsonc-parser or an error throwed by the visitor function
 * @returns an error with context representing a UTAM parse error
 */
function createUtamParseError(err) {
    if (isParseError(err)) {
        const { error, offset, length } = err;
        const message = jsonc_parser_1.printParseErrorCode(error);
        return {
            error,
            message,
            isInvalidPageObjectError: false,
            offset,
            length,
        };
    }
    else {
        const { message, position } = err;
        const { offset, length = 0 } = position;
        return {
            error: UTAM_CUSTOM_PARSE_ERROR_CODE,
            message,
            isInvalidPageObjectError: true,
            offset,
            length,
        };
    }
}
exports.createUtamParseError = createUtamParseError;
/**
 * User defined type guard to narrow errors down to ParseError
 * @param err any error that needs some narrowing
 * @returns type predicate indicating if the error is a ParseError
 */
function isParseError(err) {
    return 'error' in err && typeof err.error === 'number';
}
exports.isParseError = isParseError;
/**
 * User defined type guard to narrow errors down to UtamParseError
 * @param err any error that needs some narrowing
 * @returns type predicate indicating if the error is a UtamParseError
 */
function isUtamParseError(err) {
    return 'isInvalidPageObjectError' in err;
}
exports.isUtamParseError = isUtamParseError;
/**
 * Facade function that augment the parseTree function from jsonc-parser to invalidate JSON
 * objects with duplicated keys in the same scope.
 *
 * @param jsonSourceText json page object to validate
 * @param errors errors objects returned by the visitor or via the jsonc-parser parseTree function
 * @param options configuration object to configure the behavior of the facade function
 * @returns the root node object if the text has been successfully parsed
 */
function parseTree(jsonSourceText, errors, options = { disallowDuplicatedKeys: true, disallowInlineComments: true }) {
    try {
        const visitor = new PageObjectsVisitor(options);
        jsonc_parser_1.visit(jsonSourceText, visitor);
    }
    catch (err) {
        errors.push(createUtamParseError(err));
    }
    return jsonc_parser_1.parseTree(jsonSourceText, errors);
}
exports.parseTree = parseTree;
/**
 * Visitor object used to detect duplicated key tokens in the same context
 */
class PageObjectsVisitor {
    /**
     * Creates a new Visitor object and binds methods implemented from JSONVisitor to the current object
     * @param options parser configuration object
     */
    constructor(options) {
        this.scopes = [];
        this.visitedKeys = new Set();
        this.structure = ['root'];
        this.newNestedContext = false;
        this.parserOptions = options;
        this.onObjectBegin = this.onObjectBegin.bind(this);
        this.onObjectEnd = this.onObjectEnd.bind(this);
        this.onObjectProperty = this.onObjectProperty.bind(this);
        this.onComment = this.onComment.bind(this);
    }
    /**
     * Callback function triggered when parsing comments tokens
     * @param offset offset of the key token
     * @param length key length
     */
    onComment(offset, length) {
        if (this.parserOptions.disallowInlineComments) {
            const message = `Inline comments are not allowed, use the 'description' property instead`;
            throw new errors_1.UtamJsonValidationError({
                message,
                position: { offset, length },
            });
        }
    }
    /** Callback function triggered when parsing a '{' token */
    onObjectBegin() {
        this.scopes.push(new Set());
        this.visitedKeys = this.scopes[this.scopes.length - 1];
        // We set newNestedContext to true after visited the first property
        if (this.structure.length > 1)
            this.newNestedContext = false;
    }
    /** Callback function triggered when parsing a '}' token */
    onObjectEnd() {
        this.scopes.pop();
        this.visitedKeys = this.scopes[this.scopes.length - 1];
        this.structure.pop();
    }
    /**
     * Callback function triggered when parsing a new key
     * @param property visited key token
     * @param offset offset of the key token
     * @param length key length
     */
    onObjectProperty(property, offset, length) {
        if (this.parserOptions.disallowDuplicatedKeys && this.visitedKeys.has(property)) {
            // We don't keep the last item in the array to stop at the parent
            // of the duplicated key
            const structurePath = this.structure.slice(0, -1).join(' > ');
            const message = `Duplicate "${property}" keys in ${structurePath}`;
            throw new errors_1.UtamJsonValidationError({
                message,
                position: { offset, length },
            });
        }
        else {
            this.visitedKeys.add(property);
            this.updateStructure(property);
        }
    }
    /**
     * Utility function that updates the structure depending on the context the visitor is in.
     * This function store the context hierarchy in the structure field
     *
     * @property current key being visited
     */
    updateStructure(property) {
        if (!this.newNestedContext) {
            this.structure.push(property);
            this.newNestedContext = true;
        }
        else {
            this.structure[this.structure.length - 1] = property;
        }
    }
}
//# sourceMappingURL=page-object-parser.js.map