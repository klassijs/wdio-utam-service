"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePageObject = void 0;
const diagnostics_1 = require("@utam/diagnostics");
const jsonc_parser_1 = require("jsonc-parser");
const shared_1 = require("../codegen/shared");
const args_1 = require("../utils/args");
const element_actions_1 = require("../utils/element-actions");
const errors_1 = require("../utils/errors");
const matchers_1 = require("../utils/matchers");
const primitive_arguments_1 = require("../utils/primitive-arguments");
const element_types_1 = require("../utils/element-types");
const validation_context_1 = require("../validate/validation-context");
const selector_type_validation_1 = require("./selector-type-validation");
const page_object_parser_1 = require("./page-object-parser");
const assertions_1 = require("./assertions");
const ROOT_PROPERTIES = [
    'root',
    'interface',
    'implements',
    'profile',
    'platform',
    'selector',
    'elements',
    'shadow',
    'methods',
    'type',
    'exposeRootElement',
    'beforeLoad',
    'description',
    'metadata',
];
const INTERFACE_PROPERTIES = [
    'root',
    'interface',
    'methods',
    'type',
    'exposeRootElement',
    'description',
    'metadata',
];
const SELECTOR_PROPERTIES = [
    'accessid',
    'classchain',
    'css',
    'uiautomator',
    'args',
    'returnAll',
];
const ROOT_SELECTOR_PROPERTIES = ['accessid', 'classchain', 'css', 'uiautomator'];
const ELEMENT_PROPERTIES = [
    'elements',
    'filter',
    'name',
    'public',
    'selector',
    'nullable',
    'shadow',
    'type',
    'description',
];
const FRAME_ELEMENT_SELECTOR_PROPERTIES = [
    'accessid',
    'classchain',
    'css',
    'uiautomator',
    'args',
];
const FRAME_ELEMENT_PROPERTIES = [
    'name',
    'public',
    'selector',
    'type',
    'description',
];
const FILTER_PROPERTIES = ['matcher', 'apply', 'args', 'findFirst'];
const FILTER_MATCHER_PROPERTIES = ['args', 'type'];
const METHOD_ACTION_PROPERTIES = [
    'element',
    'apply',
    'args',
    'matcher',
    'applyExternal',
    'chain',
    'returnAll',
    'returnType',
];
const UTILITY_STATEMENT_PROPERTIES = [
    'applyExternal',
    'element',
    'returnAll',
    'returnType',
];
const RETURN_SELF_STATEMENT_PROPERTIES = ['apply'];
const METHOD_PROPERTIES = ['name', 'compose', 'args', 'description'];
const INTERFACE_METHOD_PROPERTIES = [
    'name',
    'args',
    'returnType',
    'returnAll',
    'description',
];
const ARGS_PROPERTIES = ['type', 'name', 'value', 'predicate', 'args', 'description'];
const UTAM_CONTAINER_ELEMENT_TYPE = 'container';
const UTAM_FRAME_ELEMENT_TYPE = 'frame';
const UTAM_BASIC_ELEMENT_TYPE = new Set([
    'actionable',
    'clickable',
    'editable',
    'draggable',
    'touchable',
]);
const UTAM_NAVIGATION_ACTIONS = new Set(['back', 'forward']);
const SUPPORTED_MATCHERS = ['isTrue', 'isFalse', 'notNull', 'stringContains', 'stringEquals'];
const SUPPORTED_MOBILE_CONTEXT_TYPE = new Set(['web', 'native']);
const ROOT_ELEMENT_NAME = 'root';
const DOCUMENT_OBJECT_NAME = 'document';
const ROOT_DESCRIPTION_PROPERTIES = ['text', 'author', 'deprecated'];
const METHOD_DESCRIPTION_PROPERTIES = ['text', 'return', 'deprecated', 'throws'];
/**
 * Validation routine used to ensure that a property that takes a finite set of string
 * has a value in that set
 *
 * @param structure enclosing structure name
 * @param parentNode parsed parent node from the JSON document
 * @param propertyName name of the property being validated
 * @param supportedValues finite set of valid values for the property
 */
function assertValueInSet(structure, parentNode, propertyName, supportedValues) {
    const node = jsonc_parser_1.findNodeAtLocation(parentNode, [propertyName]);
    if (node) {
        const { type, offset, value } = node;
        if (type !== 'string') {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.INVALID_TYPE_FOR_VALUE(propertyName, structure, 'string', type, {
                offset,
            }));
        }
        else if (!supportedValues.has(value)) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ROOT.PLATFORM_INVALID_VALUE(value, supportedValues, {
                offset,
            }));
        }
    }
}
function assertBooleanProperty(structure, parentNode, propertyName, defaultValue) {
    const node = jsonc_parser_1.findNodeAtLocation(parentNode, [propertyName]);
    if (!node) {
        return defaultValue;
    }
    if (node && node.type !== 'boolean') {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.INVALID_TYPE_FOR_VALUE(propertyName, structure, 'boolean', node.type, {
            offset: node.offset,
        }));
    }
    return node.value;
}
// return property indicating element's type, used later in validations
function assertValidElementType(type) {
    if (element_types_1.isCustomTypePredicate(type)) {
        if (!element_types_1.VALID_CUSTOM_TYPE.test(type)) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.INVALID_CUSTOM_TYPE(type));
        }
        return 'custom';
    }
    else if (UTAM_CONTAINER_ELEMENT_TYPE === type) {
        return 'container';
    }
    else if (UTAM_FRAME_ELEMENT_TYPE === type) {
        return 'frame';
    }
    else if (UTAM_BASIC_ELEMENT_TYPE.has(type)) {
        return 'basic';
    }
    else {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.INVALID_ELEMENT_TYPE(type, UTAM_BASIC_ELEMENT_TYPE));
    }
}
// return property indicating element's type, used later in validations
// TODO update the error message if needed
function assertValidBasicElementTypes(basicElementType, name) {
    if (!Array.isArray(basicElementType)) {
        if (!UTAM_BASIC_ELEMENT_TYPE.has(basicElementType)) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.INVALID_BASIC_ELEMENT_TYPE(basicElementType, UTAM_BASIC_ELEMENT_TYPE));
        }
    }
    else {
        const visitedElementTypes = new Set();
        for (const type of basicElementType) {
            if (!UTAM_BASIC_ELEMENT_TYPE.has(type)) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.INVALID_BASIC_ELEMENT_TYPE(type, UTAM_BASIC_ELEMENT_TYPE));
            }
            if (visitedElementTypes.has(type)) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.DUPLICATE_BASIC_TYPE(type, name));
            }
            visitedElementTypes.add(type);
        }
    }
    return 'basic';
}
function assertElementIsNestable(structureContext, elementContext) {
    const { structure, position } = structureContext;
    if (elementContext.isList) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.LIST_CANNOT_HAVE_NESTED_ELEMENTS(structure, position));
    }
    if (elementContext.nodeType !== 'basic') {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.ONLY_BASIC_TYPE_CAN_HAVE_NESTED_ELEMENTS(structure, position));
    }
}
function assertValidKeys(node, structure, properties) {
    if (node.children) {
        for (const propertyNode of node.children) {
            if (propertyNode.type === 'property' && propertyNode.children) {
                const [keyNode] = propertyNode.children;
                const { type, value, offset, length } = keyNode;
                if (type === 'string' && !properties.includes(value)) {
                    throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.INVALID_PROPERTY_KEY(value, structure, properties, { offset, length }));
                }
            }
        }
    }
}
function validateLiteralValue(structureContext, valueNode, typeNode, expectedType, methodContext, elementContext) {
    const position = { offset: valueNode.offset };
    const { structure, context } = structureContext;
    const valueType = valueNode.type;
    const parserContext = `${structure}, argument "selector"`;
    if (valueType === 'object') {
        if (expectedType) {
            if (expectedType !== 'locator') {
                // unknown object type in "value"
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.INVALID_TYPE_FOR_VALUE('value', structure, expectedType, 'object', position));
            }
            if (!typeNode) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.MISSING_REQUIRED_TYPE_KEY_LITERAL_ARG(structure, expectedType, position));
            }
        }
        // at the moment selector is the only supported object type node for "value"
        assertions_1.assertIsObject(valueNode, structure, 'property "selector"');
        validateSelector({ context, methodContext, elementContext, parserContext }, valueNode);
        return 'locator';
    }
    if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.INVALID_TYPE_FOR_VALUE('value', structure, 'string | boolean | number', valueType, position));
    }
    if (expectedType) {
        if (['elementReference', 'pageObject', 'rootPageObject'].includes(expectedType)) {
            if (!typeNode) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.MISSING_REQUIRED_TYPE_KEY_LITERAL_ARG(structure, expectedType, position));
            }
        }
        if (expectedType === 'elementReference' && valueType === 'string') {
            return 'elementReference';
        }
        if (expectedType !== valueType) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.generation.ARGS.INCORRECT_TYPE(structure, jsonc_parser_1.getNodeValue(valueNode), expectedType, valueType, position));
        }
    }
    return valueType;
}
function validateElementReference(argNode, argContext, elementName) {
    const { structure, supports, context, methodContext } = argContext;
    const position = { offset: argNode.offset };
    if (args_1.isValueNotAllowed(supports)) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.VALUE_NOT_SUPPORTED(structure, position));
    }
    const elementContext = context.getElementContext(elementName);
    if (!elementContext) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.METHOD.NONEXISTENT_ELEMENT_REFERENCE(structure, elementName, position));
    }
    const nestedArgs = jsonc_parser_1.findNodeAtLocation(argNode, ['args']);
    const expectedTypes = nestedArgs
        ? elementContext.getExpectedTypes().map((type) => {
            return {
                required: true,
                type,
            };
        })
        : [];
    validateArguments(nestedArgs, {
        structure: `element reference '${elementName}' in ${structure}`,
        supports: 'onlyValues',
        methodContext,
        context,
        expectedTypes,
    });
}
function validatePredicateArgument(predicateNode, validationContext) {
    const { structure, context, methodContext } = validationContext;
    const statementStructure = `${structure} predicate`;
    if (!methodContext) {
        throw new Error('Compiler error: predicate needs method context');
    }
    if (predicateNode.children) {
        const { statementsContext } = new validation_context_1.StatementsContext(predicateNode.children);
        for (const statementContext of statementsContext) {
            const { statementNode } = statementContext;
            assertions_1.assertIsArrayMemberObject(statementNode, structure, 'predicate');
            validateComposeObject(context, statementContext, statementStructure, methodContext);
        }
    }
}
function getArgumentTypeAsString(structure, typeNode, nameValue, methodContext) {
    if (!typeNode) {
        return undefined;
    }
    assertions_1.assertNotEmptyString(typeNode, structure, 'type');
    const typeValue = jsonc_parser_1.getNodeValue(typeNode);
    if (typeValue === 'argumentReference') {
        if (!nameValue) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('name', structure));
        }
        if (!methodContext) {
            throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ARGS.NONEXISTENT_ARGUMENT_REFERENCE(structure, nameValue));
        }
        const referencedType = args_1.getReferencedArgument(nameValue, methodContext.methodArgsMap);
        if (!referencedType) {
            throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ARGS.NONEXISTENT_ARGUMENT_REFERENCE(structure, nameValue));
        }
        return referencedType;
    }
    return typeValue;
}
function validateArguments(argsNode, validationContext) {
    const types = [];
    const { expectedTypes, structure, supports, context, methodContext } = validationContext;
    const requiredExpectedTypes = expectedTypes ? expectedTypes.filter(({ required }) => required) : [];
    const expectedArgs = requiredExpectedTypes.length;
    if (argsNode) {
        const position = { offset: argsNode.offset };
        if (expectedTypes && expectedTypes.length == 0) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REDUNDANT_PROPERTY_KEY_FOR_STRUCTURE('args', structure, position));
        }
        assertions_1.assertOptionalNotEmptyArray(argsNode, structure, 'args');
        if (argsNode.children) {
            // validate that the action don't declares more args than it takes (required + optional)
            if (expectedTypes && expectedTypes.length < argsNode.children.length) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.generation.ARGS.INCORRECT_COUNT(structure, expectedTypes.length, argsNode.children.length));
            }
            // Validate that the action declares all required args
            if (requiredExpectedTypes.length > argsNode.children.length) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.generation.ARGS.INCORRECT_COUNT(structure, expectedArgs, argsNode.children.length));
            }
            const parserContext = `${structure} argument`;
            for (let i = 0; i < argsNode.children.length; i++) {
                const argNode = argsNode.children[i];
                const expectedType = expectedTypes ? expectedTypes[i].type : undefined;
                assertions_1.assertIsArrayMemberObject(argNode, structure, `argument`);
                assertValidKeys(argNode, structure, ARGS_PROPERTIES);
                const valueNode = jsonc_parser_1.findNodeAtLocation(argNode, ['value']);
                const typeNode = jsonc_parser_1.findNodeAtLocation(argNode, ['type']);
                const nameNode = jsonc_parser_1.findNodeAtLocation(argNode, ['name']);
                if (nameNode) {
                    assertions_1.assertNotEmptyString(nameNode, structure, 'name');
                }
                const nameValue = nameNode ? jsonc_parser_1.getNodeValue(nameNode) : undefined;
                const typeValue = getArgumentTypeAsString(structure, typeNode, nameValue, methodContext);
                const nestedArgsNode = jsonc_parser_1.findNodeAtLocation(argNode, ['args']);
                const predicateNode = jsonc_parser_1.findNodeAtLocation(argNode, ['predicate']);
                const descriptionNode = jsonc_parser_1.findNodeAtLocation(argNode, ['description']);
                if (typeValue === 'function') {
                    const predicateNode = assertions_1.assertNotEmptyArray(argNode, validationContext.structure, 'predicate');
                    validatePredicateArgument(predicateNode, validationContext);
                    if (valueNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.REDUNDANT_KEYS('value'));
                    }
                    if (nestedArgsNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.UNSUPPORTED_NESTED_ARGS(structure, position));
                    }
                    if (args_1.isValueNotAllowed(supports)) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.VALUE_NOT_SUPPORTED(structure, position));
                    }
                    if (descriptionNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.DESCRIPTION_NOT_SUPPORTED(position));
                    }
                    types.push('function');
                }
                else if (valueNode) {
                    if (args_1.isValueNotAllowed(supports)) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.VALUE_NOT_SUPPORTED(structure, position));
                    }
                    if (nameNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.REDUNDANT_KEYS('name'));
                    }
                    if (predicateNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.REDUNDANT_KEYS('predicate'));
                    }
                    if (descriptionNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.DESCRIPTION_NOT_SUPPORTED(position));
                    }
                    if (typeValue === 'elementReference') {
                        assertions_1.assertNotEmptyString(valueNode, structure, 'value');
                        validateElementReference(argNode, validationContext, jsonc_parser_1.getNodeValue(valueNode));
                    }
                    else if (nestedArgsNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.UNSUPPORTED_NESTED_ARGS(structure, position));
                    }
                    types.push(validateLiteralValue({ context, structure }, valueNode, typeNode, expectedType, methodContext));
                }
                else {
                    if (args_1.isOnlyValueAllowed(supports)) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.ONLY_VALUE_SUPPORTED(structure, position));
                    }
                    if (!typeValue) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('type', structure));
                    }
                    if (!nameValue) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('name', structure));
                    }
                    if (nestedArgsNode) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ARGS.UNSUPPORTED_NESTED_ARGS(structure, position));
                    }
                    if (expectedType && !args_1.isSameArgumentType(expectedType, typeValue)) {
                        throw new errors_1.UtamSchemaValidationError(diagnostics_1.generation.ARGS.INCORRECT_TYPE(structure, nameValue, expectedType, typeValue));
                    }
                    if (descriptionNode) {
                        assertions_1.assertNotEmptyString(descriptionNode, parserContext, 'description');
                    }
                    types.push(typeValue);
                }
            }
        }
    }
    else if (expectedArgs > 0) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.generation.ARGS.INCORRECT_COUNT(structure, expectedArgs, 0));
    }
    return types;
}
/**
 * validate selector type
 *
 * @param structure string passed usually as "selector"
 * @param selectorNode JSON node
 * @returns selector type and node
 */
function validateSelectorStrategy(structure, selectorNode) {
    const declaredSelectorStrategies = new Map();
    const supportedSelectorStrategies = ['accessid', 'classchain', 'css', 'uiautomator'];
    const position = { offset: selectorNode.offset };
    for (const selectorStrategy of supportedSelectorStrategies) {
        const selectorStrategyNode = jsonc_parser_1.findNodeAtLocation(selectorNode, [selectorStrategy]);
        if (selectorStrategyNode) {
            declaredSelectorStrategies.set(selectorStrategy, selectorStrategyNode);
        }
    }
    if (declaredSelectorStrategies.size === 0) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.SELECTOR.VALUE_CANT_BE_EMPTY(structure, supportedSelectorStrategies, position));
    }
    else if (declaredSelectorStrategies.size > 1) {
        // Duplicated selector strategies the offset starts at the first declared key
        const { offset } = [...declaredSelectorStrategies.values()][0];
        const position = { offset };
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.SELECTOR.DUPLICATE_SELECTOR_STRATEGIES([...declaredSelectorStrategies.keys()], supportedSelectorStrategies, position));
    }
    else {
        const [selectorStrategy, selectorStrategyNode] = [...declaredSelectorStrategies.entries()][0];
        assertions_1.assertNotEmptyString(selectorStrategyNode, structure, selectorStrategy);
        return { selectorType: selectorStrategy, selectorValue: selectorStrategyNode };
    }
}
function validateSelector(selectorContext, selectorNode) {
    const { context, elementContext, methodContext } = selectorContext;
    const isFrameElement = elementContext?.nodeType === 'frame';
    const isRootElement = elementContext?.name === ROOT_ELEMENT_NAME;
    const VALID_SELECTOR_PROPERTIES = isRootElement
        ? ROOT_SELECTOR_PROPERTIES
        : isFrameElement
            ? FRAME_ELEMENT_SELECTOR_PROPERTIES
            : SELECTOR_PROPERTIES;
    const structure = selectorContext.parserContext;
    assertValidKeys(selectorNode, structure, VALID_SELECTOR_PROPERTIES);
    const { selectorType, selectorValue } = validateSelectorStrategy(structure, selectorNode);
    const selectorString = jsonc_parser_1.getNodeValue(selectorValue);
    selector_type_validation_1.validateSelectorValue(selectorType, selectorString);
    const selectorStringArgs = primitive_arguments_1.getSelectorArgTypesFromString(selectorString);
    const expectedTypes = selectorStringArgs.map((argType) => {
        return { required: true, type: argType };
    });
    //remember selector args for an element
    if (elementContext) {
        elementContext.addExpectedArgTypes(selectorStringArgs);
    }
    const argsNode = jsonc_parser_1.findNodeAtLocation(selectorNode, ['args']);
    // values are not allowed - does not make sense to have hardcoded selector with '%s'/'%d' and values
    validateArguments(argsNode, {
        context,
        structure: `${selectorContext.parserContext} arguments`,
        supports: 'onlyNameType',
        methodContext,
        expectedTypes,
    });
    if (!isFrameElement) {
        assertBooleanProperty(structure, selectorNode, 'returnAll', false);
    }
}
function validateProfile(profileNode, tracker) {
    if (profileNode.children && profileNode.children.length === 1) {
        const nameNode = profileNode.children[0];
        if (nameNode.type === 'property' && nameNode.children && nameNode.children.length === 2) {
            const name = nameNode.children[0].value;
            if (tracker.has(name)) {
                throw new errors_1.UtamCompilerValidationError(profileNode, 801, [name]);
            }
            tracker.add(name);
            const valuesNode = nameNode.children[1];
            if (valuesNode.type === 'array') {
                assertions_1.assertOptionalNotEmptyArray(valuesNode, 'root', `profile "${name}"`);
                if (valuesNode.children) {
                    const valuesTracker = new Set();
                    for (const valueNode of valuesNode.children) {
                        const valueStr = assertions_1.assertNotEmptyString(valueNode, `profile "${name}"`, 'value');
                        if (valuesTracker.has(valueStr)) {
                            throw new errors_1.UtamCompilerValidationError(profileNode, 802, [name, valueStr]);
                        }
                        valuesTracker.add(valueStr);
                    }
                }
            }
            else if (valuesNode.type !== 'string') {
                throw new errors_1.UtamCompilerValidationError(profileNode, 806, [name]);
            }
        }
        else {
            throw new errors_1.UtamCompilerValidationError(profileNode, 800);
        }
    }
    else {
        throw new errors_1.UtamCompilerValidationError(profileNode, 800);
    }
}
function validateReturnType(methodName, structureContext, statementContext) {
    const { structure, position } = structureContext;
    const { statementNode: composeObjectNode, isNextStatementChain } = statementContext;
    const returnTypeNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['returnType']);
    const returnAllNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['returnAll']);
    if (returnTypeNode) {
        assertions_1.assertNotEmptyString(returnTypeNode, structure, 'returnType');
        const returnTypeNodeValue = jsonc_parser_1.getNodeValue(returnTypeNode);
        if (!isValidReturnType(returnTypeNodeValue)) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.METHOD.UNSUPPORTED_RETURN_TYPE_VALUE(structure, returnTypeNodeValue, position));
        }
        if (isNextStatementChain && !element_types_1.isCustomTypePredicate(returnTypeNodeValue)) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.METHOD.INVALID_RETURN_TYPE_NEXT_STATEMENT_IS_CHAIN(structure, position));
        }
        if (returnAllNode) {
            assertBooleanProperty(structure, composeObjectNode, 'returnAll', false);
        }
    }
    else if (returnAllNode) {
        throw new errors_1.UtamCompilerValidationError(returnAllNode, 603, [methodName]);
    }
}
function validateAppliedAction(structureContext, elementContext, apply) {
    const action = element_actions_1.buildActionByName(apply, elementContext.elementType);
    const { structure, position } = structureContext;
    if (!action) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ACTION.UNKNOWN_APPLICABLE_METHOD(structure, apply, elementContext.elementType, position));
    }
    if (!action.external && !element_actions_1.isActionApplicableForTypes(action, elementContext.elementType)) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ACTION.INVALID_APPLICABLE_TYPE(structure, action.applyFunction, action.applicableTo, position));
    }
    if (!element_actions_1.isCorrectElementCardinality(action, elementContext.isList)) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ACTION.APPLICABLE_ONLY_TO_LIST(structure, action.applyFunction, position));
    }
    return action;
}
/**
 * custom element filter has matcher object, args and apply
 * @param structure context of validation
 * @param filterNode node
 */
function validateElementFilter(structureContext, elementContext, filterNode) {
    const position = { offset: filterNode.offset };
    const { structure, context } = structureContext;
    const applyNode = jsonc_parser_1.findNodeAtLocation(filterNode, ['apply']);
    if (!applyNode) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('apply', structure, position));
    }
    const action = validateAppliedAction({ structure, position, context }, elementContext, jsonc_parser_1.getNodeValue(applyNode));
    const matcherNode = assertions_1.assertNotNullObject(filterNode, structure, 'matcher');
    assertValidKeys(matcherNode, structure, FILTER_MATCHER_PROPERTIES);
    const matcherTypeNode = jsonc_parser_1.findNodeAtLocation(matcherNode, ['type']);
    if (!matcherTypeNode) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('matcher.type', structure, position));
    }
    const matcherType = matchers_1.getMatcherType(matcherTypeNode.value);
    if (!matcherType) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ELEMENT.INVALID_FILTER_MATCHER(structure, matcherTypeNode.value, SUPPORTED_MATCHERS, position));
    }
    const isBasicElement = elementContext.nodeType === 'basic';
    if (isBasicElement) {
        const compatibleMatchers = matchers_1.getCompatibleMatchers(action);
        if (!compatibleMatchers.includes(matcherType)) {
            throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ELEMENT.UNSUPPORTED_FILTER_MATCHER(structure, action.applyFunction, matcherType, compatibleMatchers, position));
        }
    }
    const filterArgsExpectedTypes = isBasicElement ? element_actions_1.getActionExpectedArgs(action) : undefined;
    const filterArgsNode = jsonc_parser_1.findNodeAtLocation(filterNode, ['args']);
    const filterArgsTypes = validateArguments(filterArgsNode, {
        context,
        structure,
        supports: 'any',
        expectedTypes: filterArgsExpectedTypes,
    });
    // remember filter args in element context
    if (elementContext) {
        elementContext.addExpectedArgTypes(filterArgsTypes);
    }
    const matcherExpectedArgs = matchers_1.getMatcherExpectedArgs(matcherType);
    const matcherArgsExpectedTypes = matcherExpectedArgs
        ? matcherExpectedArgs.map((matcherArg) => ({ type: matcherArg, required: true }))
        : [];
    const matcherArgsNode = jsonc_parser_1.findNodeAtLocation(matcherNode, ['args']);
    const matcherArgsTypes = validateArguments(matcherArgsNode, {
        context,
        structure,
        supports: 'any',
        expectedTypes: matcherArgsExpectedTypes,
    });
    // remember filter args in element context
    if (elementContext) {
        elementContext.addExpectedArgTypes(matcherArgsTypes);
    }
}
function validateElementRecursive(parentName, context, elementNode) {
    const position = { offset: elementNode.offset };
    assertions_1.assertIsObject(elementNode, `element "${parentName}"`, 'member of "elements" array');
    const nameNode = jsonc_parser_1.findNodeAtLocation(elementNode, ['name']);
    if (!nameNode) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('name', 'element', position));
    }
    const elementName = assertions_1.assertNotEmptyString(nameNode, `element "${nameNode.value}"`, 'name');
    const parserContext = `element "${elementName}"`;
    assertValidKeys(elementNode, parserContext, ELEMENT_PROPERTIES);
    const descriptionNode = jsonc_parser_1.findNodeAtLocation(elementNode, ['description']);
    if (descriptionNode) {
        validateMethodDescription(parserContext, descriptionNode);
    }
    assertBooleanProperty(parserContext, elementNode, 'public', false);
    const typeNode = jsonc_parser_1.findNodeAtLocation(elementNode, ['type']);
    let elementType = 'basic';
    let typeNodeValue = ['basic'];
    if (typeNode) {
        if (typeNode.type === 'array') {
            typeNodeValue = jsonc_parser_1.getNodeValue(typeNode);
            elementType = assertValidBasicElementTypes(typeNodeValue, elementName);
            if (typeNodeValue.length === 0) {
                typeNodeValue = ['basic'];
            }
        }
        else {
            typeNodeValue = assertions_1.assertNotEmptyString(typeNode, parserContext, 'type');
            elementType = assertValidElementType(typeNodeValue);
        }
    }
    const elementContext = new validation_context_1.ElementContext(elementName, elementType, typeNodeValue, false);
    const selectorParserContext = `${parserContext}, "selector" property`;
    if (elementType === 'container') {
        for (const key of ['filter', 'nullable']) {
            if (jsonc_parser_1.findNodeAtLocation(elementNode, [key])) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REDUNDANT_PROPERTY_KEY_FOR_STRUCTURE(key, 'container element', position));
            }
        }
    }
    else if (elementType === 'frame') {
        assertValidKeys(elementNode, parserContext, FRAME_ELEMENT_PROPERTIES);
        const selectorNode = assertions_1.assertNotNullObject(elementNode, parserContext, 'selector');
        validateSelector({ context, elementContext, parserContext: selectorParserContext }, selectorNode);
    }
    else {
        // only for non-container we should check selector and filter
        const selectorNode = assertions_1.assertNotNullObject(elementNode, parserContext, 'selector');
        validateSelector({ context, elementContext, parserContext: selectorParserContext }, selectorNode);
        elementContext.isList = assertBooleanProperty(parserContext, selectorNode, 'returnAll', false);
        assertBooleanProperty(parserContext, elementNode, 'nullable', false);
        const filterNode = jsonc_parser_1.findNodeAtLocation(elementNode, ['filter']);
        if (filterNode) {
            const filterStructure = `${parserContext} filter`;
            assertions_1.assertIsObject(filterNode, parserContext, 'property "filter"');
            assertValidKeys(filterNode, filterStructure, FILTER_PROPERTIES);
            if (!elementContext.isList) {
                throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ELEMENT.INVALID_FILTER_WITHOUT_SELECTOR_LIST(elementName, position));
            }
            validateElementFilter({ context, structure: filterStructure }, elementContext, filterNode);
            // if filter does not set "findFirst" to true, it's still a list
            elementContext.isList = !assertBooleanProperty(filterStructure, filterNode, 'findFirst', false);
        }
    }
    if (!context.addUniqueElement(elementContext)) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.JSON.DUPLICATE_NODE_DECLARED(elementName, 'element', position));
    }
    const elementsNode = jsonc_parser_1.findNodeAtLocation(elementNode, ['elements']);
    const structureContext = { structure: elementName, position: { offset: elementNode.offset }, context };
    if (elementsNode) {
        assertElementIsNestable(structureContext, elementContext);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        validateElementsRecursive(elementName, context, elementsNode);
    }
    const shadowNode = jsonc_parser_1.findNodeAtLocation(elementNode, ['shadow']);
    if (shadowNode) {
        assertElementIsNestable(structureContext, elementContext);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        validateShadowRecursive(elementName, context, shadowNode);
    }
}
function validateElementsRecursive(parentElement, context, elementsNode) {
    assertions_1.assertOptionalNotEmptyArray(elementsNode, `element "${parentElement}"`, 'elements');
    if (elementsNode.children) {
        for (const elementObjectNode of elementsNode.children) {
            validateElementRecursive(parentElement, context, elementObjectNode);
        }
    }
}
function validateShadowRecursive(parentElement, context, shadowNode) {
    assertions_1.assertIsObject(shadowNode, `element "${parentElement}"`, 'property "shadow"');
    assertValidKeys(shadowNode, `element "${parentElement}" shadow`, ['elements']);
    const elementsNode = jsonc_parser_1.findNodeAtLocation(shadowNode, ['elements']);
    if (elementsNode) {
        validateElementsRecursive(parentElement, context, elementsNode);
    }
}
function validateUtilityComposeStatement(structureContext, applyExternalNode, methodContext) {
    assertions_1.assertIsObject(applyExternalNode, structureContext.structure, 'property "applyExternal"');
    assertValidKeys(applyExternalNode, structureContext.structure, ['type', 'invoke', 'args']);
    const structure = `${structureContext.structure} in applyExternal`;
    const { position, context } = structureContext;
    const typeNode = jsonc_parser_1.findNodeAtLocation(applyExternalNode, ['type']);
    if (!typeNode) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('type', structure, position));
    }
    const parserContext = `${structureContext.structure}, property "applyExternal"`;
    assertions_1.assertNotEmptyString(typeNode, parserContext, 'type');
    const invokeNode = jsonc_parser_1.findNodeAtLocation(applyExternalNode, ['invoke']);
    if (!invokeNode) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_KEY_ON_STRUCTURE('invoke', structure, position));
    }
    assertions_1.assertNotEmptyString(invokeNode, parserContext, 'invoke');
    const argsNode = jsonc_parser_1.findNodeAtLocation(applyExternalNode, ['args']);
    validateArguments(argsNode, { structure, supports: 'any', methodContext, context });
}
function validateReturnSelfStatement(structureContext, statementContext) {
    const { structure, position } = structureContext;
    const { statementNode: composeObjectNode, isLast } = statementContext;
    const returnSelfStruncture = `${structure} "returnSelf"`;
    // all properties except "apply" are redundant
    assertValidKeys(composeObjectNode, returnSelfStruncture, RETURN_SELF_STATEMENT_PROPERTIES);
    // "returnSelf" can only be last statement
    if (!isLast) {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ACTION.INVALID_RETURN_SELF_NOT_LAST_STATEMENT(returnSelfStruncture, position));
    }
    // statement does not have Element Context, hence return undefined
    return;
}
function validateApplyComposeStatement(structureContext, composeObjectNode, elementName, applyNode, methodContext) {
    const { structure, position, context } = structureContext;
    const applyValue = jsonc_parser_1.getNodeValue(applyNode);
    if (elementName === 'self') {
        const argsNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['args']);
        validateArguments(argsNode, { structure, supports: 'any', methodContext, context });
        return;
    }
    // TODO remove this and add proper validations once we implement arguments validation on document element
    const FRAME_ACTIONS = ['enterFrame', 'enterFrameAndLoad', 'exitFrame', 'exitToParentFrame'];
    if (elementName === 'document' && FRAME_ACTIONS.includes(applyValue)) {
        return;
    }
    if (elementName === 'navigation' && UTAM_NAVIGATION_ACTIONS.has(applyValue)) {
        return;
    }
    const elementContext = context.getElementContext(elementName);
    if (!elementContext) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.METHOD.NONEXISTENT_ELEMENT_REFERENCE(structure, elementName, position));
    }
    const isBasicElement = elementContext.nodeType === 'basic';
    const action = validateAppliedAction(structureContext, elementContext, applyValue);
    const expectedArgsTypes = isBasicElement ? element_actions_1.getActionExpectedArgs(action) : undefined;
    const argsNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['args']);
    validateArguments(argsNode, {
        structure,
        supports: 'any',
        methodContext,
        expectedTypes: expectedArgsTypes,
        context,
    });
    return elementContext;
}
// compose statement with only "element"
function validateGetterComposeStatement(structureContext, composeObjectNode, 
// element inside compose stmnt - findNodeAtLocation(composeObjectNode, ['element']);
elementNode, methodContext) {
    const { structure, position, context } = structureContext;
    const elementName = assertions_1.assertNotEmptyString(elementNode, structure, 'element');
    const chainNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['chain']);
    const isChain = chainNode ? jsonc_parser_1.getNodeValue(chainNode) : false;
    const elementContext = context.getElementContext(elementName);
    if (!elementContext && !isChain) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.METHOD.NONEXISTENT_ELEMENT_REFERENCE(structure, elementName, position));
    }
    const argsNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['args']);
    validateArguments(argsNode, { structure, supports: 'any', methodContext, context });
    return elementContext;
}
function validateComposeObject(context, statementContext, structure, methodContext) {
    const { statementNode: composeObjectNode } = statementContext;
    const position = { offset: composeObjectNode.offset };
    const structureContext = { structure, position, context };
    assertValidKeys(composeObjectNode, structure, METHOD_ACTION_PROPERTIES);
    const applyExternalNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['applyExternal']);
    const applyNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['apply']);
    const elementNode = jsonc_parser_1.findNodeAtLocation(composeObjectNode, ['element']);
    let elementName = 'self';
    if (elementNode) {
        elementName = assertions_1.assertNotEmptyString(elementNode, structure, 'element');
    }
    validateReturnType(methodContext.methodName, structureContext, statementContext);
    // statement can be one of:
    // "apply" (to self or to element)
    if (applyNode) {
        const applyValue = assertions_1.assertNotEmptyString(applyNode, structure, 'apply');
        if (`returnSelf` === applyValue) {
            validateReturnSelfStatement(structureContext, statementContext);
        }
        else {
            validateApplyComposeStatement(structureContext, composeObjectNode, elementName, applyNode, methodContext);
        }
    }
    else if (applyExternalNode) {
        // or "applyExternal" (imperative extension)
        assertValidKeys(composeObjectNode, structure, UTILITY_STATEMENT_PROPERTIES);
        validateUtilityComposeStatement(structureContext, applyExternalNode, methodContext);
    }
    else if (elementNode) {
        // or "element" (call element getter)
        validateGetterComposeStatement(structureContext, composeObjectNode, elementNode, methodContext);
    }
    else {
        throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.JSON.REQUIRED_EXCLUSIVE_KEYS_ON_STRUCTURE(['applyExternal', 'apply', 'element'], structure, position));
    }
    if ('beforeLoad' === methodContext.methodType &&
        elementName &&
        elementName !== 'root' &&
        elementName !== 'document' &&
        elementName !== 'self') {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.ROOT.BEFORE_LOAD_UNSUPPORTED_ELEMENT(position));
    }
}
/**
 * Routine function that validates interfaces methods' returnType.
 * A valid returnType for an interface method is the sum of the returnType from element getters and compose methods.
 * The set of valid values for interface method's returnType is the following:
 *
 * - Primitive: 'string' | 'number' | 'boolean'
 * - Custom Element Types: utam-lightning/pageObjects/input
 * - Page Object or Root Page Object
 * - Frame
 *
 * @param returnTypeValue returnType value declared in the page object
 * @returns true if the value is valid, false otherwise
 */
function isValidReturnType(returnTypeValue) {
    if (element_types_1.isCustomTypePredicate(returnTypeValue)) {
        // custom type
        return element_types_1.VALID_CUSTOM_TYPE.test(returnTypeValue);
    }
    return [
        shared_1.UTAM_STRING_RETURN_TYPE,
        shared_1.UTAM_BOOLEAN_RETURN_TYPE,
        shared_1.UTAM_NUMBER_RETURN_TYPE,
        shared_1.UTAM_FRAME_RETURN_TYPE,
        shared_1.UTAM_PAGE_OBJECT_RETURN_TYPE,
        shared_1.UTAM_ROOT_PAGE_OBJECT_RETURN_TYPE,
    ].includes(returnTypeValue);
}
/**
 * Routine function that validates interfaces' methods.
 * An interface is a page object with a root property set to true. It's methods describe the signatures
 * of the interface API that are implemented by concrete classes.
 *
 * @param context page object traversal context
 * @param methodNode current method being validated
 */
function validateInterfaceMethod(context, methodNode) {
    const position = { offset: methodNode.offset };
    assertions_1.assertIsArrayMemberObject(methodNode, 'methods', 'method');
    assertValidKeys(methodNode, 'interface method', INTERFACE_METHOD_PROPERTIES);
    const methodName = assertions_1.assertHasNotEmptyString(methodNode, 'interface method', 'name');
    const structure = `method "${methodName}"`;
    if (!context.addUniqueMethod(methodName)) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.JSON.DUPLICATE_NODE_DECLARED(methodName, 'method', position));
    }
    const descriptionNode = jsonc_parser_1.findNodeAtLocation(methodNode, ['description']);
    if (descriptionNode) {
        validateMethodDescription(`method "${methodName}"`, descriptionNode);
    }
    const argsNode = jsonc_parser_1.findNodeAtLocation(methodNode, ['args']);
    // check declared parameters, literals not allowed in interface method
    validateArguments(argsNode, { structure, context, supports: 'onlyNameType' });
    const returnTypeNode = jsonc_parser_1.findNodeAtLocation(methodNode, ['returnType']);
    const returnAllNode = jsonc_parser_1.findNodeAtLocation(methodNode, ['returnAll']);
    if (returnTypeNode) {
        let isValidType, returnTypeNodeValue;
        if (returnTypeNode.type === 'array') {
            assertions_1.assertOptionalNotEmptyArray(returnTypeNode, structure, 'returnType');
            returnTypeNodeValue = jsonc_parser_1.getNodeValue(returnTypeNode);
            isValidType = returnTypeNodeValue.every((basicType) => UTAM_BASIC_ELEMENT_TYPE.has(basicType));
        }
        else {
            returnTypeNodeValue = assertions_1.assertNotEmptyString(returnTypeNode, structure, 'returnType');
            isValidType =
                [...UTAM_BASIC_ELEMENT_TYPE].find((type) => type === returnTypeNodeValue) ||
                    isValidReturnType(returnTypeNodeValue);
        }
        if (!isValidType) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.METHOD.UNSUPPORTED_RETURN_TYPE_VALUE(structure, returnTypeNodeValue.toString(), position));
        }
        if (returnAllNode) {
            assertBooleanProperty(structure, methodNode, 'returnAll', false);
        }
    }
    else if (returnAllNode) {
        throw new errors_1.UtamCompilerValidationError(returnAllNode, 402, [methodName]);
    }
}
function validateMethodDescription(structure, descriptionNode) {
    const parserContext = `${structure} description`;
    if (descriptionNode.type === 'string') {
        return;
    }
    assertions_1.assertIsObject(descriptionNode, structure, 'property "description"');
    assertValidKeys(descriptionNode, parserContext, METHOD_DESCRIPTION_PROPERTIES);
    const textArrayNode = assertions_1.assertNotEmptyArray(descriptionNode, parserContext, 'text');
    assertions_1.assertArrayMemberIsString(textArrayNode, parserContext, 'text');
    const deprecatedNode = jsonc_parser_1.findNodeAtLocation(descriptionNode, ['deprecated']);
    if (deprecatedNode) {
        assertions_1.assertNotEmptyString(deprecatedNode, parserContext, 'deprecated');
    }
    const returnNode = jsonc_parser_1.findNodeAtLocation(descriptionNode, ['return']);
    if (returnNode) {
        assertions_1.assertNotEmptyString(returnNode, parserContext, 'return');
    }
    const throwsNode = jsonc_parser_1.findNodeAtLocation(descriptionNode, ['throws']);
    if (throwsNode) {
        assertions_1.assertNotEmptyString(throwsNode, parserContext, 'throws');
    }
}
function validateComposeMethod(context, methodNode) {
    const position = { offset: methodNode.offset };
    assertions_1.assertIsArrayMemberObject(methodNode, 'methods', 'method');
    assertValidKeys(methodNode, 'method', METHOD_PROPERTIES);
    const methodName = assertions_1.assertHasNotEmptyString(methodNode, 'method', 'name');
    const structure = `method "${methodName}"`;
    if (!context.addUniqueMethod(methodName)) {
        throw new errors_1.UtamValidationError(diagnostics_1.descriptions.JSON.DUPLICATE_NODE_DECLARED(methodName, 'method', position));
    }
    const argsNode = jsonc_parser_1.findNodeAtLocation(methodNode, ['args']);
    // check declared parameters, literals not allowed in method declaration
    validateArguments(argsNode, { structure, context, supports: 'onlyNameType' });
    const composeNode = assertions_1.assertNotEmptyArray(methodNode, structure, 'compose');
    const descriptionNode = jsonc_parser_1.findNodeAtLocation(methodNode, ['description']);
    if (descriptionNode) {
        validateMethodDescription(`method "${methodName}"`, descriptionNode);
    }
    const methodContext = {
        methodArgsMap: args_1.buildArgsNodeMap(argsNode),
        methodType: 'compose',
        methodName,
    };
    if (composeNode.children) {
        const { statementsContext } = new validation_context_1.StatementsContext(composeNode.children);
        for (const statementContext of statementsContext) {
            const { statementNode } = statementContext;
            assertions_1.assertIsArrayMemberObject(statementNode, `method "${methodName}"`, 'statement');
            validateComposeObject(context, statementContext, `method "${methodName}" statement`, methodContext);
        }
    }
}
function validateMethods(context, methodsNode) {
    assertions_1.assertOptionalNotEmptyArray(methodsNode, 'root', 'methods');
    assertValidKeys(methodsNode, 'root', ['methods']);
    // Interface & Compose methods don't have the same structural shape
    const validateMethodFunction = context.isInterface ? validateInterfaceMethod : validateComposeMethod;
    if (methodsNode.children) {
        for (const methodObjectNode of methodsNode.children) {
            validateMethodFunction(context, methodObjectNode);
        }
    }
}
function validateBeforeLoad(context, beforeLoadNode) {
    const structure = 'beforeLoad';
    assertions_1.assertOptionalNotEmptyArray(beforeLoadNode, 'root', 'beforeLoad');
    const methodContext = {
        methodArgsMap: args_1.buildArgsNodeMap(undefined),
        methodType: 'beforeLoad',
        methodName: 'beforeLoad',
    };
    if (beforeLoadNode.children) {
        const { statementsContext } = new validation_context_1.StatementsContext(beforeLoadNode.children);
        for (const statementContext of statementsContext) {
            const { statementNode } = statementContext;
            assertions_1.assertIsArrayMemberObject(statementNode, `method "beforeLoad"`, 'statement');
            validateComposeObject(context, statementContext, structure, methodContext);
        }
    }
}
function validateRootDescription(descriptionNode) {
    const structure = 'root';
    const parserContext = `root "description"`;
    if (descriptionNode.type === 'string') {
        assertions_1.assertNotEmptyString(descriptionNode, parserContext, 'description');
        return;
    }
    assertions_1.assertIsObject(descriptionNode, structure, 'property "description"');
    assertValidKeys(descriptionNode, parserContext, ROOT_DESCRIPTION_PROPERTIES);
    const textArrayNode = assertions_1.assertNotEmptyArray(descriptionNode, parserContext, 'text');
    assertions_1.assertArrayMemberIsString(textArrayNode, parserContext, 'text');
    const deprecatedNode = jsonc_parser_1.findNodeAtLocation(descriptionNode, ['deprecated']);
    if (deprecatedNode) {
        assertions_1.assertNotEmptyString(deprecatedNode, parserContext, 'deprecated');
    }
    const authorNode = jsonc_parser_1.findNodeAtLocation(descriptionNode, ['author']);
    if (authorNode) {
        assertions_1.assertNotEmptyString(authorNode, parserContext, 'author');
    }
}
function validatePageObjectJson(jsonSourceText) {
    const errors = [];
    const rootNode = page_object_parser_1.parseTree(jsonSourceText, errors);
    const structure = 'root';
    // check if preliminary parsing returned some errors
    if (errors.length) {
        const firstError = errors[0];
        const utamParseError = page_object_parser_1.isUtamParseError(firstError) ? firstError : page_object_parser_1.createUtamParseError(firstError);
        const { message, offset } = utamParseError;
        throw new errors_1.UtamCompilerValidationError({ offset }, 900, [message]);
    }
    assertions_1.assertIsObject(rootNode, structure, 'json');
    assertValidKeys(rootNode, structure, ROOT_PROPERTIES);
    const selectorNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['selector']);
    const rootMarkerNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['root']);
    const typeNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['type']);
    const context = new validation_context_1.Context();
    // need to register root and document in case it's referenced from compose
    const rootElm = new validation_context_1.ElementContext(ROOT_ELEMENT_NAME, 'basic', typeNode ? jsonc_parser_1.getNodeValue(typeNode) : [shared_1.UTAM_ELEMENT_DEFAULT_TYPE], false);
    context.addUniqueElement(rootElm);
    const documentElm = new validation_context_1.ElementContext(DOCUMENT_OBJECT_NAME, 'custom', 'custom/pageObjects/document', false);
    context.addUniqueElement(documentElm);
    context.isInterface = assertBooleanProperty(structure, rootNode, 'interface', false);
    if (context.isInterface) {
        assertValidKeys(rootNode, 'interface root', INTERFACE_PROPERTIES);
    }
    if (selectorNode) {
        assertions_1.assertIsObject(selectorNode, structure, 'property "selector"');
        validateSelector({ context, elementContext: rootElm, parserContext: 'root "selector" property' }, selectorNode);
        // if not marked as root - selector is redundant
        if (!rootMarkerNode || !rootMarkerNode?.value) {
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ROOT.REDUNDANT_SELECTOR());
        }
    }
    else {
        // if marked as root - needs selector
        if (!context.isInterface && rootMarkerNode && rootMarkerNode?.value) {
            const { offset, length } = rootMarkerNode.parent;
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ROOT.REQUIRED_SELECTOR_IF_ROOT({ offset, length }));
        }
    }
    // check that value is boolean
    assertBooleanProperty(structure, rootNode, 'root', false);
    assertBooleanProperty(structure, rootNode, 'exposeRootElement', false);
    assertValueInSet(structure, rootNode, 'platform', SUPPORTED_MOBILE_CONTEXT_TYPE);
    const metadataNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['metadata']);
    if (metadataNode) {
        assertions_1.assertIsObject(metadataNode, structure, 'property "metadata"');
    }
    if (typeNode) {
        if (typeNode.type === 'array') {
            assertions_1.assertOptionalNotEmptyArray(typeNode, 'page object root', 'type');
        }
        else {
            assertions_1.assertNotEmptyString(typeNode, 'page object root', 'type');
        }
        const typeValue = jsonc_parser_1.getNodeValue(typeNode);
        assertValidBasicElementTypes(typeValue, 'root');
    }
    const implementsNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['implements']);
    if (implementsNode) {
        assertions_1.assertNotEmptyString(implementsNode, 'page object root', 'implements');
    }
    const profileNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['profile']);
    if (profileNode) {
        if (!implementsNode) {
            const { offset, length } = profileNode;
            throw new errors_1.UtamSchemaValidationError(diagnostics_1.descriptions.ROOT.REQUIRED_IMPLEMENTS_IF_PROFILE({ offset, length }));
        }
        assertions_1.assertOptionalNotEmptyArray(profileNode, 'page object root', 'profile');
        if (profileNode.children) {
            const tracker = new Set();
            for (const profile of profileNode.children) {
                assertions_1.assertIsObject(profile, 'root', 'profile');
                validateProfile(profile, tracker);
            }
        }
    }
    const shadowNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['shadow']);
    if (shadowNode) {
        validateShadowRecursive('root', context, shadowNode);
    }
    const elementsNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['elements']);
    if (elementsNode) {
        validateElementsRecursive('root', context, elementsNode);
    }
    // all methods should be validated after element traversal
    const beforeLoadNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['beforeLoad']);
    if (beforeLoadNode) {
        validateBeforeLoad(context, beforeLoadNode);
    }
    const methodsNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['methods']);
    if (methodsNode) {
        validateMethods(context, methodsNode);
    }
    const descriptionNode = jsonc_parser_1.findNodeAtLocation(rootNode, ['description']);
    if (descriptionNode) {
        validateRootDescription(descriptionNode);
    }
    return jsonc_parser_1.parse(jsonSourceText);
}
function validatePageObject(jsonSourceText) {
    try {
        return validatePageObjectJson(jsonSourceText);
    }
    catch (error) {
        if (error instanceof errors_1.UtamValidationError && error.position) {
            errors_1.calculatePositionFromSource(error, jsonSourceText);
        }
        throw error;
    }
}
exports.validatePageObject = validatePageObject;
//# sourceMappingURL=page-object.js.map