"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatementsContext = exports.StatementContext = exports.Context = exports.ElementContext = void 0;
const jsonc_parser_1 = require("jsonc-parser");
/**
 * context of an element including its name, type, cardinality and expected parameter types
 */
class ElementContext {
    constructor(name, nodeType, elementType, isList) {
        // expected args types of selector and filter, used in validation for elementReference
        this.expectedArgs = new Array();
        this.name = name;
        this.nodeType = nodeType;
        this.elementType = elementType;
        this.isList = isList;
    }
    /**
     * expected types of args for an element including selector and filter
     * @returns array of type names for args
     */
    getExpectedTypes() {
        return this.expectedArgs;
    }
    /**
     * set expected args types for an element
     * @param types set expected args types for an element
     */
    addExpectedArgTypes(types) {
        this.expectedArgs.push(...types);
    }
}
exports.ElementContext = ElementContext;
/**
 * traversal context created per each validated Page Object
 * accumulates information about elements and provides validations across different nodes
 */
class Context {
    constructor() {
        this.visitedElements = new Map();
        this.visitedMethods = new Set();
        /** Indicates if the page object was declared as an interface (interface: true in the root scope) */
        this.isInterface = false;
    }
    addUniqueElement(elementContext) {
        const name = elementContext.name;
        if (this.visitedElements.has(name)) {
            return false;
        }
        this.visitedElements.set(name, elementContext);
        return true;
    }
    addUniqueMethod(name) {
        if (this.visitedMethods.has(name)) {
            return false;
        }
        this.visitedMethods.add(name);
        return true;
    }
    getElementContext(name) {
        return this.visitedElements.get(name);
    }
}
exports.Context = Context;
/**
 * Represents a decorated statement with context information used to validate returnTypes
 */
class StatementContext {
    constructor(statementNode, isLast, nextIsChain) {
        this.statementNode = statementNode;
        this.isLast = isLast;
        this.isNextStatementChain = nextIsChain;
    }
}
exports.StatementContext = StatementContext;
/**
 * Traversal context for statements (in compose method or in beforeLoad). This class decorates the statement nodes
 * object with properties that add some context around the statement. This is used for the validation of the returnType
 * in statements that can require information about siblings statements (n +/- 1).
 */
class StatementsContext {
    constructor(statementNodes) {
        this.statementsContext = statementNodes.map((statementNodeObject, index, statementsNodeObjects) => {
            const isLast = index === statementsNodeObjects.length - 1;
            const nextStatement = !isLast ? statementsNodeObjects[index + 1] : null;
            const nextIsChain = this.isNextStatementChain(nextStatement);
            return new StatementContext(statementNodeObject, isLast, nextIsChain);
        });
    }
    isNextStatementChain(nextStatement) {
        if (!nextStatement)
            return false;
        const chainNode = jsonc_parser_1.findNodeAtLocation(nextStatement, ['chain']);
        if (!chainNode)
            return false;
        const chainNodeValue = jsonc_parser_1.getNodeValue(chainNode);
        return chainNodeValue;
    }
}
exports.StatementsContext = StatementsContext;
//# sourceMappingURL=validation-context.js.map