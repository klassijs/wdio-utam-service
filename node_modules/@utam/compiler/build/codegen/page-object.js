"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePageObject = void 0;
const element_types_1 = require("../utils/element-types");
const primitive_arguments_1 = require("../utils/primitive-arguments");
const renderer_1 = require("./renderer");
function generateElement(renderer, element, options = {}) {
    const { selector = {}, name, elements, shadow, type, filter, nullable } = element;
    const { insideShadow, parentName, parentArgs = [], parentArgTypes = {}, parentArgDescriptions = {}, parentNullable, parentSelectorReturnsList, parentFilterApplicationName, } = options;
    const isContainer = element_types_1.isContainerElement(type);
    let filterFunctionIdentifier;
    let appliedFunctionApplicationIdentifier;
    let filterFunctionArgs = [];
    let filterArgsTypes;
    let filterArgsDescriptions;
    // if filter is not set, default is true as it's used as condition to return list
    const filterReturnsList = filter ? !filter.findFirst : true;
    // if container element does not have selector, assign default
    const elementSelector = isContainer && !element.selector ? { css: ':scope > *:first-child' } : selector;
    // Creates a stateless function that will be hoisted at the module level to apply filtering criteria
    if (filter) {
        filterFunctionArgs = primitive_arguments_1.getArgumentsNames(filter.args).concat(primitive_arguments_1.getArgumentsNames(filter.matcher.args));
        filterArgsTypes = primitive_arguments_1.getArgumentsTypeMap(filter.args);
        filterArgsDescriptions = primitive_arguments_1.getArgumentsDescriptionMap(filter.args);
        Object.assign(filterArgsTypes, primitive_arguments_1.getArgumentsTypeMap(filter.matcher.args));
        // Creates a stateless function that will be hoisted at the module level to apply element filter
        filterFunctionIdentifier = renderer.addFilterFunctionDeclaration(filter, {
            name,
            parentName,
            parentArgs,
        });
        const hasNestedElements = elements || shadow ? true : false;
        if (hasNestedElements) {
            appliedFunctionApplicationIdentifier = renderer.addFilterApplicationFunctionDeclaration(filter, {
                name,
                filterFunctionIdentifier,
            });
        }
    }
    // Creates a stateless function that will be hoisted at the module level to get a particular element
    const hoistedFunctionIdentifier = renderer.addSelectorFunctionDeclaration(elementSelector, {
        isContainer,
        insideShadow,
        parentName,
        parentArgs,
        parentNullable,
        parentSelectorReturnsList,
        nullable,
        name,
        parentFilterApplicationName,
    });
    const argsTypes = primitive_arguments_1.getSelectorArgTypes(elementSelector);
    const argsDescriptions = primitive_arguments_1.getSelectorArgDescriptions(elementSelector);
    const args = primitive_arguments_1.getArgumentsNames(elementSelector.args);
    // Merge all types
    const mergedArgTypes = { ...parentArgTypes, ...argsTypes, ...filterArgsTypes };
    const mergedArgDescriptions = { ...parentArgDescriptions, ...argsDescriptions, ...filterArgsDescriptions };
    const orderedArgs = [...parentArgs, ...args, ...filterFunctionArgs];
    renderer.addElementMethod({
        name,
        type,
        args,
        nullable,
        parentArgs,
        parentNullable: parentNullable,
        hoistedFunctionIdentifier,
        filterFunctionIdentifier,
        appliedFunctionApplicationIdentifier,
        filterFunctionArgs,
        filterReturnsList,
        argsTypeMap: mergedArgTypes,
        argsDescriptionMap: mergedArgDescriptions,
        hasSelector: !!elementSelector.css,
        selectorReturnsList: !!elementSelector.returnAll,
        isPublic: !!element.public,
        description: element.description,
    });
    // Recursively continue resolving elements
    if (elements) {
        for (const element of elements) {
            generateElement(renderer, element, {
                parentName: hoistedFunctionIdentifier,
                parentArgs: orderedArgs,
                parentNullable: parentNullable ?? nullable,
                parentArgTypes: mergedArgTypes,
                parentSelectorReturnsList: selector.returnAll,
                parentFilterApplicationName: appliedFunctionApplicationIdentifier,
            });
        }
    }
    if (shadow) {
        for (const shadowElement of shadow.elements) {
            generateElement(renderer, shadowElement, {
                insideShadow: true,
                parentName: hoistedFunctionIdentifier,
                parentArgs: orderedArgs,
                parentNullable: parentNullable ?? nullable,
                parentArgTypes: mergedArgTypes,
                parentSelectorReturnsList: selector.returnAll,
                parentFilterApplicationName: appliedFunctionApplicationIdentifier,
            });
        }
    }
}
function generateMethods(renderer, methods) {
    for (const method of methods) {
        renderer.addCustomMethod(method);
    }
}
function generatePageObject(pageObject, metadata, compilerConfig, alias) {
    const renderer = new renderer_1.Renderer();
    const { elements = [], shadow, methods, type, beforeLoad, exposeRootElement } = pageObject;
    const { interface: isInterface, platform, root: isRoot, description } = pageObject;
    const { skipCodeGen, skipTypeGen, format } = compilerConfig;
    const { name, commentsOptions } = metadata;
    renderer.createClassBody(name, pageObject.selector, {
        skipCodeGen,
        skipTypeGen,
        format,
        isInterface,
        isRoot,
        platform,
        description,
        commentsOptions,
    });
    // TODO: pass interface
    // We declare method for root element
    renderer.applyRootOptions({ type, exposeRootElement, beforeLoad });
    for (const element of elements) {
        generateElement(renderer, element);
    }
    if (shadow) {
        for (const shadowElement of shadow.elements) {
            generateElement(renderer, shadowElement, { insideShadow: true });
        }
    }
    if (methods) {
        generateMethods(renderer, methods);
    }
    return renderer.render(alias);
}
exports.generatePageObject = generatePageObject;
//# sourceMappingURL=page-object.js.map