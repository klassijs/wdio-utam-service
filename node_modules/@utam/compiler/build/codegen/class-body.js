"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassBody = exports.getBasicElementTypeCtor = void 0;
const code_1 = require("../utils/code");
const element_types_1 = require("../utils/element-types");
const imports_1 = require("../utils/imports");
const naming_1 = require("../utils/naming");
const primitive_arguments_1 = require("../utils/primitive-arguments");
const return_types_1 = require("../utils/return-types");
const jsdoc_transformers_1 = require("../utils/jsdoc-transformers");
const class_body_generator_1 = require("./helpers/class-body-generator");
const statements_body_generator_1 = require("./helpers/statements-body-generator");
const statements_transformer_1 = require("./helpers/statements-transformer");
const shared_1 = require("./shared");
function getBasicElementTypeCtor(type) {
    return shared_1.UTAM_ELEMENT_TYPE_TO_CTOR[type];
}
exports.getBasicElementTypeCtor = getBasicElementTypeCtor;
function selectModuleConstructorByType(type, typesTracker) {
    let moduleSpecifier = shared_1.UTAM_CORE_MODULE;
    let defaultImport = false;
    let external = false;
    let namedImport;
    if (element_types_1.isBasicElement(type)) {
        namedImport = shared_1.UTAM_ELEMENT_CTOR;
    }
    else if (element_types_1.isContainerElement(type)) {
        namedImport = shared_1.UTAM_CONTAINER_CTOR;
    }
    else if (element_types_1.isFrameElement(type)) {
        namedImport = shared_1.UTAM_FRAME_ELEMENT_CTOR;
    }
    else {
        // Custom Types
        defaultImport = true;
        moduleSpecifier = type;
        namedImport = naming_1.buildImportNameFromModulePath(type, typesTracker);
        external = true;
    }
    return { moduleSpecifier, namedImport, defaultImport, external };
}
class ClassBody {
    constructor(className, rootSelector, options = { format: 'es' }) {
        /**
         * page objects imports
         * key is full module name "my/page/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.imports = new Map();
        /**
         * page objects type declarations imports (d.ts file)
         * key is full module name "my/page/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.typedImports = new Map();
        /**
         * page objects extensions imports: used to import exposed extensions functions
         * key is full module name "my/utility/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.utilityImports = new Map();
        /**
         * shared paged objects and page objects type declarations imports
         * key is full module name "my/page/Object", value is pairs of name "Object" and import identifier "_Object"
         */
        this.sharedImports = new Map();
        this._elementMethodsAst = [];
        this._composeMethodsAst = [];
        this._interfaceMethodAst = [];
        this._rootMethod = [];
        this._beforeLoadMethod = [];
        this._className = className;
        this._options = options;
        this._rootSelector = rootSelector;
        this._isInterface = !!options.isInterface;
        this._platform = options.platform;
        this._description = jsdoc_transformers_1.buildRootDescription(options.commentsOptions?.jsonPath, options.commentsOptions?.version, options.description);
        this._isRootPageObject = !!options.isRoot;
        // Auto Generate imports for the class
        this._webdriverTypeIdentifier = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_TYPES_DRIVER, {
            importDestination: this.typedImports,
        });
        this._webelementTypeIdentifier = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_TYPES_ELEMENT, {
            importDestination: this.typedImports,
        });
        this._locatorTypeIdentifier = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_TYPES_LOCATOR, {
            importDestination: this.typedImports,
        });
        // Interfaces can be marked as root without a selector
        if (this._isRootPageObject) {
            this._extendsClassNameIdentifier = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_BASE_ROOT_CLASS_NAME, {
                importDestination: this.sharedImports,
            });
            if (rootSelector) {
                this._byIdentifier = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_LOCATOR_BY, {
                    importDestination: this.imports,
                });
            }
        }
        else {
            this._extendsClassNameIdentifier = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_BASE_CLASS_NAME, {
                importDestination: this.sharedImports,
            });
        }
        this.initializeDocumentElement();
        this.initializeNavigationElement();
        const { _byIdentifier, _locatorTypeIdentifier } = this;
        this._typeIdentifiers = {
            _byIdentifier,
            _locatorTypeIdentifier,
            _elementTypeIdentifier: imports_1.buildIdentifier(shared_1.UTAM_ELEMENT_CTOR_BASE),
            _frameElementTypeIdentifier: imports_1.buildIdentifier(shared_1.UTAM_FRAME_ELEMENT_CTOR),
            _pageObjectTypeIdentifier: imports_1.buildIdentifier(shared_1.UTAM_PAGE_OBJECT_CTOR),
            _rootPageObjectTypeIdentifier: imports_1.buildIdentifier(shared_1.UTAM_PAGE_OBJECT_CTOR),
            // container types identifiers will be added later if at least one container found
        };
        this.typeNamesTracker = new Map();
    }
    initializeDocumentElement() {
        this._elementMethodsAst.push({
            elementName: shared_1.UTAM_DOCUMENT_ELEMENT,
            type: shared_1.UTAM_DOCUMENT_ELEMENT,
            typeConstructor: shared_1.UTAM_ELEMENT_CTOR_DOCUMENT,
            methodName: 'getDocument',
            hoistedFunctionIdentifier: '_doc',
            args: [],
            parentArgs: [],
            nullable: false,
            parentNullable: false,
            filterFunctionArgs: [],
            filterReturnsList: false,
            argsTypeMap: {},
            argsDescriptionMap: {},
            orderedArgs: [],
            hasSelector: true,
            selectorReturnsList: false,
            returnsList: false,
            isPublic: false,
            description: [],
        });
    }
    // TODO returns the common properties from a function
    initializeNavigationElement() {
        this._elementMethodsAst.push({
            elementName: shared_1.UTAM_NAVIGATION_ELEMENT,
            type: shared_1.UTAM_NAVIGATION_ELEMENT,
            typeConstructor: shared_1.UTAM_ELEMENT_CTOR_NAVIGATION,
            methodName: 'getNavigation',
            hoistedFunctionIdentifier: '_nav',
            args: [],
            parentArgs: [],
            nullable: false,
            parentNullable: false,
            filterFunctionArgs: [],
            filterReturnsList: false,
            argsTypeMap: {},
            argsDescriptionMap: {},
            orderedArgs: [],
            hasSelector: true,
            selectorReturnsList: false,
            returnsList: false,
            isPublic: false,
            description: [],
        });
    }
    addImport(module, name, options) {
        const { importDestination, defaultImport = false } = options;
        return imports_1.addImport(module, name, importDestination, defaultImport);
    }
    addElementMethod(config) {
        const { name, hoistedFunctionIdentifier, args = [], argsTypeMap = {}, argsDescriptionMap = {}, nullable, parentNullable, hasSelector, selectorReturnsList, isPublic, parentArgs = [], filterFunctionIdentifier, filterFunctionArgs = [], filterReturnsList, description, } = config;
        let { type = [] } = config;
        const methodName = naming_1.elementToMethodName(name, isPublic);
        const containerType = element_types_1.isContainerElement(type);
        const { moduleSpecifier, namedImport, defaultImport } = selectModuleConstructorByType(type, this.typeNamesTracker);
        const typeConstructor = containerType
            ? shared_1.UTAM_CONTAINER_CTOR
            : this.addImport(moduleSpecifier, namedImport, {
                importDestination: isPublic && namedImport !== shared_1.UTAM_ELEMENT_CTOR ? this.sharedImports : this.imports,
                defaultImport,
            });
        const returnsList = selectorReturnsList && (!filterFunctionIdentifier || filterReturnsList);
        if (containerType && isPublic) {
            const _containerType = this.addImport(moduleSpecifier, namedImport, {
                importDestination: this.typedImports,
                defaultImport: false,
            });
            this._typeIdentifiers._containerType = _containerType;
            // add import for base page object type returned by container method
            const _containerReturnTypeGenericBound = this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_BASE_CLASS_NAME, {
                importDestination: this.typedImports,
            });
            this._typeIdentifiers._containerReturnTypeGenericBound = _containerReturnTypeGenericBound;
        }
        // Add imports for basic elements as basic elements are now declared as a list of 1..N interfaces to satisfy
        if (element_types_1.isBasicElement(type)) {
            type = element_types_1.wrapSingleBasicTypeInArray(type);
            this._addBasicElementsTypesImports(type, { isPublic });
        }
        // Add import for Custom Element factory function
        if (element_types_1.isCustomType(type)) {
            this.addImport(shared_1.UTAM_CORE_MODULE, shared_1.UTAM_ELEMENT_FACTORY_FN, {
                importDestination: this.imports,
            });
        }
        this._elementMethodsAst.push({
            elementName: name,
            type,
            typeConstructor,
            methodName,
            hoistedFunctionIdentifier,
            args,
            parentArgs,
            nullable: nullable ?? false,
            parentNullable: parentNullable ?? false,
            filterFunctionIdentifier,
            filterFunctionArgs,
            filterReturnsList,
            argsTypeMap,
            argsDescriptionMap,
            orderedArgs: [...parentArgs, ...args, ...filterFunctionArgs],
            hasSelector,
            selectorReturnsList,
            returnsList,
            isPublic,
            description: jsdoc_transformers_1.buildMethodDescription(description),
        });
        return methodName;
    }
    /**
     * Add imports for basic elements as basic elements are now declared as a list of 1..N interfaces to satisfy
     * @param type type of the element parsed from the declaration in the JSON file
     * @param isPublic indicates that the function is a public PO API
     */
    _addBasicElementsTypesImports(type, { isPublic, isRootElement = false }) {
        if (isPublic) {
            // add BaseUtamElement to typed imports as all basic element types are intersection of
            // BaseUtamElement and other types mixins (activable, clickable...)
            this.addImport(shared_1.UTAM_CORE_MODULE, getBasicElementTypeCtor(shared_1.UTAM_ELEMENT_DEFAULT_TYPE), {
                importDestination: this.typedImports,
                defaultImport: false,
            });
        }
        // For interface, methods aren't implemented so we only want to add the types to the type declaration files
        // with the execption of the root element as it's getter is still part of the interface
        // Otherwise, we only adds the types to the JS page objects and to the type declaration if it's public
        // (private APIs aren't in the type declaration)
        const elementTypesImportDestination = this._isInterface && !isRootElement ? this.typedImports : isPublic ? this.sharedImports : this.imports;
        type.forEach((utamElementType) => {
            this.addImport(shared_1.UTAM_CORE_MODULE, getBasicElementTypeCtor(utamElementType), {
                importDestination: elementTypesImportDestination,
                defaultImport: false,
            });
        });
    }
    addCustomMethod(method) {
        const { name, description } = method;
        if (this._isInterface) {
            const { args: methodArgs = [], returnType = shared_1.UTAM_VOID_RETURN_TYPE, returnAll, } = method;
            const explicitReturnType = return_types_1.getExplicitReturnType(returnType, this.typeNamesTracker);
            this.addReturnTypeImportsForAbstractMethod(explicitReturnType, returnType);
            // Add imports for args types
            if (methodArgs.length > 0) {
                const importsBuilder = new statements_transformer_1.ArgImportsBuilder(this.typeNamesTracker);
                const imports = importsBuilder.mapArgToImports(methodArgs);
                for (const i of imports) {
                    const { moduleSpecifier, name, destination, defaultImport } = i;
                    this.addImport(moduleSpecifier, name, {
                        importDestination: this[destination],
                        defaultImport,
                    });
                }
            }
            this._interfaceMethodAst.push({
                methodName: name,
                isPublic: true,
                orderedArgs: primitive_arguments_1.getArgumentsNames(methodArgs),
                argsTypeMap: primitive_arguments_1.getArgumentsTypeMap(methodArgs),
                argsDescriptionMap: primitive_arguments_1.getArgumentsDescriptionMap(methodArgs),
                typeConstructor: explicitReturnType.returnTypeValue,
                returnsList: !!returnAll,
                description: jsdoc_transformers_1.buildMethodDescription(description),
            });
        }
        else {
            const { compose, args: methodArgs = [] } = method;
            const { statements, composeArgs, lastStatementReturnAll, returnType, lastStatementReturn } = this.addComposeStatements(name, compose, methodArgs);
            // import for return types in type definiton
            this.addReturnTypeImportsForComposeMethod(returnType, lastStatementReturn);
            const methodArgsTypeMap = { ...primitive_arguments_1.getArgumentsTypeMap(composeArgs), ...primitive_arguments_1.getArgumentsTypeMap(methodArgs) };
            const methodArgsDescrMap = {
                ...primitive_arguments_1.getArgumentsDescriptionMap(composeArgs),
                ...primitive_arguments_1.getArgumentsDescriptionMap(methodArgs),
            };
            const orderedArgs = [...composeArgs.map((c) => c.name)];
            this._composeMethodsAst.push({
                methodName: name,
                isPublic: true,
                orderedArgs,
                statements,
                argsTypeMap: methodArgsTypeMap,
                argsDescriptionMap: methodArgsDescrMap,
                typeConstructor: returnType.returnTypeValue,
                returnsList: lastStatementReturnAll,
                description: jsdoc_transformers_1.buildMethodDescription(description),
            });
        }
        return name;
    }
    getPageObjectOrFrameReturnTypeImport(returnTypeKind) {
        if (returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_PAGE_OBJECT) {
            return shared_1.UTAM_BASE_CLASS_NAME;
        }
        else if (returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_ROOT_PAGE_OBJECT) {
            return shared_1.UTAM_BASE_ROOT_CLASS_NAME;
        }
        else if (returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_FRAME_ELEMENT) {
            return shared_1.UTAM_FRAME_ELEMENT_CTOR;
        }
    }
    addReturnTypeImportsForComposeMethod({ returnTypeKind }, lastStatementReturn) {
        if (returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT && lastStatementReturn) {
            imports_1.addImport(lastStatementReturn, naming_1.buildImportNameFromModulePath(lastStatementReturn, this.typeNamesTracker), this.typedImports, true);
        }
        else {
            // for "frame", "pageObject", "rootPageObject"
            const typeName = this.getPageObjectOrFrameReturnTypeImport(returnTypeKind);
            if (typeName) {
                imports_1.addImport(shared_1.UTAM_CORE_MODULE, typeName, this.typedImports);
            }
        }
    }
    addReturnTypeImportsForAbstractMethod({ returnTypeKind }, returnType) {
        if (returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT) {
            const { moduleSpecifier, namedImport, defaultImport } = selectModuleConstructorByType(returnType, this.typeNamesTracker);
            this.addImport(moduleSpecifier, namedImport, {
                importDestination: this.typedImports,
                defaultImport,
            });
        }
        else if (returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_BASIC_ELEMENT) {
            const type = element_types_1.wrapSingleBasicTypeInArray(returnType);
            this._addBasicElementsTypesImports(type, { isPublic: true });
        }
        else {
            // for "frame", "pageObject", "rootPageObject"
            const typeName = this.getPageObjectOrFrameReturnTypeImport(returnTypeKind);
            if (typeName) {
                imports_1.addImport(shared_1.UTAM_CORE_MODULE, typeName, this.typedImports);
            }
        }
    }
    addComposeStatements(methodName, compose, methodArgs) {
        const { _elementMethodsAst, utilityImports, imports, typedImports, _typeIdentifiers, typeNamesTracker } = this;
        const astConfig = { elementMethodsAst: _elementMethodsAst, typeNamesTracker };
        const classBodyContext = {
            methodName,
            astConfig,
            importsDestination: {
                extensions: utilityImports,
                imports,
                typedImports,
            },
            typeIdentifiers: _typeIdentifiers,
        };
        return statements_transformer_1.transformComposeStatements(classBodyContext, compose, methodArgs);
    }
    applyRootOptions({ type, exposeRootElement, beforeLoad }) {
        const name = shared_1.UTAM_ROOT_ELEMENT;
        let rootType = type ?? [];
        rootType = element_types_1.wrapSingleBasicTypeInArray(rootType);
        const { moduleSpecifier, namedImport, defaultImport } = selectModuleConstructorByType(rootType, this.typeNamesTracker);
        const typeConstructor = this.addImport(moduleSpecifier, namedImport, {
            importDestination: this.imports,
            defaultImport,
        });
        const methodName = naming_1.elementToMethodName(name, exposeRootElement);
        const rootAst = {
            elementName: name,
            type: rootType,
            typeConstructor,
            methodName,
            isPublic: !!exposeRootElement,
            argsTypeMap: {},
            argsDescriptionMap: {},
            orderedArgs: [],
            returnsList: false,
            selectorReturnsList: false,
            beforeLoad,
            description: [],
        };
        this._rootMethod.push(rootAst);
        const { isPublic } = rootAst;
        this._addBasicElementsTypesImports(rootType, { isPublic, isRootElement: true });
        // Create a default root element AST
        this._elementMethodsAst.push({
            ...rootAst,
            nullable: false,
            parentNullable: false,
            hoistedFunctionIdentifier: 'root',
            args: [],
            parentArgs: [],
            filterFunctionArgs: [],
            hasSelector: false,
            filterReturnsList: false,
            description: [],
        });
        // should be after previous statement so that root element getter would be already added!
        if (beforeLoad) {
            // beforeLoad statements have same syntax as compose except cannot accept non-literal args
            // all differences with compose should be checked during validation phase, method level args are empty
            const { statements } = this.addComposeStatements(shared_1.BEFORE_LOAD_METHOD_NAME, beforeLoad, []);
            this._beforeLoadMethod.push({
                methodName: shared_1.BEFORE_LOAD_METHOD_NAME,
                statements: statements,
                orderedArgs: [],
                description: [],
                argsTypeMap: {},
                argsDescriptionMap: {},
            });
        }
        return methodName;
    }
    generateCode() {
        const { _extendsClassNameIdentifier, _className, _rootSelector, _byIdentifier, _typeIdentifiers, _isInterface, _platform, _description, } = this;
        const { _rootMethod, _beforeLoadMethod, _elementMethodsAst, _composeMethodsAst, typeNamesTracker } = this;
        const { utilityImports, imports, typedImports } = this;
        const camelCaseName = naming_1.kebabcaseToCamelcase(_className);
        const astConfig = { elementMethodsAst: _elementMethodsAst, typeNamesTracker };
        // Generate elements code
        const elementsWithoutRoot = _elementMethodsAst.filter(({ elementName }) => elementName !== shared_1.UTAM_ROOT_ELEMENT &&
            elementName !== shared_1.UTAM_DOCUMENT_ELEMENT &&
            elementName !== shared_1.UTAM_NAVIGATION_ELEMENT);
        const elementClassMethods = elementsWithoutRoot.map((e) => class_body_generator_1.generateElementMethodCode(e));
        // pass the class body context so that's it's accessible to all types of compose statements (method, predicates...)
        const classBodyContext = {
            methodName: '',
            astConfig,
            importsDestination: {
                extensions: utilityImports,
                imports,
                typedImports,
            },
            typeIdentifiers: _typeIdentifiers,
            typeNamesTracker,
        };
        // Generate methods code
        const composeClassMethods = _composeMethodsAst.map((m) => {
            classBodyContext.methodName = m.methodName;
            return statements_body_generator_1.generateComposeMethodCode(classBodyContext, m, _typeIdentifiers);
        });
        const interfaceMethods = this._interfaceMethodAst.map((c) => class_body_generator_1.generateInterfaceMethodCode(c));
        // Generate beforeLoad code
        classBodyContext.methodName = shared_1.BEFORE_LOAD_METHOD_NAME;
        const beforeLoadMethod = _beforeLoadMethod.map((m) => statements_body_generator_1.generateComposeMethodCode(classBodyContext, {
            methodName: shared_1.BEFORE_LOAD_METHOD_NAME,
            statements: m.statements,
            orderedArgs: [],
            description: [],
            argsTypeMap: {},
            argsDescriptionMap: {},
        }, _typeIdentifiers));
        // Generate root code
        const rootClassMethods = _rootMethod.map((root) => class_body_generator_1.generateRootElementMethodCode(root));
        const publicClassMethods = [
            ...beforeLoadMethod,
            ...rootClassMethods,
            ...elementClassMethods,
            ...composeClassMethods,
            ...interfaceMethods,
        ].join('\n\n');
        // Interface
        const isInterfaceStaticProp = _isInterface ? `static isInterface = true;` : '';
        const locator = _byIdentifier && _rootSelector
            ? `locator = ${primitive_arguments_1.buildLiteralSelectorCode(_rootSelector, _byIdentifier)}`
            : 'locator';
        // Platform
        const mobileContextStaticProp = _platform ? `static mobileContext = "${_platform}";` : '';
        const jsDocString = jsdoc_transformers_1.textToJsDoc(_description);
        return code_1.code `
            ${jsDocString}
            export default class ${camelCaseName} extends ${_extendsClassNameIdentifier} {
                constructor(driver, element, ${locator}) {
                    super(driver, element, locator);
                }

                ${publicClassMethods}
                ${isInterfaceStaticProp}
                ${mobileContextStaticProp}
            }
        `;
    }
    generateTypeDefinition() {
        const { _className, _extendsClassNameIdentifier, _webdriverTypeIdentifier, _webelementTypeIdentifier, _locatorTypeIdentifier, _typeIdentifiers, _description, } = this;
        const kebabClassName = naming_1.kebabcaseToCamelcase(_className);
        const elementClassMethods = this._elementMethodsAst.filter((p) => p.isPublic);
        const classMethods = [...this._composeMethodsAst, ...this._interfaceMethodAst]
            .map((method) => class_body_generator_1.generateBaseMethodTypeDefinition(method, _typeIdentifiers))
            .join('\n');
        const elementClassDefMethods = elementClassMethods.map((elMethod) => class_body_generator_1.generateElementMethodTypeDefinition(elMethod, _typeIdentifiers));
        const jsDocString = jsdoc_transformers_1.textToJsDoc(_description);
        return code_1.code `
            ${jsDocString}
            export default class ${kebabClassName} extends ${_extendsClassNameIdentifier} {
                constructor(driver: ${_webdriverTypeIdentifier}, element?: ${_webelementTypeIdentifier}, locator?: ${_locatorTypeIdentifier});
                ${classMethods}
                ${elementClassDefMethods}
            }
        `;
    }
    render() {
        const { skipCodeGen, skipTypeGen } = this._options;
        return {
            code: skipCodeGen ? undefined : this.generateCode(),
            typeDefinition: skipTypeGen ? undefined : this.generateTypeDefinition(),
        };
    }
}
exports.ClassBody = ClassBody;
//# sourceMappingURL=class-body.js.map