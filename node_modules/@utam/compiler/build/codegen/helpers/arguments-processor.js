"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseArguments = exports.findElementRefWithCollectedArgs = void 0;
const primitive_arguments_1 = require("../../utils/primitive-arguments");
const shared_1 = require("../shared");
const class_body_generator_1 = require("./class-body-generator");
/**
 * find and return element reference together with collected element args
 * if element was already "visited" (args already collected), return empty array of element args
 * @param elementName name of the element
 * @param elementMethodsAst array of known element getters
 * @param visitedElements tracker of visited elements
 * @returns array of non literal args and reference to a getter method
 */
function findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst) {
    const elementRefAst = class_body_generator_1.findElementAst(elementName, elementMethodsAst);
    // element was already "visited" (args already collected)
    if (visitedElements.has(elementName)) {
        return { elementRefAst, elementArgs: [] };
    }
    visitedElements.add(elementName);
    const elementArgs = Object.entries(elementRefAst.argsTypeMap).map(([name, type]) => {
        const description = elementRefAst.argsDescriptionMap[name];
        const arg = {
            name,
            type,
            // can be undefined
            description,
            literal: false,
        };
        return arg;
    });
    return { elementRefAst, elementArgs };
}
exports.findElementRefWithCollectedArgs = findElementRefWithCollectedArgs;
/**
 * find and return referenced method parameter
 * @param arg argument object
 * @param context traversal context with visited args and method args
 * @returns undefined if element was already referenced or found arg
 */
function findReferencedArg(arg, context) {
    const { visitedMethodArgsNames, methodArgs } = context;
    const { name: argName } = arg;
    if (!visitedMethodArgsNames.has(argName)) {
        const methodArg = methodArgs.find((methodArg) => methodArg.name === argName);
        // Here we explicitly cast methodArg.
        // We know that methodArg will be defined as all reference args points to
        // existing method args. Otherwise the validation of the PO would have thrown
        const { name, type, description } = methodArg;
        visitedMethodArgsNames.add(argName);
        return { type, name, literal: false, description };
    }
}
function traverseElementReference(reducer, arg, astConfig, options, context) {
    const { visitedElements } = context;
    const { elementMethodsAst } = astConfig;
    const nestedLiteralArgs = arg.args;
    // if element reference has nested literal args - recursive traversal
    if (nestedLiteralArgs) {
        const nestedArgs = traverseArguments(nestedLiteralArgs, astConfig, options, context);
        reducer.push(...nestedArgs);
    }
    else {
        const elementName = arg.value;
        // collect args of the element getter if exist
        const inferredArgs = findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst)
            .elementArgs;
        reducer.push(...inferredArgs);
    }
}
function traversePredicateStatement(reducer, predicate, astConfig, options, context) {
    const { visitedElements } = context;
    const { elementMethodsAst } = astConfig;
    const { chain: isChain = false } = predicate;
    const elementName = predicate.element ?? 'self';
    // collect args of the element getter if exist
    const elementArgs = elementName === 'self' || isChain
        ? []
        : findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst).elementArgs;
    elementArgs.forEach((arg) => reducer.push(arg));
    // recursive traversal of predicate statements
    const nestedArgs = traverseArguments(predicate.args, astConfig, options, context);
    reducer.push(...nestedArgs);
    // predicate statement can have matcher that requires further traversal
    if (predicate.matcher && predicate.matcher.args) {
        const matcherArgs = traverseArguments(predicate.matcher.args, astConfig, options, context);
        reducer.push(...matcherArgs);
    }
}
function traverseSelectorValue(reducer, arg, astConfig, options, context) {
    const nestedArgs = traverseArguments(arg.args, astConfig, options, context);
    reducer.push(...nestedArgs);
}
/**
 * traverse args deep into predicates to collect ALL method parameters
 * @param args declared args
 * @param astConfig context of the processed page object
 * @param options context to processed args
 * @returns array of explicit args
 */
function traverseArguments(args, astConfig = { typeNamesTracker: new Map() }, options = {}, context) {
    const flatArgs = [];
    if (!args) {
        return flatArgs;
    }
    return args.reduce((reducer, arg) => {
        const implicitLiteral = !arg.type || arg.type === 'literal';
        const value = arg.value;
        const type = implicitLiteral ? primitive_arguments_1.deriveLiteralType(value) : arg.type;
        const literal = 'value' in arg || type === 'function';
        const explicitArg = { ...arg, type, literal };
        // Early return of reference arg that aren't considered literal anymore
        // as they must be added to the compose method's parameters.
        // This block ensure we only add reference arg once to the compose args
        if (type === shared_1.UTAM_ARGUMENT_REFERENCE_ARG_TYPE && context) {
            const referencedArg = findReferencedArg(arg, context);
            // if same arg was already referenced, method returned undefined
            // so nothing is pushed to returned args as it's already there
            if (referencedArg) {
                reducer.push(referencedArg);
            }
            return reducer;
        }
        if (!literal || !options.excludeLiterals) {
            // Skip literals when option being passed
            reducer.push(explicitArg);
        }
        // Recursively walk all the nested arguments on the function, locator or element
        // We need to get both explicit arguments and implicit element arguments
        if (options.deep && literal && astConfig && context) {
            if (type === 'elementReference') {
                traverseElementReference(reducer, arg, astConfig, options, context);
            }
            else if (type === 'locator') {
                traverseSelectorValue(reducer, value, astConfig, options, context);
            }
            else if (type === 'function') {
                arg.predicate.forEach((predicate) => {
                    traversePredicateStatement(reducer, predicate, astConfig, options, context);
                });
            }
        }
        return reducer;
    }, flatArgs);
}
exports.traverseArguments = traverseArguments;
//# sourceMappingURL=arguments-processor.js.map