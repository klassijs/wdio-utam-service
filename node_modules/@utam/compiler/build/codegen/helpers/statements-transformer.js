"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ArgImportsBuilder_rules;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgImportsBuilder = exports.transformComposeStatements = void 0;
const args_1 = require("../../utils/args");
const element_types_1 = require("../../utils/element-types");
const imports_1 = require("../../utils/imports");
const naming_1 = require("../../utils/naming");
const primitive_arguments_1 = require("../../utils/primitive-arguments");
const return_types_1 = require("../../utils/return-types");
const class_body_1 = require("../class-body");
const shared_1 = require("../shared");
const arguments_processor_1 = require("./arguments-processor");
const class_body_generator_1 = require("./class-body-generator");
function isUtamMethodUtility(method) {
    return method.applyExternal !== undefined;
}
/**
 * build utility statement with "applyExternal"
 * @param composeAction JSON object with the method statement
 * @param context statement context
 * @param traversalContext traversal context
 * @returns method statement ast
 */
function buildUtilityStatement(composeAction, context, traversalContext) {
    const { astConfig, importsDestination } = context;
    const { applyExternal, returnAll: returnsList = false, returnType = shared_1.UTAM_VOID_RETURN_TYPE } = composeAction;
    const moduleSpecifier = applyExternal.type;
    const namedImport = applyExternal.invoke;
    const applyArgs = arguments_processor_1.traverseArguments(applyExternal.args, astConfig);
    const nonLiteralArgs = arguments_processor_1.traverseArguments(applyExternal.args, astConfig, {
        deep: true,
        excludeLiterals: true,
    }, traversalContext);
    const { composeArgs, argsNamesValidator } = traversalContext;
    argsNamesValidator(nonLiteralArgs);
    composeArgs.push(...nonLiteralArgs);
    // inside predicate not needed
    imports_1.addImport(moduleSpecifier, namedImport, importsDestination.extensions);
    // utility relies only on explicitely declared return type
    const explicitReturnType = return_types_1.getExplicitReturnType(returnType, astConfig.typeNamesTracker);
    return {
        applyFunction: applyExternal.invoke,
        applyFunctionArgs: applyArgs,
        moduleReference: applyExternal.type,
        returnType: explicitReturnType,
        returnsList,
    };
}
/**
 * build getter statement, could be chained or with self element
 * @param composeAction JSON object with the method statement
 * @param elementReferense reference if an element is from same JSON
 * @param explicitArgs getter explicit args declared in JSON
 * @param returnType return type object
 * @returns method statement ast
 */
function buildGetterStatement(composeAction, elementReferense, explicitArgs, returnType) {
    const { element: elementName = 'self', chain: isChain = false, returnAll: returnsList = false, matcher, } = composeAction;
    // element getter is called on self from same page object
    if (elementReferense?.elementRefAst) {
        const { elementArgs, elementRefAst } = elementReferense;
        // if args are explicitely set - use those that are explicit instead ones from ElementReferenceAst
        const getterArgs = primitive_arguments_1.mergeElementAndExplicitArgs(elementArgs, explicitArgs);
        // todo - if returnType or returnAll is set - verify
        return {
            elementName: 'self',
            applyFunction: elementRefAst.methodName,
            applyFunctionArgs: getterArgs,
            isChain,
            returnsList: matcher ? false : elementRefAst.selectorReturnsList && elementRefAst.filterReturnsList,
            returnType,
            matcher: matcher,
        };
    }
    // chain element getter from another PO
    if (!isChain) {
        // never happens in reality, checked during validation phase
        throw new Error(`Unable to find accessor for an element with name "${elementName}".`);
    }
    return {
        applyFunction: naming_1.elementToMethodName(elementName, true),
        applyFunctionArgs: explicitArgs,
        isChain,
        returnType,
        returnsList,
        matcher: matcher,
    };
}
/**
 * Infer cardinality of return type if possible. We can do it only if statement uses an element from the same page object.
 *
 * @param composeAction JSON statement
 * @param returnTypeKind if return type is void, cardinality is not list
 * @param context elements context to access element types
 * @returns boolean true if inferred to return list and last statement (for predicate) or current statement
 */
function inferStatementReturnCardinality(composeAction, returnTypeKind, context) {
    const elementMethodsAst = context.astConfig.elementMethodsAst;
    const lastStatement = composeAction.apply === 'waitFor' ? args_1.getLastPredicateStatement(composeAction) : composeAction;
    if (lastStatement.matcher || returnTypeKind === shared_1.UTAM_RETURN_CATEGORY_VOID) {
        return { returnsList: false, lastStatement };
    }
    const { element, chain: isChain = false, returnAll: returnsList = false } = lastStatement;
    if (element && !isChain) {
        // returnAll might be inferred if getter invoked
        const elementRefAst = arguments_processor_1.findElementRefWithCollectedArgs(element, new Set(), elementMethodsAst).elementRefAst;
        if (elementRefAst) {
            return { returnsList: elementRefAst.selectorReturnsList && elementRefAst.filterReturnsList, lastStatement };
        }
    }
    return { returnsList, lastStatement };
}
/**
 * transform compose statements array with apply/applyExternal into
 * array of AST objects and accumulated args
 * @param context statements context
 * @param compose compose statements
 * @param methodArgs args at the method level
 * @returns transformed statements
 */
function transformComposeStatements(context, compose, methodArgs) {
    const { astConfig } = context;
    const { elementMethodsAst, typeNamesTracker } = astConfig;
    const validateUniqueArgumentsNames = primitive_arguments_1.createUniqueNamesValidator(context.methodName);
    const generateReturnType = return_types_1.createReturnTypeGenerator(typeNamesTracker, elementMethodsAst);
    const traversalContext = {
        visitedElements: new Set(),
        visitedMethodArgsNames: new Set(),
        argsNamesValidator: validateUniqueArgumentsNames,
        methodArgs: methodArgs,
        composeArgs: [],
    };
    const { visitedElements, composeArgs } = traversalContext;
    const importsBuilder = new ArgImportsBuilder(typeNamesTracker);
    let returnType = return_types_1.RETURN_TYPE_VOID;
    let lastStatementReturn = compose[compose.length - 1].returnType;
    let lastStatementReturnAll = false;
    const composeStatements = compose.map((composeAction, index) => {
        const isLastStatement = index === compose.length - 1;
        if (isUtamMethodUtility(composeAction)) {
            return buildUtilityStatement(composeAction, context, traversalContext);
        }
        // for waitFor always replace caller element by "this"
        if (composeAction.apply === 'waitFor') {
            composeAction.element = 'self';
        }
        const { element: elementName = 'self', chain: isChain = false, matcher } = composeAction;
        // collect compose arguments
        const applyArgs = arguments_processor_1.traverseArguments(composeAction.args, astConfig);
        const elementAst = elementName === 'self' || isChain
            ? { elementArgs: [] }
            : arguments_processor_1.findElementRefWithCollectedArgs(elementName, visitedElements, elementMethodsAst);
        const { elementRefAst } = elementAst;
        // first check if explicit returnType is set or use default
        const statementReturnType = generateReturnType(composeAction, elementRefAst?.type);
        // then try to infer
        const { returnsList, lastStatement } = inferStatementReturnCardinality(composeAction, statementReturnType.returnTypeKind, context);
        if (isLastStatement) {
            returnType = statementReturnType;
            addImportForGetterReturnType(lastStatement, context);
            lastStatementReturn = lastStatement.returnType;
            lastStatementReturnAll = returnsList;
        }
        // getter can be invoked with explicit args, so ignore its default args
        const elementArgs = !composeAction.apply && applyArgs.length > 0 && !isChain ? [] : elementAst.elementArgs;
        // collect element arguments, empty for 'self' and chain statements
        validateUniqueArgumentsNames(elementArgs);
        composeArgs.push(...elementArgs);
        // add missing imports for locator, frame, pageObject and rootPageObject from statement args
        const importsData = importsBuilder.mapArgToImports(applyArgs);
        imports_1.addMissingImportsFromStatementsArgs(context, importsData);
        const nonLiteralArgs = arguments_processor_1.traverseArguments(composeAction.args, astConfig, {
            deep: true,
            excludeLiterals: true,
        }, traversalContext);
        // collect matcher arguments
        const nonLiteralMatcherArgs = arguments_processor_1.traverseArguments(composeAction.matcher?.args, astConfig, {
            excludeLiterals: true,
        });
        const statementNonLiteralArgs = [
            ...nonLiteralArgs,
            ...nonLiteralMatcherArgs,
        ];
        validateUniqueArgumentsNames(statementNonLiteralArgs);
        composeArgs.push(...statementNonLiteralArgs);
        // element getters
        if (!composeAction.apply) {
            return buildGetterStatement(composeAction, elementAst, applyArgs, statementReturnType);
        }
        if (!elementRefAst) {
            if (!isChain) {
                // self method called
                return {
                    elementName,
                    applyFunction: composeAction.apply,
                    applyFunctionArgs: applyArgs,
                    matcher,
                    isChain,
                    returnType: statementReturnType,
                    returnsList,
                };
            }
            // action applied to element(s) returned from previous statement
            return {
                applyFunction: composeAction.apply,
                applyFunctionArgs: applyArgs,
                matcher,
                isChain,
                returnType: statementReturnType,
                returnsList,
            };
        }
        // regular element + apply action
        return {
            elementName,
            elementType: elementRefAst.type,
            elementNullable: elementRefAst.nullable ?? false,
            elementGetMethod: elementRefAst.methodName,
            elementArgs: elementRefAst.orderedArgs,
            isChain,
            returnType: statementReturnType,
            returnsList,
            applyFunction: composeAction.apply,
            applyFunctionArgs: applyArgs,
            matcher,
        };
    });
    return { statements: composeStatements, composeArgs, returnType, lastStatementReturnAll, lastStatementReturn };
}
exports.transformComposeStatements = transformComposeStatements;
/**
 * Class that creates imports objects from the compose statement arguments.
 * Those object can be destructured and passed to the addImport function to update
 * the class imports maps.
 */
class ArgImportsBuilder {
    /**
     * Creates a new ArgImportsBuilder object
     * @param typesNamesTracker type names collisions tracker for imports
     */
    constructor(typesNamesTracker) {
        /** import rules maps */
        _ArgImportsBuilder_rules.set(this, void 0);
        __classPrivateFieldSet(this, _ArgImportsBuilder_rules, new Map()
            .set(shared_1.UTAM_FRAME_ARG_TYPE, this.buildFrameArgImports)
            .set(shared_1.UTAM_LOCATOR_ARG_TYPE, this.buildLocatorArgImports)
            .set(shared_1.UTAM_ROOT_PAGE_OBJECT_ARG_TYPE, (arg) => this.buildPageObjectArgImports(arg, typesNamesTracker))
            .set(shared_1.UTAM_PAGE_OBJECT_ARG_TYPE, (arg) => this.buildPageObjectArgImports(arg, typesNamesTracker)), "f");
    }
    /**
     * Construct and return import data for non literal frame argument
     * @param arg internal representation of a utam argument
     */
    buildFrameArgImports(arg) {
        if (arg.literal)
            return [];
        return [
            {
                moduleSpecifier: shared_1.UTAM_CORE_MODULE,
                name: shared_1.UTAM_FRAME_ELEMENT_CTOR,
                destination: 'typedImports',
                defaultImport: false,
            },
        ];
    }
    /**
     * Construct and return import data for literal css locator argument
     * @param arg internal representation of a utam argument
     */
    buildLocatorArgImports(arg) {
        if (!arg.literal)
            return [];
        return [
            {
                moduleSpecifier: shared_1.UTAM_CORE_MODULE,
                name: shared_1.UTAM_LOCATOR_BY,
                destination: 'imports',
                defaultImport: false,
            },
        ];
    }
    /**
     * Construct and return import data for rootPageObject and pageObject argument
     * @param arg internal representation of a utam argument
     */
    buildPageObjectArgImports(arg, typeNamesTracker) {
        if (arg.literal) {
            const moduleSpecifier = arg
                .value;
            const name = naming_1.buildImportNameFromModulePath(moduleSpecifier, typeNamesTracker);
            return [
                {
                    moduleSpecifier,
                    name,
                    destination: 'imports',
                    defaultImport: true,
                },
            ];
        }
        return [
            {
                moduleSpecifier: shared_1.UTAM_CORE_MODULE,
                name: shared_1.UTAM_PAGE_OBJECT_CTOR,
                destination: 'typedImports',
                defaultImport: false,
            },
            {
                moduleSpecifier: shared_1.UTAM_CORE_MODULE,
                name: arg.type === shared_1.UTAM_ROOT_PAGE_OBJECT_ARG_TYPE ? shared_1.UTAM_BASE_ROOT_CLASS_NAME : shared_1.UTAM_BASE_CLASS_NAME,
                destination: 'typedImports',
                defaultImport: false,
            },
        ];
    }
    /**
     * Map a list of compose statement arguments to imports data.
     * Those imports data are added to the class body import maps in order
     * to generate imports for some identifiers that would be missing otherwise
     *
     * @param args compose statement arguments
     * @returns a list of imports data
     */
    mapArgToImports(args) {
        return args.flatMap((arg) => {
            const { type } = arg;
            if (!__classPrivateFieldGet(this, _ArgImportsBuilder_rules, "f").has(type)) {
                return [];
            }
            const createImportsFromArg = __classPrivateFieldGet(this, _ArgImportsBuilder_rules, "f").get(type);
            const imports = createImportsFromArg(arg);
            return imports;
        });
    }
}
exports.ArgImportsBuilder = ArgImportsBuilder;
_ArgImportsBuilder_rules = new WeakMap();
/**
 * Adds imports for basic element who might be private but returned by a getter inside a compose method
 *
 * @param lastStatement last statement
 * @param context statements context
 */
function addImportForGetterReturnType(lastStatement, context) {
    const { astConfig, importsDestination } = context;
    const { typeNamesTracker } = astConfig;
    const { element, apply, chain: isChain = false } = lastStatement;
    if (element && !apply && !isChain) {
        const { typedImports } = importsDestination;
        const elementAst = class_body_generator_1.findElementAst(element, astConfig.elementMethodsAst);
        const { type } = elementAst;
        if (type !== shared_1.UTAM_DOCUMENT_ELEMENT && type !== shared_1.UTAM_NAVIGATION_ELEMENT && element_types_1.isCustomType(type)) {
            imports_1.addImport(type, naming_1.buildImportNameFromModulePath(type, typeNamesTracker), typedImports, true);
        }
        else if (element_types_1.isBasicElement(type)) {
            const elementType = element_types_1.wrapSingleBasicTypeInArray(type);
            imports_1.addImport(shared_1.UTAM_CORE_MODULE, class_body_1.getBasicElementTypeCtor(shared_1.UTAM_ELEMENT_DEFAULT_TYPE), typedImports, false);
            elementType.forEach((utamElementType) => {
                imports_1.addImport(shared_1.UTAM_CORE_MODULE, class_body_1.getBasicElementTypeCtor(utamElementType), typedImports, false);
            });
        }
    }
}
//# sourceMappingURL=statements-transformer.js.map