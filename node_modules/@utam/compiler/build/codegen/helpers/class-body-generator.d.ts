import { MethodArgumentsTypeMap, MethodArgumentsDescriptionMap, UtamStatementElementType, TypeNamesTracker } from '@utam/types';
export interface AstConfig {
    elementMethodsAst?: ElementMethodAst[];
    typeNamesTracker: TypeNamesTracker;
}
interface BaseMethodAst {
    methodName: string;
    isPublic: boolean;
    argsTypeMap: MethodArgumentsTypeMap;
    argsDescriptionMap: MethodArgumentsDescriptionMap;
    orderedArgs: string[];
    typeConstructor: string;
    returnsList: boolean;
    description: string[];
}
export declare type InterfaceMethodAst = BaseMethodAst;
export interface RootElementMethodAst extends BaseMethodAst {
    elementName: string;
    type: UtamStatementElementType;
    isPublic: boolean;
    selectorReturnsList: boolean;
}
export declare function generateRootElementMethodCode(methodAst: RootElementMethodAst): string;
export declare function generateInterfaceMethodCode(methodAst: InterfaceMethodAst): string;
export interface ElementMethodAst extends RootElementMethodAst {
    args: string[];
    hoistedFunctionIdentifier: string;
    parentArgs: string[];
    nullable: boolean;
    parentNullable: boolean;
    hasSelector: boolean;
    filterFunctionIdentifier?: string;
    filterFunctionArgs: string[];
    filterReturnsList: boolean;
    returnsList: boolean;
}
/**
 * Actions like containsElement and dragAndDrop accept objects as parameters (Locator and BaseUtamElement accordingly).
 * Declarations of methods need imported object types - composeContains(locatorArg: _Locator) and composeDragAndDrop(elementArg: _BaseUtamElement).
 * This helper provides correct types to replace JSON non literal types like "locator" and "element" by an imported type
 */
export interface TypeIdentifiers {
    _containerType?: string;
    _containerReturnTypeGenericBound?: string;
    _byIdentifier?: string;
    _locatorTypeIdentifier?: string;
    _elementTypeIdentifier?: string;
    _frameElementTypeIdentifier?: string;
    _pageObjectTypeIdentifier?: string;
    _rootPageObjectTypeIdentifier?: string;
}
/**
 * Generate method signature for type definition of compose or interface methods (not getters!)
 *
 * @param BaseMethodAst AST with method signature
 * @param typeIdentifiers config with mapping of some type names to the type identifiers
 * @returns method declaration string
 */
export declare function generateBaseMethodTypeDefinition({ methodName, orderedArgs, argsTypeMap, argsDescriptionMap, typeConstructor, returnsList, description, }: BaseMethodAst, typeIdentifiers: TypeIdentifiers): string;
export declare function generateElementMethodCode(elementAst: ElementMethodAst): string;
export declare function generateElementMethodTypeDefinition({ methodName, type, parentArgs, args, hasSelector, argsTypeMap: rawArgsMap, argsDescriptionMap, nullable, parentNullable, filterFunctionArgs, typeConstructor, returnsList, description, }: ElementMethodAst, typeIdentifiers: TypeIdentifiers): string;
export declare function findElementAst(elementName: string, elementMethodsAst?: ElementMethodAst[]): ElementMethodAst;
export {};
//# sourceMappingURL=class-body-generator.d.ts.map