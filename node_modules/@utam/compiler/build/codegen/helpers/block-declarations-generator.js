"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFilterApplicationDeclarationCode = exports.generateFilterDeclarationCode = exports.generateSelectorDeclarationCode = exports.validateState = void 0;
const code_1 = require("../../utils/code");
const matchers_1 = require("../../utils/matchers");
const primitive_arguments_1 = require("../../utils/primitive-arguments");
const shared_1 = require("../shared");
function validateState(declarations, by) {
    if (declarations.length && !by) {
        // if Page Object has only container element it does not need by
        const isContainerPageObject = declarations.length === 1 && declarations[0].isContainer;
        if (!isContainerPageObject) {
            throw new Error('Invalid state while generating module: By identifier must be defined if any declaration exists');
        }
    }
}
exports.validateState = validateState;
function validateShadowExistance(insideShadow, byShadow) {
    if (insideShadow && !byShadow) {
        throw new Error('Invalid state while generating module: Shadow Identifier must be defined if any declaration exists');
    }
}
function generateSelectorDeclarationCode(ast, { byId, shadowId }) {
    // Get context variables for generating the code
    const { name, parentName, selector, parentArgs, parentNullable, insideShadow, isContainer, nullable, parentSelectorReturnsList, parentFilterApplicationName, } = ast;
    const LOCATOR_ID = '_locator';
    const ELEMENT_ID = parentSelectorReturnsList ? '_elements' : '_element';
    validateShadowExistance(ast.insideShadow, shadowId);
    const { returnAll, args = [] } = selector;
    const containerExternalSelector = isContainer && !selector.css;
    const containerArgs = containerExternalSelector ? [shared_1.UTAM_CONTAINER_LOCATOR] : [];
    const allArgs = ['driver', 'root', ...parentArgs, ...primitive_arguments_1.getArgumentsNames(args), ...containerArgs]; // Merge arguments from hierarchy
    const findElementMethod = returnAll ? 'findElements' : 'findElement';
    // Compute expressions to compose the final statements
    // Don't pass args to the element getter for a nested element of a filtered element
    // as args are passed to the filter application hoisted function
    const elementArgs = parentSelectorReturnsList && parentFilterApplicationName ? [] : parentArgs;
    const getElementExpression = parentName
        ? `await ${parentName}(driver, ${'root'.concat(code_1.buildAddedArgs(elementArgs))})`
        : `root`;
    const locatorExpression = containerExternalSelector
        ? shared_1.UTAM_CONTAINER_LOCATOR // for container selector is passed as method parameter, otherwise hardcoded css
        : primitive_arguments_1.buildLiteralSelectorCode(selector, byId);
    const elementStatement = `let ${ELEMENT_ID} = ${getElementExpression};`;
    const locatorStatement = `const ${LOCATOR_ID} = ${locatorExpression};`;
    const shadowStatement = insideShadow ? `${ELEMENT_ID} = new ${shadowId}(driver, ${ELEMENT_ID});` : '';
    const parentNullableStatement = parentNullable ? `if (!${ELEMENT_ID}) { return null; }` : '';
    const nullableStatements = nullable
        ? [
            `const hasElement = await ${ELEMENT_ID}.containsElement(${LOCATOR_ID});`,
            `if (!hasElement) { return null; }`,
        ]
        : [];
    const FILTERED_ELEMENT_ID = '_filteredElement';
    const parentFilterParameters = ELEMENT_ID.concat(code_1.buildAddedArgs(parentArgs));
    const filterParentElementStatement = parentSelectorReturnsList && parentFilterApplicationName
        ? `const ${FILTERED_ELEMENT_ID} = await ${parentFilterApplicationName}(${parentFilterParameters});`
        : '';
    const returnedElementId = parentSelectorReturnsList ? FILTERED_ELEMENT_ID : ELEMENT_ID;
    const statements = [
        elementStatement,
        parentNullableStatement,
        locatorStatement,
        shadowStatement,
        nullableStatements.join('\n'),
        filterParentElementStatement,
        `return ${returnedElementId}.${findElementMethod}(${LOCATOR_ID});`,
    ].filter(Boolean); // We filter falsy values to remove unnecesary "\n"
    return code_1.code `
        async function ${name}(${allArgs.join(', ')}) {
            ${statements}
        }
    `;
}
exports.generateSelectorDeclarationCode = generateSelectorDeclarationCode;
function generateFilterDeclarationCode(ast, byId) {
    const { filter: { apply, matcher, args = [] }, name, parentArgs, } = ast;
    // FIXME:
    // filter should be able to accept any types of parameters, not just primitives or locator
    // which requires adding ability to import custom types and such
    let applyArgs = '';
    if (args) {
        applyArgs = args.map((arg) => primitive_arguments_1.generateUtamArgumentValueCode(arg, byId)).join(', ');
    }
    const filterApplyCode = `await element.${apply}(${applyArgs})`;
    let matcherArg = '';
    if (matcher?.args) {
        matcherArg = matcher.args.map((arg) => primitive_arguments_1.generateUtamArgumentValueCode(arg, byId)).join(', ');
    }
    // on top of args inside filter, those can be in selector or in matcher
    const additionalArgs = primitive_arguments_1.getArgumentsNames(matcher?.args);
    const filterFunctionCode = matchers_1.buildFilterFunctionCode(matcher.type, filterApplyCode, matcherArg);
    // Merge arguments from hierarchy
    const allArgs = ['element', ...parentArgs, ...primitive_arguments_1.getArgumentsNames(args), ...additionalArgs].join(', ');
    return code_1.code `
        async function ${name}(${allArgs}) {
           ${filterFunctionCode}
        }
    `;
}
exports.generateFilterDeclarationCode = generateFilterDeclarationCode;
/**
 * Generates the code for the hoisted filter application.
 *
 * This code is being generated when an element has a filter and a nested tree of elements.
 * It's generated once when processing the parent element and the function name is stored in the
 * SelectorDeclarationAST context so that it can be referenced when generating the nested elements hoisted getters.
 *
 * @param ast AST that holds the required information for generating this function
 * @returns the generated code for the hoisted filter application function
 */
function generateFilterApplicationDeclarationCode(ast) {
    const { filter: { matcher, args = [] }, name, elementName, filterFunctionName, parentArgs, } = ast;
    // on top of args inside filter, those can be in selector or in matcher
    const additionalArgs = primitive_arguments_1.getArgumentsNames(matcher?.args);
    // Merge arguments from hierarchy
    const filterArgs = [...primitive_arguments_1.getArgumentsNames(args), ...additionalArgs];
    const allArgs = [...parentArgs, ...primitive_arguments_1.getArgumentsNames(args), ...additionalArgs];
    const filterFunctionParameters = 'el'.concat(code_1.buildAddedArgs(filterArgs));
    const functionParameters = 'elements'.concat(code_1.buildAddedArgs(allArgs));
    return code_1.code `
        async function ${name}(${functionParameters}) {
            const appliedFilter = await Promise.all(
                elements.map((el) => ${filterFunctionName}(${filterFunctionParameters}))
            );
            let _element = elements.find((_, i) => appliedFilter[i]);
            if (!_element) {
                throw new Error('Could not find element "${elementName.toString()}" that matches filter condition!');
            }
            return _element;
        }
    `;
}
exports.generateFilterApplicationDeclarationCode = generateFilterApplicationDeclarationCode;
//# sourceMappingURL=block-declarations-generator.js.map