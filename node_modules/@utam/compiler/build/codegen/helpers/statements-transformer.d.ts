/**
 * Types and methods to map grammar objects with statements into AST.
 * Used by compose statements, beforeLoad and predicate
 *
 * @since 0.0.7-alpha7
 */
import { ExplicitNonLiteralArg, ExplicitUtamArgument, MethodDeclarationArgument, UtamArgument, UtamMethodAction, UtamMethodUtility, TypeNamesTracker } from '@utam/types';
import { ReturnType } from '../../utils/return-types';
import { AstConfig, TypeIdentifiers } from './class-body-generator';
import { MethodStatementAst } from './statements-body-generator';
/**
 * context of the accumulated statementwith reference to element methods and imports
 */
export interface StatementsContext {
    /**
     * method name is required for an error message
     */
    methodName: string;
    astConfig: AstConfig;
    importsDestination: ImportsDestinations;
    typeIdentifiers: TypeIdentifiers;
}
interface ImportsDestinations {
    extensions: Map<string, Map<string, string>>;
    imports: Map<string, Map<string, string>>;
    typedImports: Map<string, Map<string, string>>;
}
/**
 * Processed composes tatements.
 * Intermittent helper structure containing of JSON fields and AST.
 */
export interface TransformedStatements {
    /**
     * compose statements
     */
    statements: MethodStatementAst[];
    /**
     * accumulated args from all statements
     */
    composeArgs: ExplicitNonLiteralArg[];
    /**
     * return type, will be used in method declaration and imports
     */
    returnType: ReturnType;
    /**
     * boolean indicating that last statement returns an array. Can be inferred or explicitely declared.
     */
    lastStatementReturnAll: boolean;
    /**
     * last statement "returnType" string, can be inferred or explicitely declared.
     * if last statement is waitFor should be last predicate statement
     * can be undefined because statement might not have "returnType"
     */
    lastStatementReturn: string | undefined;
}
/**
 * transform compose statements array with apply/applyExternal into
 * array of AST objects and accumulated args
 * @param context statements context
 * @param compose compose statements
 * @param methodArgs args at the method level
 * @returns transformed statements
 */
export declare function transformComposeStatements(context: StatementsContext, compose: Array<UtamMethodAction | UtamMethodUtility>, methodArgs: Array<MethodDeclarationArgument>): TransformedStatements;
/**
 * Object that group all parameters required to generate an import.
 * Generating an import is done by mutating a ClassBody import map by calling the addImport function.
 *
 * @see {addImport}
 */
export interface ModuleImport {
    /** the import statement module specifier  */
    moduleSpecifier: string;
    /** the import name in the import statement */
    name: string;
    /** the class body import destination name */
    destination: keyof Omit<ImportsDestinations, 'extensions'>;
    /** indicates if the import is a default import or not */
    defaultImport: boolean;
}
/**
 * Class that creates imports objects from the compose statement arguments.
 * Those object can be destructured and passed to the addImport function to update
 * the class imports maps.
 */
export declare class ArgImportsBuilder {
    #private;
    /**
     * Creates a new ArgImportsBuilder object
     * @param typesNamesTracker type names collisions tracker for imports
     */
    constructor(typesNamesTracker: TypeNamesTracker);
    /**
     * Construct and return import data for non literal frame argument
     * @param arg internal representation of a utam argument
     */
    buildFrameArgImports(arg: ExplicitUtamArgument<UtamArgument>): ModuleImport[];
    /**
     * Construct and return import data for literal css locator argument
     * @param arg internal representation of a utam argument
     */
    buildLocatorArgImports(arg: ExplicitUtamArgument<UtamArgument>): ModuleImport[];
    /**
     * Construct and return import data for rootPageObject and pageObject argument
     * @param arg internal representation of a utam argument
     */
    buildPageObjectArgImports(arg: ExplicitUtamArgument<UtamArgument>, typeNamesTracker: TypeNamesTracker): ModuleImport[];
    /**
     * Map a list of compose statement arguments to imports data.
     * Those imports data are added to the class body import maps in order
     * to generate imports for some identifiers that would be missing otherwise
     *
     * @param args compose statement arguments
     * @returns a list of imports data
     */
    mapArgToImports(args: ExplicitUtamArgument<UtamArgument>[]): ModuleImport[];
}
export {};
//# sourceMappingURL=statements-transformer.d.ts.map