"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.findElementAst = exports.generateElementMethodTypeDefinition = exports.generateElementMethodCode = exports.generateBaseMethodTypeDefinition = exports.generateInterfaceMethodCode = exports.generateRootElementMethodCode = void 0;
const code_1 = require("../../utils/code");
const container_helpers_1 = require("../../utils/container-helpers");
const element_constructors_1 = require("../../utils/element-constructors");
const element_types_1 = require("../../utils/element-types");
const imports_1 = require("../../utils/imports");
const shared_1 = require("../shared");
const jsdoc_transformers_1 = require("../../utils/jsdoc-transformers");
// generate root element getter
function generateRootElementMethodCode(methodAst) {
    const { methodName, typeConstructor, type } = methodAst;
    const basicElementCtorName = element_constructors_1.createCtorNameFromTypes(type);
    const utamBasicElementCtors = element_constructors_1.mapBasicTypesToCtors(type);
    return code_1.code `
        async ${methodName}() {
            const driver = this.driver;
            const root = await this.getRootElement();
            const ${basicElementCtorName} = ${typeConstructor}(${utamBasicElementCtors});
            return new ${basicElementCtorName}(driver, root);
        }
        `;
}
exports.generateRootElementMethodCode = generateRootElementMethodCode;
function generateInterfaceMethodCode(methodAst) {
    const { methodName, description, orderedArgs, argsDescriptionMap } = methodAst;
    const argsStr = orderedArgs.join(', ');
    const jsDoc = jsdoc_transformers_1.buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code_1.code `
    ${jsDoc}
    async ${methodName}(${argsStr}) {
        throw new Error(\`Interface method "${methodName}" was not implemented by the concrete implementation class.\`);
    }`;
}
exports.generateInterfaceMethodCode = generateInterfaceMethodCode;
/**
 * generates string with parameters for a method signature, used for code in type definition
 * @param argsNames array with args names
 * @param argsMap method arguments
 * @param typeIdentifiers config with mapping of some type names to the type identifiers
 * @returns parameters for method declaration, ex. "strArg: string, numArg: number"
 */
function generateArgsForMethodSignature(argsNames, argsMap, typeIdentifiers) {
    const typedArgs = argsNames.map((argName) => {
        const argType = argsMap[argName];
        if (!argType) {
            throw new Error(`Unable to match type of the '${argName}' argument`);
        }
        let declaredType;
        switch (argType) {
            case shared_1.UTAM_ELEMENT_REFERENCE_ARG_TYPE:
                // "element" type should be declared as _BaseUtamElement
                declaredType = typeIdentifiers._elementTypeIdentifier;
                break;
            case shared_1.UTAM_FRAME_ARG_TYPE:
                declaredType = typeIdentifiers._frameElementTypeIdentifier;
                break;
            case shared_1.UTAM_PAGE_OBJECT_ARG_TYPE:
                declaredType = `${typeIdentifiers._pageObjectTypeIdentifier}<T>`;
                break;
            case shared_1.UTAM_ROOT_PAGE_OBJECT_ARG_TYPE:
                declaredType = `${typeIdentifiers._rootPageObjectTypeIdentifier}<T>`;
                break;
            case shared_1.UTAM_LOCATOR_ARG_TYPE:
                // "locator" type should be declared as _Locator
                declaredType = typeIdentifiers._locatorTypeIdentifier;
                break;
            default:
                // primitive types remain as is
                declaredType = argType;
        }
        return `${argName}: ${declaredType}`;
    });
    return typedArgs.join(', ');
}
/**
 * Generate method signature for type definition of compose or interface methods (not getters!)
 *
 * @param BaseMethodAst AST with method signature
 * @param typeIdentifiers config with mapping of some type names to the type identifiers
 * @returns method declaration string
 */
function generateBaseMethodTypeDefinition({ methodName, orderedArgs, argsTypeMap, argsDescriptionMap, typeConstructor, returnsList, description, }, typeIdentifiers) {
    const pageObjectOrRootPageObjectArg = Object.values(argsTypeMap).find((type) => type === shared_1.UTAM_ROOT_PAGE_OBJECT_ARG_TYPE || type === shared_1.UTAM_PAGE_OBJECT_ARG_TYPE);
    const isRootPageObjectType = typeConstructor === shared_1.UTAM_BASE_ROOT_CLASS_NAME ||
        pageObjectOrRootPageObjectArg === shared_1.UTAM_ROOT_PAGE_OBJECT_ARG_TYPE;
    // if method accepts PO type as parameter, add <T extends...> to declaration
    const genericPageObjectType = pageObjectOrRootPageObjectArg
        ? `<T extends ${imports_1.buildIdentifier(isRootPageObjectType ? shared_1.UTAM_BASE_ROOT_CLASS_NAME : shared_1.UTAM_BASE_CLASS_NAME)}>`
        : '';
    const methodArgumentsTyped = generateArgsForMethodSignature(orderedArgs, argsTypeMap, typeIdentifiers);
    const listType = returnsList ? '[]' : '';
    const jsDoc = jsdoc_transformers_1.buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    const isReturnTypePageObject = 
    // typeConstructor starts from "_", like "_UtamBasePageObject"
    typeConstructor.endsWith(shared_1.UTAM_BASE_ROOT_CLASS_NAME) || typeConstructor.endsWith(shared_1.UTAM_BASE_CLASS_NAME);
    // if method returns page object AND accepts PO type as parameter - it should return Promise<T>
    const returnType = pageObjectOrRootPageObjectArg && isReturnTypePageObject ? 'T' : typeConstructor;
    return code_1.code `
        ${jsDoc}
        ${methodName}${genericPageObjectType}(${methodArgumentsTyped}): Promise<${returnType}${listType}>;
    `;
}
exports.generateBaseMethodTypeDefinition = generateBaseMethodTypeDefinition;
// generate element getter
function generateElementMethodCode(elementAst) {
    const { methodName, type, args, parentArgs, nullable, parentNullable, hoistedFunctionIdentifier, typeConstructor, hasSelector, selectorReturnsList, returnsList, filterFunctionIdentifier, filterFunctionArgs, filterReturnsList, description, argsDescriptionMap, orderedArgs, elementName, } = elementAst;
    const hasContainer = element_types_1.isContainerElement(type);
    const nullableType = nullable || parentNullable;
    const methodArguments = getElementMethodArgs(elementAst).join(', ');
    const hoistedMethodArguments = code_1.buildAddedArgs([
        ...parentArgs,
        ...args,
        ...(hasContainer && !hasSelector ? [shared_1.UTAM_CONTAINER_LOCATOR] : []),
    ]);
    const elementsVarName = selectorReturnsList ? 'elements' : 'element';
    const findStatement = code_1.code `let ${elementsVarName} = await ${hoistedFunctionIdentifier}(driver, root${hoistedMethodArguments});`;
    const nullableStatement = nullableType ? `if (!${elementsVarName}) { return null; }` : '';
    /*
     * Return UtamClass statement:
     * elements.map((e) => { new Ctor(e, ...args); });
     */
    const basicElementCtorName = element_constructors_1.createCtorNameFromTypes(type) || typeConstructor;
    const utamBasicElementCtors = element_constructors_1.mapBasicTypesToCtors(type);
    const basicElementConstructorStatement = Array.isArray(type)
        ? `const ${basicElementCtorName} = ${typeConstructor}(${utamBasicElementCtors});`
        : '';
    /**
     * Create statement
     */
    const customElementFactoryFn = imports_1.buildIdentifier(shared_1.UTAM_ELEMENT_FACTORY_FN);
    const Ctor = Array.isArray(type) ? basicElementCtorName : typeConstructor;
    const createStatementSingle = element_types_1.isCustomType(type)
        ? code_1.code `${elementsVarName} = await ${customElementFactoryFn}(${typeConstructor}, driver, ${elementsVarName});`
        : code_1.code `${elementsVarName} = new ${Ctor}(driver, ${elementsVarName});`;
    const createStatementList = element_types_1.isCustomType(type)
        ? code_1.code `${elementsVarName} = await Promise.all(${elementsVarName}.map(function _createElement(element) {
            return ${customElementFactoryFn}(${typeConstructor}, driver, element);
        }));`
        : code_1.code `${elementsVarName} = ${elementsVarName}.map(function _createElement(element) {
            return new ${basicElementCtorName}(driver, element);
        });`;
    const createStatement = returnsList || filterFunctionIdentifier ? createStatementList : createStatementSingle;
    /*
     * Filter statement:
     * await Promise.all(elements.map(el => filterPredicate(el)))
     *              .then(find first match or return undefined);
     */
    let filterStatement = '';
    if (filterFunctionIdentifier) {
        const filterArgs = code_1.buildAddedArgs(filterFunctionArgs);
        const operandId = 'el';
        // find first match or apply filter depending on "findFirst" property
        const filterCollector = filterReturnsList ? 'filter' : 'find';
        // add code that checks if match not found
        const matchNotFoundCondition = filterReturnsList
            ? `!${elementsVarName} || ${elementsVarName}.length === 0`
            : `!${elementsVarName}`;
        // if match not found, for nullable we return null or empty array, for not nullable throw
        const matchNotFoundConditionResult = nullable
            ? filterReturnsList
                ? 'return [];'
                : 'return null;'
            : `throw new Error('Could not find element "${elementName}" that matches filter condition!');`;
        filterStatement = code_1.code `
        const appliedFilter = await Promise.all(${elementsVarName}.map(${operandId} => ${filterFunctionIdentifier}(${operandId}${filterArgs})));
        ${elementsVarName} = ${elementsVarName}.${filterCollector}((_, i) => appliedFilter[i]);
        if(${matchNotFoundCondition}) {
            ${matchNotFoundConditionResult}
        }
        `;
    }
    let beforeLoadStatement = '';
    if (element_types_1.isCustomType(type)) {
        const operandId = 'el';
        beforeLoadStatement = returnsList
            ? `await Promise.all(${elementsVarName}.map(${operandId} => ${operandId}.${shared_1.BEFORE_LOAD_METHOD_NAME}()));`
            : `await ${elementsVarName}.${shared_1.BEFORE_LOAD_METHOD_NAME}();`;
    }
    const statements = [
        basicElementConstructorStatement,
        findStatement,
        nullableStatement,
        createStatement,
        filterStatement,
        beforeLoadStatement,
        // Filter falsy values to remove unnecesary "\n"
    ]
        .filter(Boolean)
        .join('\n');
    const jsDoc = jsdoc_transformers_1.buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code_1.code `
        ${jsDoc}
        async ${methodName}(${methodArguments}) {
            const driver = this.driver;
            const root = await this.getRootElement();
            ${statements}
            return ${elementsVarName};
        }`;
}
exports.generateElementMethodCode = generateElementMethodCode;
// accumulate all args of an element getter: parent, selector, filter
function getElementMethodArgs({ hasSelector, parentArgs = [], args = [], filterFunctionArgs = [], type, }) {
    return [
        ...parentArgs,
        ...args,
        ...(element_types_1.isContainerElement(type)
            ? hasSelector
                ? [shared_1.UTAM_CONTAINER_CTOR]
                : [shared_1.UTAM_CONTAINER_CTOR, shared_1.UTAM_CONTAINER_LOCATOR]
            : []),
        ...filterFunctionArgs,
    ];
}
// generate element getter method signature for type definition
function generateElementMethodTypeDefinition({ methodName, type, parentArgs, args, hasSelector, argsTypeMap: rawArgsMap, argsDescriptionMap, nullable, parentNullable, filterFunctionArgs, typeConstructor, returnsList, description, }, typeIdentifiers) {
    const { _containerType, _containerReturnTypeGenericBound, _byIdentifier } = typeIdentifiers;
    const containerType = type && element_types_1.isContainerElement(type);
    const listType = returnsList ? '[]' : '';
    const nullableType = nullable || parentNullable ? ' | null' : '';
    let constructorType = typeConstructor;
    if (Array.isArray(type)) {
        constructorType = element_constructors_1.createBasicElementCtorType(type);
    }
    else if (containerType) {
        constructorType = 'T';
    }
    const genericPrefixType = containerType && _containerReturnTypeGenericBound ? `<T extends ${_containerReturnTypeGenericBound}>` : '';
    const orderedArgs = [
        ...parentArgs,
        ...args,
        ...(containerType ? (hasSelector ? [shared_1.UTAM_CONTAINER_CTOR] : [shared_1.UTAM_CONTAINER_CTOR, shared_1.UTAM_CONTAINER_LOCATOR]) : []),
        ...filterFunctionArgs,
    ];
    const argsTypeMap = containerType
        ? container_helpers_1.modifyArgumentsForContainer(rawArgsMap, _containerType, _byIdentifier)
        : rawArgsMap;
    const methodArgumentsTyped = generateArgsForMethodSignature(orderedArgs, argsTypeMap, typeIdentifiers);
    const jsDoc = jsdoc_transformers_1.buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code_1.code `
        ${jsDoc}
        ${methodName}${genericPrefixType}(${methodArgumentsTyped}): Promise<${constructorType}${listType}${nullableType}>;
    `;
}
exports.generateElementMethodTypeDefinition = generateElementMethodTypeDefinition;
// find element AST by element name
function findElementAst(elementName, elementMethodsAst) {
    if (!elementMethodsAst) {
        throw new Error(`Unable to search for an element "${elementName}" accessor: context of element methods is undefined`);
    }
    const elementRefAst = elementMethodsAst.find((ast) => ast.elementName === elementName);
    if (!elementRefAst) {
        // never happens in reality, checked during validation phase
        throw new Error(`Unable to find accessor for an element with name "${elementName}".`);
    }
    return elementRefAst;
}
exports.findElementAst = findElementAst;
//# sourceMappingURL=class-body-generator.js.map