"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComposeMethodCode = void 0;
/**
 * types and methods related to the generation of methods with multiple statements
 *
 * @since 0.0.7-alpha7
 */
const diagnostics_1 = require("@utam/diagnostics");
const code_1 = require("../../utils/code");
const errors_1 = require("../../utils/errors");
const imports_1 = require("../../utils/imports");
const matchers_1 = require("../../utils/matchers");
const naming_1 = require("../../utils/naming");
const primitive_arguments_1 = require("../../utils/primitive-arguments");
const jsdoc_transformers_1 = require("../../utils/jsdoc-transformers");
const shared_1 = require("../shared");
const arguments_processor_1 = require("./arguments-processor");
const class_body_generator_1 = require("./class-body-generator");
const statements_transformer_1 = require("./statements-transformer");
function isExtensionStatement(statement) {
    return statement.moduleReference !== undefined;
}
function isSelfStatement(statement) {
    return statement.elementName === 'self';
}
function isChainStatement(statement) {
    return statement.isChain && !('elementName' in statement);
}
// depending on the matcher, generate result string
function generateResultStatement(matcher, statementIndex, byId) {
    const resultId = `_result${statementIndex}`;
    if (matcher) {
        // matcher does not have nested or referenced args
        const args = arguments_processor_1.traverseArguments(matcher.args);
        const matcherArgsStr = args.map((arg) => primitive_arguments_1.generateArgumentValueCode(arg, byId)).join(', ');
        const matcherExpression = matchers_1.generateMatcherCode(matcher.type, matcherArgsStr);
        const matcherId = `_matcher${statementIndex}`;
        return { matcherCode: `const ${matcherId} = ${resultId}${matcherExpression};`, resultId: matcherId };
    }
    else {
        return { matcherCode: '', resultId: resultId };
    }
}
function generateReturnStatement(isLastStatementAndReturnsValue, resultId) {
    return isLastStatementAndReturnsValue ? `return ${resultId};` : '';
}
function isLastStatementAndReturnsValue(returnType, isLastStatement) {
    const returnsVoid = returnType.returnTypeValue === shared_1.UTAM_VOID_RETURN_TYPE;
    const returnsStatementValue = isLastStatement && !returnsVoid;
    return returnsStatementValue;
}
function generateChainStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, applyFunctionArgs = [], matcher, returnsList, returnType } = statement;
    const { index, isPreviousStatementList, isLastStatement } = statementContext;
    const calleeName = `_statement${index - 1}`;
    const resultId = `_result${index}`;
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const flatFn = returnsList && isPreviousStatementList ? `.flat()` : ``;
    const invokeExpr = isPreviousStatementList
        ? `(await Promise.all(${calleeName}.map(_it => _it.${applyFunction}(${applyArgs}))))${flatFn};`
        : `await ${calleeName}.${applyFunction}(${applyArgs});`;
    // Invoke
    const invokeStatement = !isLastStatement
        ? `const _statement${index} = ${invokeExpr}`
        : returnsStatementValue || matcher
            ? `const ${resultId} = ${invokeExpr}`
            : `${invokeExpr}`;
    // Match
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    const resultStatement = generateResultStatement(matcher, index, byId);
    // Return
    const returnStatement = generateReturnStatement(returnsStatementValue, resultStatement.resultId);
    return code_1.code `
        ${invokeStatement}
        ${resultStatement.matcherCode}
        ${returnStatement}
    `;
}
// generates code for a statement with "self"
function generateSelfStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, matcher, applyFunctionArgs = [], isChain, returnType } = statement;
    const { index, isNextStatementChain, isLastStatement } = statementContext;
    const resultId = `_result${index}`;
    const statementId = `_statement${index}`;
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    // We need to save the result of the getter invocation in a variable if next statement is chained
    const calleeName = isChain ? `_statement${index - 1}` : `this`;
    const invokeStatementSingle = isNextStatementChain && !isLastStatement
        ? `const ${statementId} = await ${calleeName}.${applyFunction}(${applyArgs});`
        : `await ${calleeName}.${applyFunction}(${applyArgs});`;
    // Invoke
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const invokeStatement = returnsStatementValue || matcher ? `const ${resultId} = ${invokeStatementSingle}` : `${invokeStatementSingle}`;
    // Match
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    const resultStatement = generateResultStatement(matcher, index, byId);
    // Return
    const returnStatement = generateReturnStatement(returnsStatementValue, resultStatement.resultId);
    return code_1.code `
                ${invokeStatement}
                ${resultStatement.matcherCode}
                ${returnStatement}
            `;
}
// generates code for a statement that invokes an imperative extension
// unlike other statement types it does not have "element" or "matcher"
function generateImperativeExtensionStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, applyFunctionArgs = [], returnType } = statement;
    const { index, isNextStatementChain, isLastStatement } = statementContext;
    const resultId = `_result${index}`;
    const statementId = `_statement${index}`;
    const pageObjectContext = `{ pageObject: this }`;
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    const parameters = applyArgs.length ? [pageObjectContext, applyArgs].join(', ') : pageObjectContext;
    const invokeStatementSingle = `await _${applyFunction}(${parameters})`;
    // Invoke
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const invokeStatement = returnsStatementValue
        ? `const ${resultId} = ${invokeStatementSingle}`
        : isNextStatementChain
            ? `const ${statementId} = ${invokeStatementSingle}`
            : `${invokeStatementSingle}`;
    // Return (matcher not allowed inside applyExternal statement)
    const returnStatement = generateReturnStatement(returnsStatementValue, resultId);
    return code_1.code `
                ${invokeStatement}
                ${returnStatement}
            `;
}
// generates code for a regular "element" + "apply" statement
function generateRegularStatement(context, typeIdentifiers, statement, statementContext) {
    const { applyFunction, applyFunctionArgs = [], matcher, elementName, isChain, returnsList, elementGetMethod: elementCaller, elementArgs = [], returnType, } = statement;
    const { index, isLastStatement, isPreviousStatementList, visitedElements } = statementContext;
    const { astConfig } = context;
    const { elementMethodsAst } = astConfig;
    let elementNullable = false;
    if (!isChain) {
        const elementAst = class_body_generator_1.findElementAst(elementName, elementMethodsAst);
        elementNullable = elementAst.nullable;
    }
    // Setup args and identifiers
    const elementAlreadyVisited = visitedElements.has(elementName);
    const elmId = elementAlreadyVisited ? visitedElements.get(elementName) : `_statement${index}`;
    // add the element to visited
    visitedElements.set(elementName, elmId);
    // Setup args and identifiers
    const resultId = `_result${index}`;
    const elmArgs = elementArgs.join(', ');
    const applyArgs = generateArgumentsCodeFromExplicitArgs(context, applyFunctionArgs, typeIdentifiers);
    // Separate the expression in two for readability (otherwise should be ternary operator)
    const applyExpressionSingle = `await ${elmId}.${applyFunction}(${applyArgs})`;
    const applyExpressionList = `await Promise.all(${elmId}.map((_it) => _it.${applyFunction}(${applyArgs})))`;
    // if apply function is 'size', we return number of found elements
    const applyExpressionLength = `${elmId}.length`;
    const applyExpr = applyFunction === 'size'
        ? applyExpressionLength
        : returnsList || isPreviousStatementList
            ? applyExpressionList
            : applyExpressionSingle;
    // Invoke
    const elementStatement = elementAlreadyVisited ? '' : `const ${elmId} = await this.${elementCaller}(${elmArgs});`;
    const elementNullStatement = elementNullable
        ? `if(${elmId} === null) { return ${returnsList ? '[]' : 'null'}; }`
        : '';
    const returnsStatementValue = isLastStatementAndReturnsValue(returnType, isLastStatement);
    const applyStatement = returnsStatementValue || matcher ? `const ${resultId} = ${applyExpr};` : `${applyExpr};`;
    // Match
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    const resultStatement = generateResultStatement(matcher, index, byId);
    // Return
    const returnStatement = generateReturnStatement(returnsStatementValue, resultStatement.resultId);
    return code_1.code `
            ${elementStatement}
            ${elementNullStatement}
            ${applyStatement}
            ${resultStatement.matcherCode}
            ${returnStatement}
        `;
}
// generate code lines for statements
function generateStatementsCode(context, statements, typeIdentifiers) {
    const visited = new Map();
    return statements.map((statement, index, all) => {
        const isLastStatement = all.length - 1 === index;
        const isFirstStatement = index === 0;
        const previousStatement = isFirstStatement ? null : all[index - 1];
        const nextStatement = isLastStatement ? null : all[index + 1];
        const isNextStatementChain = nextStatement && !isExtensionStatement(nextStatement) ? !!nextStatement?.isChain : false;
        const { returnTypeKind, returnTypeValue } = statement.returnType;
        if (returnTypeKind !== shared_1.UTAM_RETURN_CATEGORY_CUSTOM_ELEMENT && isNextStatementChain) {
            const { methodName } = context;
            throw new errors_1.UtamValidationError(diagnostics_1.descriptions.METHOD.INFERRED_TYPE_NOT_CUSTOM_NEXT_STATEMENT_IS_CHAIN(methodName, returnTypeValue));
        }
        const statementContext = {
            index,
            isPreviousStatementList: !!previousStatement?.returnsList,
            isNextStatementChain,
            isLastStatement,
            visitedElements: visited,
        };
        if (shared_1.RETURN_SELF_ACTION === statement.applyFunction) {
            return 'return this;';
        }
        if (isExtensionStatement(statement)) {
            return generateImperativeExtensionStatement(context, typeIdentifiers, statement, statementContext);
        }
        if (isChainStatement(statement)) {
            return generateChainStatement(context, typeIdentifiers, statement, statementContext);
        }
        if (isSelfStatement(statement)) {
            return generateSelfStatement(context, typeIdentifiers, statement, statementContext);
        }
        return generateRegularStatement(context, typeIdentifiers, statement, statementContext);
    });
}
/**
 * generate code for a method composed of declared statements
 *
 * @param astConfig context of the current page object with elements and methods information
 * @param methodAst abstract representation of the method declared in JSON
 */
function generateComposeMethodCode(context, methodAst, typeIdentifiers) {
    const { methodName, statements, orderedArgs, description, argsDescriptionMap } = methodAst;
    const statementsCode = generateStatementsCode(context, statements, typeIdentifiers);
    const jsDoc = jsdoc_transformers_1.buildMethodJsDoc(description, orderedArgs, argsDescriptionMap);
    return code_1.code `
    ${jsDoc}
    async ${methodName}(${orderedArgs.join(', ')}) {
        ${statementsCode.join('\n')}
    }`;
}
exports.generateComposeMethodCode = generateComposeMethodCode;
// generate predicate statements inside "waitFor" inside compose or beforeLoad methods
function generatePredicateStatement(context, predicate, typeIdentifiers) {
    context.methodName = 'predicate';
    // get all statements for each predicate recurcively
    const preProcessedStatements = statements_transformer_1.transformComposeStatements(context, predicate, []).statements;
    // generate code lines for each statement, those can have other waitFor/predicates inside
    const statementsCodeLines = generateStatementsCode(context, preProcessedStatements, typeIdentifiers).join('\n');
    // combine all statements into one async
    return (predicate &&
        code_1.code `
        async () => {
            ${statementsCodeLines}
        }`);
}
function generateElementReferenceCode(context, arg, typeIdentifiers) {
    const { astConfig } = context;
    const { elementMethodsAst } = astConfig;
    const elementName = arg.value;
    const elementAst = class_body_generator_1.findElementAst(elementName, elementMethodsAst);
    let elmGetterArgs = '';
    if (arg.args) {
        // args were already traversed earlier and parameters were added to a method context
        // we just need to collect them and build a string, hence no context passed to traversal
        const nestedArgs = arguments_processor_1.traverseArguments(arg.args, astConfig);
        elmGetterArgs = generateArgumentsCodeFromExplicitArgs(context, nestedArgs, typeIdentifiers);
    }
    else {
        const elementArgs = elementAst.orderedArgs;
        // infer args from getter
        elmGetterArgs = elementArgs.join(', ');
    }
    return `await this.${elementAst.methodName}(${elmGetterArgs})`;
}
function generateArgumentsCodeFromExplicitArgs(context, args, typeIdentifiers) {
    const { _byIdentifier: byId = '' } = typeIdentifiers;
    return args
        .map((arg) => {
        if (arg.literal) {
            if (arg.type === 'function') {
                // if type is "function", need to accumulate code from inside the predicate
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                return generatePredicateStatement(context, arg.predicate, typeIdentifiers);
            }
            if (arg.type === 'elementReference') {
                return generateElementReferenceCode(context, arg, typeIdentifiers);
            }
            // literal selector or element can have nested args and should be processed separately
            const value = arg.value;
            if (arg.type === shared_1.UTAM_LOCATOR_ARG_TYPE) {
                return primitive_arguments_1.buildLiteralSelectorCode(value, byId);
            }
            if (arg.type === shared_1.UTAM_ROOT_PAGE_OBJECT_ARG_TYPE || arg.type === shared_1.UTAM_PAGE_OBJECT_ARG_TYPE) {
                const importName = naming_1.buildImportNameFromModulePath(value, context.astConfig.typeNamesTracker);
                return imports_1.buildIdentifier(importName);
            }
        }
        // if not a function or object with nested args - get code from primitive args utils
        return primitive_arguments_1.generateArgumentValueCode(arg, byId);
    })
        .join(', ');
}
//# sourceMappingURL=statements-body-generator.js.map