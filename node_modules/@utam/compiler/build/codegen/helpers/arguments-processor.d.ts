/**
 * Functionality related to processing of arguments inside methods or elements
 *
 * @since 0.0.7-alpha7
 */
import { ExplicitNonLiteralArg, ExplicitUtamArgument, NonLiteralArgumentInternal, UtamArgument } from '@utam/types';
import { AstConfig, ElementMethodAst } from './class-body-generator';
export interface ElementReferenceAst {
    elementRefAst?: ElementMethodAst;
    elementArgs: ExplicitNonLiteralArg[];
}
/**
 * find and return element reference together with collected element args
 * if element was already "visited" (args already collected), return empty array of element args
 * @param elementName name of the element
 * @param elementMethodsAst array of known element getters
 * @param visitedElements tracker of visited elements
 * @returns array of non literal args and reference to a getter method
 */
export declare function findElementRefWithCollectedArgs(elementName: string, visitedElements: Set<string>, elementMethodsAst?: ElementMethodAst[]): ElementReferenceAst;
interface ArgsTraversalContext {
    visitedElements: Set<string>;
    visitedMethodArgsNames: Set<string>;
    methodArgs: NonLiteralArgumentInternal[];
}
interface ArgsTraversalOptions {
    deep?: boolean;
    excludeLiterals?: boolean;
}
/**
 * traverse args deep into predicates to collect ALL method parameters
 * @param args declared args
 * @param astConfig context of the processed page object
 * @param options context to processed args
 * @returns array of explicit args
 */
export declare function traverseArguments<T extends UtamArgument>(args: T[] | undefined, astConfig?: AstConfig, options?: ArgsTraversalOptions, context?: ArgsTraversalContext): ExplicitUtamArgument<T>[];
export {};
//# sourceMappingURL=arguments-processor.d.ts.map