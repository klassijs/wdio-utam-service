"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtamLoader = void 0;
const core_1 = require("@utam/core");
const config_loader_1 = require("./config-loader");
class UtamLoader {
    constructor(driver, config = { activeProfiles: {}, injectionConfigs: [] }) {
        this.By = core_1.By;
        this._driver = driver;
        this._config = config;
        this._elementAdapter = this._config.elementAdapter;
        this._activeProfiles = config.activeProfiles || {};
        this._availableProfiles = new Map();
        this._configLoader = new config_loader_1.UtamConfigLoader();
        this.setInjectionConfigs(config.injectionConfigs ?? []);
        core_1.UtamPageObjectProvider.setGetBridgeAppTitleAdapter(this.getBridgeAppTitle.bind(this));
        core_1.UtamPageObjectProvider.setPageObjectImplAdapter(this.getInterfaceImplementation.bind(this));
    }
    /**
     * @todo take some time to rethink and simplify internal representation or profiles
     * @param UtamCtor Page Object Interface Constructor for which we load a matching implementation
     * @returns the imported implementation of the Page Object
     */
    async getInterfaceImplementation(UtamCtor) {
        const loadedProfiles = [];
        for (const [key, value] of Object.entries(this._activeProfiles)) {
            const lookupKey = `${key}_${value}`;
            if (this._availableProfiles.has(lookupKey)) {
                loadedProfiles.push(...this._availableProfiles.get(lookupKey));
            }
        }
        // Append the default profile at the end of the loaded profiles so that it has lower precedence than
        // any other activated profile
        const defaultLookupKey = `${core_1.DEFAULT_PROFILE_NAME}_${core_1.DEFAULT_PROFILE_VALUE}`;
        if (this._availableProfiles.get(defaultLookupKey)) {
            loadedProfiles.push(...this._availableProfiles.get(defaultLookupKey));
        }
        for (const loadedProfile of loadedProfiles) {
            const { interface: interfaceType, implementation } = loadedProfile;
            const utamModule = (await Promise.resolve().then(() => __importStar(require(interfaceType)))).default;
            if (utamModule === UtamCtor) {
                const implCtor = (await Promise.resolve().then(() => __importStar(require(implementation)))).default;
                return implCtor;
            }
        }
        throw new Error(`Unable to find any valid implementation`);
    }
    /**
     * Loads dependency injection configurations in memory from a list of config paths.
     * This function isn't part of the loader public API and is used only in it's constructor
     * to load the dependency injection configs in memory. The filepath can be either:
     * - absolute on the file system (i.e /Users/foo/project/path/to/configfile.json)
     * - bare specifier appended with the exposed path to the config file (i.e my-package/path/to/configfile.json)
     * @param dependencyConfigFilepaths list of dependency injection config paths
     */
    setInjectionConfigs(dependencyConfigFilepaths) {
        dependencyConfigFilepaths.forEach((configFilepaths) => {
            this._configLoader.loadConfig(configFilepaths);
            this._availableProfiles = this._configLoader.getLoadedProfiles();
        });
    }
    setProfiles(...profiles) {
        const flattenArrayOfObject = (all, current) => ({ ...all, ...current });
        this._activeProfiles = { ...this._activeProfiles, ...profiles.reduce(flattenArrayOfObject) };
    }
    setProfile(name, value) {
        // todo - add validation that profile is configured
        this._activeProfiles[name] = value;
    }
    /**
     * creates instance of the Page Object and waits for presence of its root element
     * @param Ctor type/constructor for PO
     * @param scope injected selector
     */
    async load(Ctor, scope = {}) {
        if (process.env.NODE_ENV === 'production') {
            if (!(Ctor.prototype instanceof core_1.UtamBaseRootPageObject)) {
                throw new Error(`Only root Page Objects can be loaded directly in browser, { ${Ctor.name} } is not root or missing root property`);
            }
        }
        const rootCtor = Ctor.prototype instanceof core_1.UtamBasePageObject;
        const rootElementDefined = scope.element || scope.locator;
        if (!rootCtor && !rootElementDefined) {
            throw new Error('An element on the interface of UTAM Element or a Locator must be provided in order to load a PageObject');
        }
        const { locator, element } = scope;
        let utamElement;
        if (element) {
            if (!this._elementAdapter) {
                throw new Error(`Unable to load an element without an adapter`);
            }
            utamElement = this._elementAdapter(element);
        }
        if (!utamElement && locator) {
            utamElement = await this._driver.findElement(locator);
        }
        return core_1.createInstanceAndWaitForRoot(Ctor, this._driver, utamElement, locator);
    }
    /**
     * exposes Curent Document API from loader, ex. utam.getCurrentDocument().getUrl()
     *
     * @returns instance of a Document object
     */
    getCurrentDocument() {
        if (!this._document) {
            this._document = new core_1.DocumentUtamElement(this._driver);
        }
        return this._document;
    }
    /**
     * exposes Navigation API from loader
     *
     * @returns instance of a Navigation object
     */
    getNavigation() {
        if (!this._navigation) {
            this._navigation = new core_1.NavigationUtamElement(this._driver);
        }
        return this._navigation;
    }
    // (I)Frames APIs
    /**
     * Enters the (i)frame specified by the given frame element
     * @param frame frame element to enter into
     */
    enterFrame(frame) {
        return this.getCurrentDocument().enterFrame(frame);
    }
    /**
     * Exits focus from a(n) (i)frame to the immediate parent frame
     * @remarks
     * If already at the top-level frame, this is a no-op
     */
    exitToParentFrame() {
        return this.getCurrentDocument().exitToParentFrame();
    }
    /**
     * Exits focus from a(n) (i)frame to the page's default content
     * @remarks If already at the top-level frame, this is a no-op
     */
    exitFrame() {
        return this.getCurrentDocument().exitFrame();
    }
    /**
     * Enters a frame or iframe element and loads the specified Page Object as loaded in the frame
     * @param frame rame element to enter into
     * @param Ctor Type of the Root Page Object to Return
     * @returns instance of the Page Object, loaded in the frame
     */
    enterFrameAndLoad(frame, Ctor) {
        return this.getCurrentDocument().enterFrameAndLoad(frame, Ctor);
    }
    /**
     * mobile only - set bridge app title in loader config
     * @param title string with title
     */
    setBridgeAppTitle(title) {
        this._config.bridgeAppTitle = title;
    }
    /**
     * mobile only - get bridge app title from loader config
     */
    getBridgeAppTitle() {
        return this._config.bridgeAppTitle;
    }
    /**
     * Utility method to wrap action in test into fluent wait
     * @param condition condition or function to wait for
     * @param timeoutMsec optional custom timeout, if not set will use one from config
     */
    async waitFor(condition, timeoutMsec) {
        const waitForTimeout = timeoutMsec ?? this._driver.config?.explicitTimeout ?? core_1.DEFAULT_EXPLICIT_WAIT_TEIMEOUT;
        const interval = this._driver.config?.pollingInterval ?? core_1.DEFAULT_POLLING_INTERVAL;
        const options = { timeout: waitForTimeout, interval };
        return await this._driver.waitFor(condition, options);
    }
}
exports.UtamLoader = UtamLoader;
//# sourceMappingURL=index.js.map